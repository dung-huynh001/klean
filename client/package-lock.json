n(node) && node.body && isBlock(node.body) && hasReturnStatementWithPromiseHandler(node.body, checker) && returnsPromise(node, checker);
}
function returnsPromise(node, checker) {
  const signature = checker.getSignatureFromDeclaration(node);
  const returnType = signature ? checker.getReturnTypeOfSignature(signature) : void 0;
  return !!returnType && !!checker.getPromisedTypeOfPromise(returnType);
}
function getErrorNodeFromCommonJsIndicator(commonJsModuleIndicator) {
  return isBinaryExpression(commonJsModuleIndicator) ? commonJsModuleIndicator.left : commonJsModuleIndicator;
}
function hasReturnStatementWithPromiseHandler(body, checker) {
  return !!forEachReturnStatement(body, (statement) => isReturnStatementWithFixablePromiseHandler(statement, checker));
}
function isReturnStatementWithFixablePromiseHandler(node, checker) {
  return isReturnStatement(node) && !!node.expression && isFixablePromiseHandler(node.expression, checker);
}
function isFixablePromiseHandler(node, checker) {
  if (!isPromiseHandler(node) || !hasSupportedNumberOfArguments(node) || !node.arguments.every((arg) => isFixablePromiseArgument(arg, checker))) {
    return false;
  }
  let currentNode = node.expression.expression;
  while (isPromiseHandler(currentNode) || isPropertyAccessExpression(currentNode)) {
    if (isCallExpression(currentNode)) {
      if (!hasSupportedNumberOfArguments(currentNode) || !currentNode.arguments.every((arg) => isFixablePromiseArgument(arg, checker))) {
        return false;
      }
      currentNode = currentNode.expression.expression;
    } else {
      currentNode = currentNode.expression;
    }
  }
  return true;
}
function isPromiseHandler(node) {
  return isCallExpression(node) && (hasPropertyAccessExpressionWithName(node, "then") || hasPropertyAccessExpressionWithName(node, "catch") || hasPropertyAccessExpressionWithName(node, "finally"));
}
function hasSupportedNumberOfArguments(node) {
  const name = node.expression.name.text;
  const maxArguments = name === "then" ? 2 : name === "catch" ? 1 : name === "finally" ? 1 : 0;
  if (node.arguments.length > maxArguments) return false;
  if (node.arguments.length < maxArguments) return true;
  return maxArguments === 1 || some(node.arguments, (arg) => {
    return arg.kind === 106 /* NullKeyword */ || isIdentifier(arg) && arg.text === "undefined";
  });
}
function isFixablePromiseArgument(arg, checker) {
  switch (arg.kind) {
    case 262 /* FunctionDeclaration */:
    case 218 /* FunctionExpression */:
      const functionFlags = getFunctionFlags(arg);
      if (functionFlags & 1 /* Generator */) {
        return false;
      }
    case 219 /* ArrowFunction */:
      visitedNestedConvertibleFunctions.set(getKeyFromNode(arg), true);
    case 106 /* NullKeyword */:
      return true;
    case 80 /* Identifier */:
    case 211 /* PropertyAccessExpression */: {
      const symbol = checker.getSymbolAtLocation(arg);
      if (!symbol) {
        return false;
      }
      return checker.isUndefinedSymbol(symbol) || some(skipAlias(symbol, checker).declarations, (d) => isFunctionLike(d) || hasInitializer(d) && !!d.initializer && isFunctionLike(d.initializer));
    }
    default:
      return false;
  }
}
function getKeyFromNode(exp) {
  return `${exp.pos.toString()}:${exp.end.toString()}`;
}
function canBeConvertedToClass(node, checker) {
  var _a, _b, _c, _d;
  if (isFunctionExpression(node)) {
    if (isVariableDeclaration(node.parent) && ((_a = node.symbol.members) == null ? void 0 : _a.size)) {
      return true;
    }
    const symbol = checker.getSymbolOfExpando(
      node,
      /*allowDeclaration*/
      false
    );
    return !!(symbol && (((_b = symbol.exports) == null ? void 0 : _b.size) || ((_c = symbol.members) == null ? void 0 : _c.size)));
  }
  if (isFunctionDeclaration(node)) {
    return !!((_d = node.symbol.members) == null ? void 0 : _d.size);
  }
  return false;
}
function canBeConvertedToAsync(node) {
  switch (node.kind) {
    case 262 /* FunctionDeclaration */:
    case 174 /* MethodDeclaration */:
    case 218 /* FunctionExpression */:
    case 219 /* ArrowFunction */:
      return true;
    default:
      return false;
  }
}

// src/services/transpile.ts
var optionsRedundantWithVerbatimModuleSyntax = /* @__PURE__ */ new Set([
  "isolatedModules"
]);
function transpileModule(input, transpileOptions) {
  return transpileWorker(
    input,
    transpileOptions,
    /*declaration*/
    false
  );
}
function transpileDeclaration(input, transpileOptions) {
  return transpileWorker(
    input,
    transpileOptions,
    /*declaration*/
    true
  );
}
var barebonesLibContent = `/// <reference no-default-lib="true"/>
interface Boolean {}
interface Function {}
interface CallableFunction {}
interface NewableFunction {}
interface IArguments {}
interface Number {}
interface Object {}
interface RegExp {}
interface String {}
interface Array<T> { length: number; [n: number]: T; }
interface SymbolConstructor {
    (desc?: string | number): symbol;
    for(name: string): symbol;
    readonly toStringTag: symbol;
}
declare var Symbol: SymbolConstructor;
interface Symbol {
    readonly [Symbol.toStringTag]: string;
}`;
var barebonesLibName = "lib.d.ts";
var barebonesLibSourceFile;
function transpileWorker(input, transpileOptions, declaration) {
  barebonesLibSourceFile ?? (barebonesLibSourceFile = createSourceFile(barebonesLibName, barebonesLibContent, { languageVersion: 99 /* Latest */ }));
  const diagnostics = [];
  const options = transpileOptions.compilerOptions ? fixupCompilerOptions(transpileOptions.compilerOptions, diagnostics) : {};
  const defaultOptions = getDefaultCompilerOptions2();
  for (const key in defaultOptions) {
    if (hasProperty(defaultOptions, key) && options[key] === void 0) {
      options[key] = defaultOptions[key];
    }
  }
  for (const option of transpileOptionValueCompilerOptions) {
    if (options.verbatimModuleSyntax && optionsRedundantWithVerbatimModuleSyntax.has(option.name)) {
      continue;
    }
    options[option.name] = option.transpileOptionValue;
  }
  options.suppressOutputPathCheck = true;
  options.allowNonTsExtensions = true;
  if (declaration) {
    options.declaration = true;
    options.emitDeclarationOnly = true;
    options.isolatedDeclarations = true;
  } else {
    options.declaration = false;
  }
  const newLine = getNewLineCharacter(options);
  const compilerHost = {
    getSourceFile: (fileName) => fileName === normalizePath(inputFileName) ? sourceFile : fileName === normalizePath(barebonesLibName) ? barebonesLibSourceFile : void 0,
    writeFile: (name, text) => {
      if (fileExtensionIs(name, ".map")) {
        Debug.assertEqual(sourceMapText, void 0, "Unexpected multiple source map outputs, file:", name);
        sourceMapText = text;
      } else {
        Debug.assertEqual(outputText, void 0, "Unexpected multiple outputs, file:", name);
        outputText = text;
      }
    },
    getDefaultLibFileName: () => barebonesLibName,
    useCaseSensitiveFileNames: () => false,
    getCanonicalFileName: (fileName) => fileName,
    getCurrentDirectory: () => "",
    getNewLine: () => newLine,
    fileExists: (fileName) => fileName === inputFileName || !!declaration && fileName === barebonesLibName,
    readFile: () => "",
    directoryExists: () => true,
    getDirectories: () => []
  };
  const inputFileName = transpileOptions.fileName || (transpileOptions.compilerOptions && transpileOptions.compilerOptions.jsx ? "module.tsx" : "module.ts");
  const sourceFile = createSourceFile(
    inputFileName,
    input,
    {
      languageVersion: getEmitScriptTarget(options),
      impliedNodeFormat: getImpliedNodeFormatForFile(
        toPath(inputFileName, "", compilerHost.getCanonicalFileName),
        /*packageJsonInfoCache*/
        void 0,
        compilerHost,
        options
      ),
      setExternalModuleIndicator: getSetExternalModuleIndicator(options),
      jsDocParsingMode: transpileOptions.jsDocParsingMode ?? 0 /* ParseAll */
    }
  );
  if (transpileOptions.moduleName) {
    sourceFile.moduleName = transpileOptions.moduleName;
  }
  if (transpileOptions.renamedDependencies) {
    sourceFile.renamedDependencies = new Map(Object.entries(transpileOptions.renamedDependencies));
  }
  let outputText;
  let sourceMapText;
  const inputs = declaration ? [inputFileName, barebonesLibName] : [inputFileName];
  const program = createProgram(inputs, options, compilerHost);
  if (transpileOptions.reportDiagnostics) {
    addRange(
      /*to*/
      diagnostics,
      /*from*/
      program.getSyntacticDiagnostics(sourceFile)
    );
    addRange(
      /*to*/
      diagnostics,
      /*from*/
      program.getOptionsDiagnostics()
    );
  }
  const result = program.emit(
    /*targetSourceFile*/
    void 0,
    /*writeFile*/
    void 0,
    /*cancellationToken*/
    void 0,
    /*emitOnlyDtsFiles*/
    declaration,
    transpileOptions.transformers,
    /*forceDtsEmit*/
    declaration
  );
  addRange(
    /*to*/
    diagnostics,
    /*from*/
    result.diagnostics
  );
  if (outputText === void 0) return Debug.fail("Output generation failed");
  return { outputText, diagnostics, sourceMapText };
}
function transpile(input, compilerOptions, fileName, diagnostics, moduleName) {
  const output = transpileModule(input, { compilerOptions, fileName, reportDiagnostics: !!diagnostics, moduleName });
  addRange(diagnostics, output.diagnostics);
  return output.outputText;
}
var commandLineOptionsStringToEnum;
function fixupCompilerOptions(options, diagnostics) {
  commandLineOptionsStringToEnum = commandLineOptionsStringToEnum || filter(optionDeclarations, (o) => typeof o.type === "object" && !forEachEntry(o.type, (v) => typeof v !== "number"));
  options = cloneCompilerOptions(options);
  for (const opt of commandLineOptionsStringToEnum) {
    if (!hasProperty(options, opt.name)) {
      continue;
    }
    const value = options[opt.name];
    if (isString(value)) {
      options[opt.name] = parseCustomTypeOption(opt, value, diagnostics);
    } else {
      if (!forEachEntry(opt.type, (v) => v === value)) {
        diagnostics.push(createCompilerDiagnosticForInvalidCustomType(opt));
      }
    }
  }
  return options;
}

// src/services/_namespaces/ts.NavigateTo.ts
var ts_NavigateTo_exports = {};
__export(ts_NavigateTo_exports, {
  getNavigateToItems: () => getNavigateToItems
});

// src/services/navigateTo.ts
function getNavigateToItems(sourceFiles, checker, cancellationToken, searchValue, maxResultCount, excludeDtsFiles, excludeLibFiles) {
  const patternMatcher = createPatternMatcher(searchValue);
  if (!patternMatcher) return emptyArray;
  const rawItems = [];
  const singleCurrentFile = sourceFiles.length === 1 ? sourceFiles[0] : void 0;
  for (const sourceFile of sourceFiles) {
    cancellationToken.throwIfCancellationRequested();
    if (excludeDtsFiles && sourceFile.isDeclarationFile) {
      continue;
    }
    if (shouldExcludeFile(sourceFile, !!excludeLibFiles, singleCurrentFile)) {
      continue;
    }
    sourceFile.getNamedDeclarations().forEach((declarations, name) => {
      getItemsFromNamedDeclaration(patternMatcher, name, declarations, checker, sourceFile.fileName, !!excludeLibFiles, singleCurrentFile, rawItems);
    });
  }
  rawItems.sort(compareNavigateToItems);
  return (maxResultCount === void 0 ? rawItems : rawItems.slice(0, maxResultCount)).map(createNavigateToItem);
}
function shouldExcludeFile(file, excludeLibFiles, singleCurrentFile) {
  return file !== singleCurrentFile && excludeLibFiles && (isInsideNodeModules(file.path) || file.hasNoDefaultLib);
}
function getItemsFromNamedDeclaration(patternMatcher, name, declarations, checker, fileName, excludeLibFiles, singleCurrentFile, rawItems) {
  const match = patternMatcher.getMatchForLastSegmentOfPattern(name);
  if (!match) {
    return;
  }
  for (const declaration of declarations) {
    if (!shouldKeepItem(declaration, checker, excludeLibFiles, singleCurrentFile)) continue;
    if (patternMatcher.patternContainsDots) {
      const fullMatch = patternMatcher.getFullMatch(getContainers(declaration), name);
      if (fullMatch) {
        rawItems.push({ name, fileName, matchKind: fullMatch.kind, isCaseSensitive: fullMatch.isCaseSensitive, declaration });
      }
    } else {
      rawItems.push({ name, fileName, matchKind: match.kind, isCaseSensitive: match.isCaseSensitive, declaration });
    }
  }
}
function shouldKeepItem(declaration, checker, excludeLibFiles, singleCurrentFile) {
  var _a;
  switch (declaration.kind) {
    case 273 /* ImportClause */:
    case 276 /* ImportSpecifier */:
    case 271 /* ImportEqualsDeclaration */:
      const importer = checker.getSymbolAtLocation(declaration.name);
      const imported = checker.getAliasedSymbol(importer);
      return importer.escapedName !== imported.escapedName && !((_a = imported.declarations) == null ? void 0 : _a.every((d) => shouldExcludeFile(d.getSourceFile(), excludeLibFiles, singleCurrentFile)));
    default:
      return true;
  }
}
function tryAddSingleDeclarationName(declaration, containers) {
  const name = getNameOfDeclaration(declaration);
  return !!name && (pushLiteral(name, containers) || name.kind === 167 /* ComputedPropertyName */ && tryAddComputedPropertyName(name.expression, containers));
}
function tryAddComputedPropertyName(expression, containers) {
  return pushLiteral(expression, containers) || isPropertyAccessExpression(expression) && (containers.push(expression.name.text), true) && tryAddComputedPropertyName(expression.expression, containers);
}
function pushLiteral(node, containers) {
  return isPropertyNameLiteral(node) && (containers.push(getTextOfIdentifierOrLiteral(node)), true);
}
function getContainers(declaration) {
  const containers = [];
  const name = getNameOfDeclaration(declaration);
  if (name && name.kind === 167 /* ComputedPropertyName */ && !tryAddComputedPropertyName(name.expression, containers)) {
    return emptyArray;
  }
  containers.shift();
  let container = getContainerNode(declaration);
  while (container) {
    if (!tryAddSingleDeclarationName(container, containers)) {
      return emptyArray;
    }
    container = getContainerNode(container);
  }
  return containers.reverse();
}
function compareNavigateToItems(i1, i2) {
  return compareValues(i1.matchKind, i2.matchKind) || compareStringsCaseSensitiveUI(i1.name, i2.name);
}
function createNavigateToItem(rawItem) {
  const declaration = rawItem.declaration;
  const container = getContainerNode(declaration);
  const containerName = container && getNameOfDeclaration(container);
  return {
    name: rawItem.name,
    kind: getNodeKind(declaration),
    kindModifiers: getNodeModifiers(declaration),
    matchKind: PatternMatchKind[rawItem.matchKind],
    isCaseSensitive: rawItem.isCaseSensitive,
    fileName: rawItem.fileName,
    textSpan: createTextSpanFromNode(declaration),
    // TODO(jfreeman): What should be the containerName when the container has a computed name?
    containerName: containerName ? containerName.text : "",
    containerKind: containerName ? getNodeKind(container) : "" /* unknown */
  };
}

// src/services/_namespaces/ts.NavigationBar.ts
var ts_NavigationBar_exports = {};
__export(ts_NavigationBar_exports, {
  getNavigationBarItems: () => getNavigationBarItems,
  getNavigationTree: () => getNavigationTree
});

// src/services/navigationBar.ts
var whiteSpaceRegex = /\s+/g;
var maxLength = 150;
var curCancellationToken;
var curSourceFile;
var parentsStack = [];
var parent;
var trackedEs5ClassesStack = [];
var trackedEs5Classes;
var emptyChildItemArray = [];
function getNavigationBarItems(sourceFile, cancellationToken) {
  curCancellationToken = cancellationToken;
  curSourceFile = sourceFile;
  try {
    return map(primaryNavBarMenuItems(rootNavigationBarNode(sourceFile)), convertToPrimaryNavBarMenuItem);
  } finally {
    reset();
  }
}
function getNavigationTree(sourceFile, cancellationToken) {
  curCancellationToken = cancellationToken;
  curSourceFile = sourceFile;
  try {
    return convertToTree(rootNavigationBarNode(sourceFile));
  } finally {
    reset();
  }
}
function reset() {
  curSourceFile = void 0;
  curCancellationToken = void 0;
  parentsStack = [];
  parent = void 0;
  emptyChildItemArray = [];
}
function nodeText(node) {
  return cleanText(node.getText(curSourceFile));
}
function navigationBarNodeKind(n) {
  return n.node.kind;
}
function pushChild(parent2, child) {
  if (parent2.children) {
    parent2.children.push(child);
  } else {
    parent2.children = [child];
  }
}
function rootNavigationBarNode(sourceFile) {
  Debug.assert(!parentsStack.length);
  const root = { node: sourceFile, name: void 0, additionalNodes: void 0, parent: void 0, children: void 0, indent: 0 };
  parent = root;
  for (const statement of sourceFile.statements) {
    addChildrenRecursively(statement);
  }
  endNode();
  Debug.assert(!parent && !parentsStack.length);
  return root;
}
function addLeafNode(node, name) {
  pushChild(parent, emptyNavigationBarNode(node, name));
}
function emptyNavigationBarNode(node, name) {
  return {
    node,
    name: name || (isDeclaration(node) || isExpression(node) ? getNameOfDeclaration(node) : void 0),
    additionalNodes: void 0,
    parent,
    children: void 0,
    indent: parent.indent + 1
  };
}
function addTrackedEs5Class(name) {
  if (!trackedEs5Classes) {
    trackedEs5Classes = /* @__PURE__ */ new Map();
  }
  trackedEs5Classes.set(name, true);
}
function endNestedNodes(depth) {
  for (let i = 0; i < depth; i++) endNode();
}
function startNestedNodes(targetNode, entityName) {
  const names = [];
  while (!isPropertyNameLiteral(entityName)) {
    const name = getNameOrArgument(entityName);
    const nameText = getElementOrPropertyAccessName(entityName);
    entityName = entityName.expression;
    if (nameText === "prototype" || isPrivateIdentifier(name)) continue;
    names.push(name);
  }
  names.push(entityName);
  for (let i = names.length - 1; i > 0; i--) {
    const name = names[i];
    startNode(targetNode, name);
  }
  return [names.length - 1, names[0]];
}
function startNode(node, name) {
  const navNode = emptyNavigationBarNode(node, name);
  pushChild(parent, navNode);
  parentsStack.push(parent);
  trackedEs5ClassesStack.push(trackedEs5Classes);
  trackedEs5Classes = void 0;
  parent = navNode;
}
function endNode() {
  if (parent.children) {
    mergeChildren(parent.children, parent);
    sortChildren(parent.children);
  }
  parent = parentsStack.pop();
  trackedEs5Classes = trackedEs5ClassesStack.pop();
}
function addNodeWithRecursiveChild(node, child, name) {
  startNode(node, name);
  addChildrenRecursively(child);
  endNode();
}
function addNodeWithRecursiveInitializer(node) {
  if (node.initializer && isFunctionOrClassExpression(node.initializer)) {
    startNode(node);
    forEachChild(node.initializer, addChildrenRecursively);
    endNode();
  } else {
    addNodeWithRecursiveChild(node, node.initializer);
  }
}
function hasNavigationBarName(node) {
  const name = getNameOfDeclaration(node);
  if (name === void 0) return false;
  if (isComputedPropertyName(name)) {
    const expression = name.expression;
    return isEntityNameExpression(expression) || isNumericLiteral(expression) || isStringOrNumericLiteralLike(expression);
  }
  return !!name;
}
function addChildrenRecursively(node) {
  curCancellationToken.throwIfCancellationRequested();
  if (!node || isToken(node)) {
    return;
  }
  switch (node.kind) {
    case 176 /* Constructor */:
      const ctr = node;
      addNodeWithRecursiveChild(ctr, ctr.body);
      for (const param of ctr.parameters) {
        if (isParameterPropertyDeclaration(param, ctr)) {
          addLeafNode(param);
        }
      }
      break;
    case 174 /* MethodDeclaration */:
    case 177 /* GetAccessor */:
    case 178 /* SetAccessor */:
    case 173 /* MethodSignature */:
      if (hasNavigationBarName(node)) {
        addNodeWithRecursiveChild(node, node.body);
      }
      break;
    case 172 /* PropertyDeclaration */:
      if (hasNavigationBarName(node)) {
        addNodeWithRecursiveInitializer(node);
      }
      break;
    case 171 /* PropertySignature */:
      if (hasNavigationBarName(node)) {
        addLeafNode(node);
      }
      break;
    case 273 /* ImportClause */:
      const importClause = node;
      if (importClause.name) {
        addLeafNode(importClause.name);
      }
      const { namedBindings } = importClause;
      if (namedBindings) {
        if (namedBindings.kind === 274 /* NamespaceImport */) {
          addLeafNode(namedBindings);
        } else {
          for (const element of namedBindings.elements) {
            addLeafNode(element);
          }
        }
      }
      break;
    case 304 /* ShorthandPropertyAssignment */:
      addNodeWithRecursiveChild(node, node.name);
      break;
    case 305 /* SpreadAssignment */:
      const { expression } = node;
      isIdentifier(expression) ? addLeafNode(node, expression) : addLeafNode(node);
      break;
    case 208 /* BindingElement */:
    case 303 /* PropertyAssignment */:
    case 260 /* VariableDeclaration */: {
      const child = node;
      if (isBindingPattern(child.name)) {
        addChildrenRecursively(child.name);
      } else {
        addNodeWithRecursiveInitializer(child);
      }
      break;
    }
    case 262 /* FunctionDeclaration */:
      const nameNode = node.name;
      if (nameNode && isIdentifier(nameNode)) {
        addTrackedEs5Class(nameNode.text);
      }
      addNodeWithRecursiveChild(node, node.body);
      break;
    case 219 /* ArrowFunction */:
    case 218 /* FunctionExpression */:
      addNodeWithRecursiveChild(node, node.body);
      break;
    case 266 /* EnumDeclaration */:
      startNode(node);
      for (const member of node.members) {
        if (!isComputedProperty(member)) {
          addLeafNode(member);
        }
      }
      endNode();
      break;
    case 263 /* ClassDeclaration */:
    case 231 /* ClassExpression */:
    case 264 /* InterfaceDeclaration */:
      startNode(node);
      for (const member of node.members) {
        addChildrenRecursively(member);
      }
      endNode();
      break;
    case 267 /* ModuleDeclaration */:
      addNodeWithRecursiveChild(node, getInteriorModule(node).body);
      break;
    case 277 /* ExportAssignment */: {
      const expression2 = node.expression;
      const child = isObjectLiteralExpression(expression2) || isCallExpression(expression2) ? expression2 : isArrowFunction(expression2) || isFunctionExpression(expression2) ? expression2.body : void 0;
      if (child) {
        startNode(node);
        addChildrenRecursively(child);
        endNode();
      } else {
        addLeafNode(node);
      }
      break;
    }
    case 281 /* ExportSpecifier */:
    case 271 /* ImportEqualsDeclaration */:
    case 181 /* IndexSignature */:
    case 179 /* CallSignature */:
    case 180 /* ConstructSignature */:
    case 265 /* TypeAliasDeclaration */:
      addLeafNode(node);
      break;
    case 213 /* CallExpression */:
    case 226 /* BinaryExpression */: {
      const special = getAssignmentDeclarationKind(node);
      switch (special) {
        case 1 /* ExportsProperty */:
        case 2 /* ModuleExports */:
          addNodeWithRecursiveChild(node, node.right);
          return;
        case 6 /* Prototype */:
        case 3 /* PrototypeProperty */: {
          const binaryExpression = node;
          const assignmentTarget = binaryExpression.left;
          const prototypeAccess = special === 3 /* PrototypeProperty */ ? assignmentTarget.expression : assignmentTarget;
          let depth = 0;
          let className;
          if (isIdentifier(prototypeAccess.expression)) {
            addTrackedEs5Class(prototypeAccess.expression.text);
            className = prototypeAccess.expression;
          } else {
            [depth, className] = startNestedNodes(binaryExpression, prototypeAccess.expression);
          }
          if (special === 6 /* Prototype */) {
            if (isObjectLiteralExpression(binaryExpression.right)) {
              if (binaryExpression.right.properties.length > 0) {
                startNode(binaryExpression, className);
                forEachChild(binaryExpression.right, addChildrenRecursively);
                endNode();
              }
            }
          } else if (isFunctionExpression(binaryExpression.right) || isArrowFunction(binaryExpression.right)) {
            addNodeWithRecursiveChild(node, binaryExpression.right, className);
          } else {
            startNode(binaryExpression, className);
            addNodeWithRecursiveChild(node, binaryExpression.right, assignmentTarget.name);
            endNode();
          }
          endNestedNodes(depth);
          return;
        }
        case 7 /* ObjectDefinePropertyValue */:
        case 9 /* ObjectDefinePrototypeProperty */: {
          const defineCall = node;
          const className = special === 7 /* ObjectDefinePropertyValue */ ? defineCall.arguments[0] : defineCall.arguments[0].expression;
          const memberName = defineCall.arguments[1];
          const [depth, classNameIdentifier] = startNestedNodes(node, className);
          startNode(node, classNameIdentifier);
          startNode(node, setTextRange(factory.createIdentifier(memberName.text), memberName));
          addChildrenRecursively(node.arguments[2]);
          endNode();
          endNode();
          endNestedNodes(depth);
          return;
        }
        case 5 /* Property */: {
          const binaryExpression = node;
          const assignmentTarget = binaryExpression.left;
          const targetFunction = assignmentTarget.expression;
          if (isIdentifier(targetFunction) && getElementOrPropertyAccessName(assignmentTarget) !== "prototype" && trackedEs5Classes && trackedEs5Classes.has(targetFunction.text)) {
            if (isFunctionExpression(binaryExpression.right) || isArrowFunction(binaryExpression.right)) {
              addNodeWithRecursiveChild(node, binaryExpression.right, targetFunction);
            } else if (isBindableStaticAccessExpression(assignmentTarget)) {
              startNode(binaryExpression, targetFunction);
              addNodeWithRecursiveChild(binaryExpression.left, binaryExpression.right, getNameOrArgument(assignmentTarget));
              endNode();
            }
            return;
          }
          break;
        }
        case 4 /* ThisProperty */:
        case 0 /* None */:
        case 8 /* ObjectDefinePropertyExports */:
          break;
        default:
          Debug.assertNever(special);
      }
    }
    default:
      if (hasJSDocNodes(node)) {
        forEach(node.jsDoc, (jsDoc) => {
          forEach(jsDoc.tags, (tag) => {
            if (isJSDocTypeAlias(tag)) {
              addLeafNode(tag);
            }
          });
        });
      }
      forEachChild(node, addChildrenRecursively);
  }
}
function mergeChildren(children, node) {
  const nameToItems = /* @__PURE__ */ new Map();
  filterMutate(children, (child, index) => {
    const declName = child.name || getNameOfDeclaration(child.node);
    const name = declName && nodeText(declName);
    if (!name) {
      return true;
    }
    const itemsWithSameName = nameToItems.get(name);
    if (!itemsWithSameName) {
      nameToItems.set(name, child);
      return true;
    }
    if (itemsWithSameName instanceof Array) {
      for (const itemWithSameName of itemsWithSameName) {
        if (tryMerge(itemWithSameName, child, index, node)) {
          return false;
        }
      }
      itemsWithSameName.push(child);
      return true;
    } else {
      const itemWithSameName = itemsWithSameName;
      if (tryMerge(itemWithSameName, child, index, node)) {
        return false;
      }
      nameToItems.set(name, [itemWithSameName, child]);
      return true;
    }
  });
}
var isEs5ClassMember = {
  [5 /* Property */]: true,
  [3 /* PrototypeProperty */]: true,
  [7 /* ObjectDefinePropertyValue */]: true,
  [9 /* ObjectDefinePrototypeProperty */]: true,
  [0 /* None */]: false,
  [1 /* ExportsProperty */]: false,
  [2 /* ModuleExports */]: false,
  [8 /* ObjectDefinePropertyExports */]: false,
  [6 /* Prototype */]: true,
  [4 /* ThisProperty */]: false
};
function tryMergeEs5Class(a, b, bIndex, parent2) {
  function isPossibleConstructor(node) {
    return isFunctionExpression(node) || isFunctionDeclaration(node) || isVariableDeclaration(node);
  }
  const bAssignmentDeclarationKind = isBinaryExpression(b.node) || isCallExpression(b.node) ? getAssignmentDeclarationKind(b.node) : 0 /* None */;
  const aAssignmentDeclarationKind = isBinaryExpression(a.node) || isCallExpression(a.node) ? getAssignmentDeclarationKind(a.node) : 0 /* None */;
  if (isEs5ClassMember[bAssignmentDeclarationKind] && isEs5ClassMember[aAssignmentDeclarationKind] || isPossibleConstructor(a.node) && isEs5ClassMember[bAssignmentDeclarationKind] || isPossibleConstructor(b.node) && isEs5ClassMember[aAssignmentDeclarationKind] || isClassDeclaration(a.node) && isSynthesized(a.node) && isEs5ClassMember[bAssignmentDeclarationKind] || isClassDeclaration(b.node) && isEs5ClassMember[aAssignmentDeclarationKind] || isClassDeclaration(a.node) && isSynthesized(a.node) && isPossibleConstructor(b.node) || isClassDeclaration(b.node) && isPossibleConstructor(a.node) && isSynthesized(a.node)) {
    let lastANode = a.additionalNodes && lastOrUndefined(a.additionalNodes) || a.node;
    if (!isClassDeclaration(a.node) && !isClassDeclaration(b.node) || isPossibleConstructor(a.node) || isPossibleConstructor(b.node)) {
      const ctorFunction = isPossibleConstructor(a.node) ? a.node : isPossibleConstructor(b.node) ? b.node : void 0;
      if (ctorFunction !== void 0) {
        const ctorNode = setTextRange(
          factory.createConstructorDeclaration(
            /*modifiers*/
            void 0,
            [],
            /*body*/
            void 0
          ),
          ctorFunction
        );
        const ctor = emptyNavigationBarNode(ctorNode);
        ctor.indent = a.indent + 1;
        ctor.children = a.node === ctorFunction ? a.children : b.children;
        a.children = a.node === ctorFunction ? concatenate([ctor], b.children || [b]) : concatenate(a.children || [{ ...a }], [ctor]);
      } else {
        if (a.children || b.children) {
          a.children = concatenate(a.children || [{ ...a }], b.children || [b]);
          if (a.children) {
            mergeChildren(a.children, a);
            sortChildren(a.children);
          }
        }
      }
      lastANode = a.node = setTextRange(
        factory.createClassDeclaration(
          /*modifiers*/
          void 0,
          a.name || factory.createIdentifier("__class__"),
          /*typeParameters*/
          void 0,
          /*heritageClauses*/
          void 0,
          []
        ),
        a.node
      );
    } else {
      a.children = concatenate(a.children, b.children);
      if (a.children) {
        mergeChildren(a.children, a);
      }
    }
    const bNode = b.node;
    if (parent2.children[bIndex - 1].node.end === lastANode.end) {
      setTextRange(lastANode, { pos: lastANode.pos, end: bNode.end });
    } else {
      if (!a.additionalNodes) a.additionalNodes = [];
      a.additionalNodes.push(setTextRange(
        factory.createClassDeclaration(
          /*modifiers*/
          void 0,
          a.name || factory.createIdentifier("__class__"),
          /*typeParameters*/
          void 0,
          /*heritageClauses*/
          void 0,
          []
        ),
        b.node
      ));
    }
    return true;
  }
  return bAssignmentDeclarationKind === 0 /* None */ ? false : true;
}
function tryMerge(a, b, bIndex, parent2) {
  if (tryMergeEs5Class(a, b, bIndex, parent2)) {
    return true;
  }
  if (shouldReallyMerge(a.node, b.node, parent2)) {
    merge(a, b);
    return true;
  }
  return false;
}
function shouldReallyMerge(a, b, parent2) {
  if (a.kind !== b.kind || a.parent !== b.parent && !(isOwnChild(a, parent2) && isOwnChild(b, parent2))) {
    return false;
  }
  switch (a.kind) {
    case 172 /* PropertyDeclaration */:
    case 174 /* MethodDeclaration */:
    case 177 /* GetAccessor */:
    case 178 /* SetAccessor */:
      return isStatic(a) === isStatic(b);
    case 267 /* ModuleDeclaration */:
      return areSameModule(a, b) && getFullyQualifiedModuleName(a) === getFullyQualifiedModuleName(b);
    default:
      return true;
  }
}
function isSynthesized(node) {
  return !!(node.flags & 16 /* Synthesized */);
}
function isOwnChild(n, parent2) {
  const par = isModuleBlock(n.parent) ? n.parent.parent : n.parent;
  return par === parent2.node || contains(parent2.additionalNodes, par);
}
function areSameModule(a, b) {
  if (!a.body || !b.body) {
    return a.body === b.body;
  }
  return a.body.kind === b.body.kind && (a.body.kind !== 267 /* ModuleDeclaration */ || areSameModule(a.body, b.body));
}
function merge(target, source) {
  target.additionalNodes = target.additionalNodes || [];
  target.additionalNodes.push(source.node);
  if (source.additionalNodes) {
    target.additionalNodes.push(...source.additionalNodes);
  }
  target.children = concatenate(target.children, source.children);
  if (target.children) {
    mergeChildren(target.children, target);
    sortChildren(target.children);
  }
}
function sortChildren(children) {
  children.sort(compareChildren);
}
function compareChildren(child1, child2) {
  return compareStringsCaseSensitiveUI(tryGetName(child1.node), tryGetName(child2.node)) || compareValues(navigationBarNodeKind(child1), navigationBarNodeKind(child2));
}
function tryGetName(node) {
  if (node.kind === 267 /* ModuleDeclaration */) {
    return getModuleName(node);
  }
  const declName = getNameOfDeclaration(node);
  if (declName && isPropertyName(declName)) {
    const propertyName = getPropertyNameForPropertyNameNode(declName);
    return propertyName && unescapeLeadingUnderscores(propertyName);
  }
  switch (node.kind) {
    case 218 /* FunctionExpression */:
    case 219 /* ArrowFunction */:
    case 231 /* ClassExpression */:
      return getFunctionOrClassName(node);
    default:
      return void 0;
  }
}
function getItemName(node, name) {
  if (node.kind === 267 /* ModuleDeclaration */) {
    return cleanText(getModuleName(node));
  }
  if (name) {
    const text = isIdentifier(name) ? name.text : isElementAccessExpression(name) ? `[${nodeText(name.argumentExpression)}]` : nodeText(name);
    if (text.length > 0) {
      return cleanText(text);
    }
  }
  switch (node.kind) {
    case 307 /* SourceFile */:
      const sourceFile = node;
      return isExternalModule(sourceFile) ? `"${escapeString(getBaseFileName(removeFileExtension(normalizePath(sourceFile.fileName))))}"` : "<global>";
    case 277 /* ExportAssignment */:
      return isExportAssignment(node) && node.isExportEquals ? "export=" /* ExportEquals */ : "default" /* Default */;
    case 219 /* ArrowFunction */:
    case 262 /* FunctionDeclaration */:
    case 218 /* FunctionExpression */:
    case 263 /* ClassDeclaration */:
    case 231 /* ClassExpression */:
      if (getSyntacticModifierFlags(node) & 2048 /* Default */) {
        return "default";
      }
      return getFunctionOrClassName(node);
    case 176 /* Constructor */:
      return "constructor";
    case 180 /* ConstructSignature */:
      return "new()";
    case 179 /* CallSignature */:
      return "()";
    case 181 /* IndexSignature */:
      return "[]";
    default:
      return "<unknown>";
  }
}
function primaryNavBarMenuItems(root) {
  const primaryNavBarMenuItems2 = [];
  function recur(item) {
    if (shouldAppearInPrimaryNavBarMenu(item)) {
      primaryNavBarMenuItems2.push(item);
      if (item.children) {
        for (const child of item.children) {
          recur(child);
        }
      }
    }
  }
  recur(root);
  return primaryNavBarMenuItems2;
  function shouldAppearInPrimaryNavBarMenu(item) {
    if (item.children) {
      return true;
    }
    switch (navigationBarNodeKind(item)) {
      case 263 /* ClassDeclaration */:
      case 231 /* ClassExpression */:
      case 266 /* EnumDeclaration */:
      case 264 /* InterfaceDeclaration */:
      case 267 /* ModuleDeclaration */:
      case 307 /* SourceFile */:
      case 265 /* TypeAliasDeclaration */:
      case 346 /* JSDocTypedefTag */:
      case 338 /* JSDocCallbackTag */:
        return true;
      case 219 /* ArrowFunction */:
      case 262 /* FunctionDeclaration */:
      case 218 /* FunctionExpression */:
        return isTopLevelFunctionDeclaration(item);
      default:
        return false;
    }
    function isTopLevelFunctionDeclaration(item2) {
      if (!item2.node.body) {
        return false;
      }
      switch (navigationBarNodeKind(item2.parent)) {
        case 268 /* ModuleBlock */:
        case 307 /* SourceFile */:
        case 174 /* MethodDeclaration */:
        case 176 /* Constructor */:
          return true;
        default:
          return false;
      }
    }
  }
}
function convertToTree(n) {
  return {
    text: getItemName(n.node, n.name),
    kind: getNodeKind(n.node),
    kindModifiers: getModifiers2(n.node),
    spans: getSpans(n),
    nameSpan: n.name && getNodeSpan(n.name),
    childItems: map(n.children, convertToTree)
  };
}
function convertToPrimaryNavBarMenuItem(n) {
  return {
    text: getItemName(n.node, n.name),
    kind: getNodeKind(n.node),
    kindModifiers: getModifiers2(n.node),
    spans: getSpans(n),
    childItems: map(n.children, convertToSecondaryNavBarMenuItem) || emptyChildItemArray,
    indent: n.indent,
    bolded: false,
    grayed: false
  };
  function convertToSecondaryNavBarMenuItem(n2) {
    return {
      text: getItemName(n2.node, n2.name),
      kind: getNodeKind(n2.node),
      kindModifiers: getNodeModifiers(n2.node),
      spans: getSpans(n2),
      childItems: emptyChildItemArray,
      indent: 0,
      bolded: false,
      grayed: false
    };
  }
}
function getSpans(n) {
  const spans = [getNodeSpan(n.node)];
  if (n.additionalNodes) {
    for (const node of n.additionalNodes) {
      spans.push(getNodeSpan(node));
    }
  }
  return spans;
}
function getModuleName(moduleDeclaration) {
  if (isAmbientModule(moduleDeclaration)) {
    return getTextOfNode(moduleDeclaration.name);
  }
  return getFullyQualifiedModuleName(moduleDeclaration);
}
function getFullyQualifiedModuleName(moduleDeclaration) {
  const result = [getTextOfIdentifierOrLiteral(moduleDeclaration.name)];
  while (moduleDeclaration.body && moduleDeclaration.body.kind === 267 /* ModuleDeclaration */) {
    moduleDeclaration = moduleDeclaration.body;
    result.push(getTextOfIdentifierOrLiteral(moduleDeclaration.name));
  }
  return result.join(".");
}
function getInteriorModule(decl) {
  return decl.body && isModuleDeclaration(decl.body) ? getInteriorModule(decl.body) : decl;
}
function isComputedProperty(member) {
  return !member.name || member.name.kind === 167 /* ComputedPropertyName */;
}
function getNodeSpan(node) {
  return node.kind === 307 /* SourceFile */ ? createTextSpanFromRange(node) : createTextSpanFromNode(node, curSourceFile);
}
function getModifiers2(node) {
  if (node.parent && node.parent.kind === 260 /* VariableDeclaration */) {
    node = node.parent;
  }
  return getNodeModifiers(node);
}
function getFunctionOrClassName(node) {
  const { parent: parent2 } = node;
  if (node.name && getFullWidth(node.name) > 0) {
    return cleanText(declarationNameToString(node.name));
  } else if (isVariableDeclaration(parent2)) {
    return cleanText(declarationNameToString(parent2.name));
  } else if (isBinaryExpression(parent2) && parent2.operatorToken.kind === 64 /* EqualsToken */) {
    return nodeText(parent2.left).replace(whiteSpaceRegex, "");
  } else if (isPropertyAssignment(parent2)) {
    return nodeText(parent2.name);
  } else if (getSyntacticModifierFlags(node) & 2048 /* Default */) {
    return "default";
  } else if (isClassLike(node)) {
    return "<class>";
  } else if (isCallExpression(parent2)) {
    let name = getCalledExpressionName(parent2.expression);
    if (name !== void 0) {
      name = cleanText(name);
      if (name.length > maxLength) {
        return `${name} callback`;
      }
      const args = cleanText(mapDefined(parent2.arguments, (a) => isStringLiteralLike(a) || isTemplateLiteral(a) ? a.getText(curSourceFile) : void 0).join(", "));
      return `${name}(${args}) callback`;
    }
  }
  return "<function>";
}
function getCalledExpressionName(expr) {
  if (isIdentifier(expr)) {
    return expr.text;
  } else if (isPropertyAccessExpression(expr)) {
    const left = getCalledExpressionName(expr.expression);
    const right = expr.name.text;
    return left === void 0 ? right : `${left}.${right}`;
  } else {
    return void 0;
  }
}
function isFunctionOrClassExpression(node) {
  switch (node.kind) {
    case 219 /* ArrowFunction */:
    case 218 /* FunctionExpression */:
    case 231 /* ClassExpression */:
      return true;
    default:
      return false;
  }
}
function cleanText(text) {
  text = text.length > maxLength ? text.substring(0, maxLength) + "..." : text;
  return text.replace(/\\?(\r?\n|\r|\u2028|\u2029)/g, "");
}

// src/services/_namespaces/ts.refactor.ts
var ts_refactor_exports = {};
__export(ts_refactor_exports, {
  addExportToChanges: () => addExportToChanges,
  addExportsInOldFile: () => addExportsInOldFile,
  addImportsForMovedSymbols: () => addImportsForMovedSymbols,
  addNewFileToTsconfig: () => addNewFileToTsconfig,
  addOrRemoveBracesToArrowFunction: () => ts_refactor_addOrRemoveBracesToArrowFunction_exports,
  addTargetFileImports: () => addTargetFileImports,
  containsJsx: () => containsJsx,
  convertArrowFunctionOrFunctionExpression: () => ts_refactor_convertArrowFunctionOrFunctionExpression_exports,
  convertParamsToDestructuredObject: () => ts_refactor_convertParamsToDestructuredObject_exports,
  convertStringOrTemplateLiteral: () => ts_refactor_convertStringOrTemplateLiteral_exports,
  convertToOptionalChainExpression: () => ts_refactor_convertToOptionalChainExpression_exports,
  createNewFileName: () => createNewFileName,
  deleteMovedStatements: () => deleteMovedStatements,
  deleteUnusedImports: () => deleteUnusedImports,
  deleteUnusedOldImports: () => deleteUnusedOldImports,
  doChangeNamedToNamespaceOrDefault: () => doChangeNamedToNamespaceOrDefault,
  extractSymbol: () => ts_refactor_extractSymbol_exports,
  filterImport: () => filterImport,
  forEachImportInStatement: () => forEachImportInStatement,
  generateGetAccessorAndSetAccessor: () => ts_refactor_generateGetAccessorAndSetAccessor_exports,
  getApplicableRefactors: () => getApplicableRefactors,
  getEditsForRefactor: () => getEditsForRefactor,
  getExistingLocals: () => getExistingLocals,
  getIdentifierForNode: () => getIdentifierForNode,
  getNewStatementsAndRemoveFromOldFile: () => getNewStatementsAndRemoveFromOldFile,
  getStatementsToMove: () => getStatementsToMove,
  getTopLevelDeclarationStatement: () => getTopLevelDeclarationStatement,
  getUsageInfo: () => getUsageInfo,
  inferFunctionReturnType: () => ts_refactor_inferFunctionReturnType_exports,
  isRefactorErrorInfo: () => isRefactorErrorInfo,
  isTopLevelDeclaration: () => isTopLevelDeclaration,
  moduleSpecifierFromImport: () => moduleSpecifierFromImport,
  nameOfTopLevelDeclaration: () => nameOfTopLevelDeclaration,
  refactorKindBeginsWith: () => refactorKindBeginsWith,
  registerRefactor: () => registerRefactor,
  updateImportsInOtherFiles: () => updateImportsInOtherFiles
});

// src/services/refactorProvider.ts
var refactors = /* @__PURE__ */ new Map();
function registerRefactor(name, refactor) {
  refactors.set(name, refactor);
}
function getApplicableRefactors(context, includeInteractiveActions) {
  return arrayFrom(flatMapIterator(refactors.values(), (refactor) => {
    var _a;
    return context.cancellationToken && context.cancellationToken.isCancellationRequested() || !((_a = refactor.kinds) == null ? void 0 : _a.some((kind) => refactorKindBeginsWith(kind, context.kind))) ? void 0 : refactor.getAvailableActions(context, includeInteractiveActions);
  }));
}
function getEditsForRefactor(context, refactorName14, actionName2, interactiveRefactorArguments) {
  const refactor = refactors.get(refactorName14);
  return refactor && refactor.getEditsForAction(context, actionName2, interactiveRefactorArguments);
}

// src/services/refactors/convertExport.ts
var refactorName = "Convert export";
var defaultToNamedAction = {
  name: "Convert default export to named export",
  description: getLocaleSpecificMessage(Diagnostics.Convert_default_export_to_named_export),
  kind: "refactor.rewrite.export.named"
};
var namedToDefaultAction = {
  name: "Convert named export to default export",
  description: getLocaleSpecificMessage(Diagnostics.Convert_named_export_to_default_export),
  kind: "refactor.rewrite.export.default"
};
registerRefactor(refactorName, {
  kinds: [
    defaultToNamedAction.kind,
    namedToDefaultAction.kind
  ],
  getAvailableActions: function getRefactorActionsToConvertBetweenNamedAndDefaultExports(context) {
    const info = getInfo2(context, context.triggerReason === "invoked");
    if (!info) return emptyArray;
    if (!isRefactorErrorInfo(info)) {
      const action = info.wasDefault ? defaultToNamedAction : namedToDefaultAction;
      return [{ name: refactorName, description: action.description, actions: [action] }];
    }
    if (context.preferences.provideRefactorNotApplicableReason) {
      return [
        {
          name: refactorName,
          description: getLocaleSpecificMessage(Diagnostics.Convert_default_export_to_named_export),
          actions: [
            { ...defaultToNamedAction, notApplicableReason: info.error },
            { ...namedToDefaultAction, notApplicableReason: info.error }
          ]
        }
      ];
    }
    return emptyArray;
  },
  getEditsForAction: function getRefactorEditsToConvertBetweenNamedAndDefaultExports(context, actionName2) {
    Debug.assert(actionName2 === defaultToNamedAction.name || actionName2 === namedToDefaultAction.name, "Unexpected action name");
    const info = getInfo2(context);
    Debug.assert(info && !isRefactorErrorInfo(info), "Expected applicable refactor info");
    const edits = ts_textChanges_exports.ChangeTracker.with(context, (t) => doChange(context.file, context.program, info, t, context.cancellationToken));
    return { edits, renameFilename: void 0, renameLocation: void 0 };
  }
});
function getInfo2(context, considerPartialSpans = true) {
  const { file, program } = context;
  const span = getRefactorContextSpan(context);
  const token = getTokenAtPosition(file, span.start);
  const exportNode = !!(token.parent && getSyntacticModifierFlags(token.parent) & 32 /* Export */) && considerPartialSpans ? token.parent : getParentNodeInSpan(token, file, span);
  if (!exportNode || !isSourceFile(exportNode.parent) && !(isModuleBlock(exportNode.parent) && isAmbientModule(exportNode.parent.parent))) {
    return { error: getLocaleSpecificMessage(Diagnostics.Could_not_find_export_statement) };
  }
  const checker = program.getTypeChecker();
  const exportingModuleSymbol = getExportingModuleSymbol(exportNode.parent, checker);
  const flags = getSyntacticModifierFlags(exportNode) || (isExportAssignment(exportNode) && !exportNode.isExportEquals ? 2080 /* ExportDefault */ : 0 /* None */);
  const wasDefault = !!(flags & 2048 /* Default */);
  if (!(flags & 32 /* Export */) || !wasDefault && exportingModuleSymbol.exports.has("default" /* Default */)) {
    return { error: getLocaleSpecificMessage(Diagnostics.This_file_already_has_a_default_export) };
  }
  const noSymbolError = (id) => isIdentifier(id) && checker.getSymbolAtLocation(id) ? void 0 : { error: getLocaleSpecificMessage(Diagnostics.Can_only_convert_named_export) };
  switch (exportNode.kind) {
    case 262 /* FunctionDeclaration */:
    case 263 /* ClassDeclaration */:
    case 264 /* InterfaceDeclaration */:
    case 266 /* EnumDeclaration */:
    case 265 /* TypeAliasDeclaration */:
    case 267 /* ModuleDeclaration */: {
      const node = exportNode;
      if (!node.name) return void 0;
      return noSymbolError(node.name) || { exportNode: node, exportName: node.name, wasDefault, exportingModuleSymbol };
    }
    case 243 /* VariableStatement */: {
      const vs = exportNode;
      if (!(vs.declarationList.flags & 2 /* Const */) || vs.declarationList.declarations.length !== 1) {
        return void 0;
      }
      const decl = first(vs.declarationList.declarations);
      if (!decl.initializer) return void 0;
      Debug.assert(!wasDefault, "Can't have a default flag here");
      return noSymbolError(decl.name) || { exportNode: vs, exportName: decl.name, wasDefault, exportingModuleSymbol };
    }
    case 277 /* ExportAssignment */: {
      const node = exportNode;
      if (node.isExportEquals) return void 0;
      return noSymbolError(node.expression) || { exportNode: node, exportName: node.expression, wasDefault, exportingModuleSymbol };
    }
    default:
      return void 0;
  }
}
function doChange(exportingSourceFile, program, info, changes, cancellationToken) {
  changeExport(exportingSourceFile, info, changes, program.getTypeChecker());
  changeImports(program, info, changes, cancellationToken);
}
function changeExport(exportingSourceFile, { wasDefault, exportNode, exportName }, changes, checker) {
  if (wasDefault) {
    if (isExportAssignment(exportNode) && !exportNode.isExportEquals) {
      const exp = exportNode.expression;
      const spec = makeExportSpecifier(exp.text, exp.text);
      changes.replaceNode(exportingSourceFile, exportNode, factory.createExportDeclaration(
        /*modifiers*/
        void 0,
        /*isTypeOnly*/
        false,
        factory.createNamedExports([spec])
      ));
    } else {
      changes.delete(exportingSourceFile, Debug.checkDefined(findModifier(exportNode, 90 /* DefaultKeyword */), "Should find a default keyword in modifier list"));
    }
  } else {
    const exportKeyword = Debug.checkDefined(findModifier(exportNode, 95 /* ExportKeyword */), "Should find an export keyword in modifier list");
    switch (exportNode.kind) {
      case 262 /* FunctionDeclaration */:
      case 263 /* ClassDeclaration */:
      case 264 /* InterfaceDeclaration */:
        changes.insertNodeAfter(exportingSourceFile, exportKeyword, factory.createToken(90 /* DefaultKeyword */));
        break;
      case 243 /* VariableStatement */:
        const decl = first(exportNode.declarationList.declarations);
        if (!ts_FindAllReferences_exports.Core.isSymbolReferencedInFile(exportName, checker, exportingSourceFile) && !decl.type) {
          changes.replaceNode(exportingSourceFile, exportNode, factory.createExportDefault(Debug.checkDefined(decl.initializer, "Initializer was previously known to be present")));
          break;
        }
      case 266 /* EnumDeclaration */:
      case 265 /* TypeAliasDeclaration */:
      case 267 /* ModuleDeclaration */:
        changes.deleteModifier(exportingSourceFile, exportKeyword);
        changes.insertNodeAfter(exportingSourceFile, exportNode, factory.createExportDefault(factory.createIdentifier(exportName.text)));
        break;
      default:
        Debug.fail(`Unexpected exportNode kind ${exportNode.kind}`);
    }
  }
}
function changeImports(program, { wasDefault, exportName, exportingModuleSymbol }, changes, cancellationToken) {
  const checker = program.getTypeChecker();
  const exportSymbol = Debug.checkDefined(checker.getSymbolAtLocation(exportName), "Export name should resolve to a symbol");
  ts_FindAllReferences_exports.Core.eachExportReference(program.getSourceFiles(), checker, cancellationToken, exportSymbol, exportingModuleSymbol, exportName.text, wasDefault, (ref) => {
    if (exportName === ref) return;
    const importingSourceFile = ref.getSourceFile();
    if (wasDefault) {
      changeDefaultToNamedImport(importingSourceFile, ref, changes, exportName.text);
    } else {
      changeNamedToDefaultImport(importingSourceFile, ref, changes);
    }
  });
}
function changeDefaultToNamedImport(importingSourceFile, ref, changes, exportName) {
  const { parent: parent2 } = ref;
  switch (parent2.kind) {
    case 211 /* PropertyAccessExpression */:
      changes.replaceNode(importingSourceFile, ref, factory.createIdentifier(exportName));
      break;
    case 276 /* ImportSpecifier */:
    case 281 /* ExportSpecifier */: {
      const spec = parent2;
      changes.replaceNode(importingSourceFile, spec, makeImportSpecifier(exportName, spec.name.text));
      break;
    }
    case 273 /* ImportClause */: {
      const clause = parent2;
      Debug.assert(clause.name === ref, "Import clause name should match provided ref");
      const spec = makeImportSpecifier(exportName, ref.text);
      const { namedBindings } = clause;
      if (!namedBindings) {
        changes.replaceNode(importingSourceFile, ref, factory.createNamedImports([spec]));
      } else if (namedBindings.kind === 274 /* NamespaceImport */) {
        changes.deleteRange(importingSourceFile, { pos: ref.getStart(importingSourceFile), end: namedBindings.getStart(importingSourceFile) });
        const quotePreference = isStringLiteral(clause.parent.moduleSpecifier) ? quotePreferenceFromString(clause.parent.moduleSpecifier, importingSourceFile) : 1 /* Double */;
        const newImport = makeImport(
          /*defaultImport*/
          void 0,
          [makeImportSpecifier(exportName, ref.text)],
          clause.parent.moduleSpecifier,
          quotePreference
        );
        changes.insertNodeAfter(importingSourceFile, clause.parent, newImport);
      } else {
        changes.delete(importingSourceFile, ref);
        changes.insertNodeAtEndOfList(importingSourceFile, namedBindings.elements, spec);
      }
      break;
    }
    case 205 /* ImportType */:
      const importTypeNode = parent2;
      changes.replaceNode(importingSourceFile, parent2, factory.createImportTypeNode(importTypeNode.argument, importTypeNode.attributes, factory.createIdentifier(exportName), importTypeNode.typeArguments, importTypeNode.isTypeOf));
      break;
    default:
      Debug.failBadSyntaxKind(parent2);
  }
}
function changeNamedToDefaultImport(importingSourceFile, ref, changes) {
  const parent2 = ref.parent;
  switch (parent2.kind) {
    case 211 /* PropertyAccessExpression */:
      changes.replaceNode(importingSourceFile, ref, factory.createIdentifier("default"));
      break;
    case 276 /* ImportSpecifier */: {
      const defaultImport = factory.createIdentifier(parent2.name.text);
      if (parent2.parent.elements.length === 1) {
        changes.replaceNode(importingSourceFile, parent2.parent, defaultImport);
      } else {
        changes.delete(importingSourceFile, parent2);
        changes.insertNodeBefore(importingSourceFile, parent2.parent, defaultImport);
      }
      break;
    }
    case 281 /* ExportSpecifier */: {
      changes.replaceNode(importingSourceFile, parent2, makeExportSpecifier("default", parent2.name.text));
      break;
    }
    default:
      Debug.assertNever(parent2, `Unexpected parent kind ${parent2.kind}`);
  }
}
function makeImportSpecifier(propertyName, name) {
  return factory.createImportSpecifier(
    /*isTypeOnly*/
    false,
    propertyName === name ? void 0 : factory.createIdentifier(propertyName),
    factory.createIdentifier(name)
  );
}
function makeExportSpecifier(propertyName, name) {
  return factory.createExportSpecifier(
    /*isTypeOnly*/
    false,
    propertyName === name ? void 0 : factory.createIdentifier(propertyName),
    factory.createIdentifier(name)
  );
}
function getExportingModuleSymbol(parent2, checker) {
  if (isSourceFile(parent2)) {
    return parent2.symbol;
  }
  const symbol = parent2.parent.symbol;
  if (symbol.valueDeclaration && isExternalModuleAugmentation(symbol.valueDeclaration)) {
    return checker.getMergedSymbol(symbol);
  }
  return symbol;
}

// src/services/refactors/convertImport.ts
var refactorName2 = "Convert import";
var actions = {
  [0 /* Named */]: {
    name: "Convert namespace import to named imports",
    description: getLocaleSpecificMessage(Diagnostics.Convert_namespace_import_to_named_imports),
    kind: "refactor.rewrite.import.named"
  },
  [2 /* Namespace */]: {
    name: "Convert named imports to namespace import",
    description: getLocaleSpecificMessage(Diagnostics.Convert_named_imports_to_namespace_import),
    kind: "refactor.rewrite.import.namespace"
  },
  [1 /* Default */]: {
    name: "Convert named imports to default import",
    description: getLocaleSpecificMessage(Diagnostics.Convert_named_imports_to_default_import),
    kind: "refactor.rewrite.import.default"
  }
};
registerRefactor(refactorName2, {
  kinds: getOwnValues(actions).map((a) => a.kind),
  getAvailableActions: function getRefactorActionsToConvertBetweenNamedAndNamespacedImports(context) {
    const info = getImportConversionInfo(context, context.triggerReason === "invoked");
    if (!info) return emptyArray;
    if (!isRefactorErrorInfo(info)) {
      const action = actions[info.convertTo];
      return [{ name: refactorName2, description: action.description, actions: [action] }];
    }
    if (context.preferences.provideRefactorNotApplicableReason) {
      return getOwnValues(actions).map((action) => ({
        name: refactorName2,
        description: action.description,
        actions: [{ ...action, notApplicableReason: info.error }]
      }));
    }
    return emptyArray;
  },
  getEditsForAction: function getRefactorEditsToConvertBetweenNamedAndNamespacedImports(context, actionName2) {
    Debug.assert(some(getOwnValues(actions), (action) => action.name === actionName2), "Unexpected action name");
    const info = getImportConversionInfo(context);
    Debug.assert(info && !isRefactorErrorInfo(info), "Expected applicable refactor info");
    const edits = ts_textChanges_exports.ChangeTracker.with(context, (t) => doChange2(context.file, context.program, t, info));
    return { edits, renameFilename: void 0, renameLocation: void 0 };
  }
});
function getImportConversionInfo(context, considerPartialSpans = true) {
  const { file } = context;
  const span = getRefactorContextSpan(context);
  const token = getTokenAtPosition(file, span.start);
  const importDecl = considerPartialSpans ? findAncestor(token, or(isImportDeclaration, isJSDocImportTag)) : getParentNodeInSpan(token, file, span);
  if (importDecl === void 0 || !(isImportDeclaration(importDecl) || isJSDocImportTag(importDecl))) return { error: "Selection is not an import declaration." };
  const end = span.start + span.length;
  const nextToken = findNextToken(importDecl, importDecl.parent, file);
  if (nextToken && end > nextToken.getStart()) return void 0;
  const { importClause } = importDecl;
  if (!importClause) {
    return { error: getLocaleSpecificMessage(Diagnostics.Could_not_find_import_clause) };
  }
  if (!importClause.namedBindings) {
    return { error: getLocaleSpecificMessage(Diagnostics.Could_not_find_namespace_import_or_named_imports) };
  }
  if (importClause.namedBindings.kind === 274 /* NamespaceImport */) {
    return { convertTo: 0 /* Named */, import: importClause.namedBindings };
  }
  const shouldUseDefault = getShouldUseDefault(context.program, importClause);
  return shouldUseDefault ? { convertTo: 1 /* Default */, import: importClause.namedBindings } : { convertTo: 2 /* Namespace */, import: importClause.namedBindings };
}
function getShouldUseDefault(program, importClause) {
  return getAllowSyntheticDefaultImports(program.getCompilerOptions()) && isExportEqualsModule(importClause.parent.moduleSpecifier, program.getTypeChecker());
}
function doChange2(sourceFile, program, changes, info) {
  const checker = program.getTypeChecker();
  if (info.convertTo === 0 /* Named */) {
    doChangeNamespaceToNamed(sourceFile, checker, changes, info.import, getAllowSyntheticDefaultImports(program.getCompilerOptions()));
  } else {
    doChangeNamedToNamespaceOrDefault(sourceFile, program, changes, info.import, info.convertTo === 1 /* Default */);
  }
}
function doChangeNamespaceToNamed(sourceFile, checker, changes, toConvert, allowSyntheticDefaultImports) {
  let usedAsNamespaceOrDefault = false;
  const nodesToReplace = [];
  const conflictingNames = /* @__PURE__ */ new Map();
  ts_FindAllReferences_exports.Core.eachSymbolReferenceInFile(toConvert.name, checker, sourceFile, (id) => {
    if (!isPropertyAccessOrQualifiedName(id.parent)) {
      usedAsNamespaceOrDefault = true;
    } else {
      const exportName = getRightOfPropertyAccessOrQualifiedName(id.parent).text;
      if (checker.resolveName(
        exportName,
        id,
        -1 /* All */,
        /*excludeGlobals*/
        true
      )) {
        conflictingNames.set(exportName, true);
      }
      Debug.assert(getLeftOfPropertyAccessOrQualifiedName(id.parent) === id, "Parent expression should match id");
      nodesToReplace.push(id.parent);
    }
  });
  const exportNameToImportName = /* @__PURE__ */ new Map();
  for (const propertyAccessOrQualifiedName of nodesToReplace) {
    const exportName = getRightOfPropertyAccessOrQualifiedName(propertyAccessOrQualifiedName).text;
    let importName = exportNameToImportName.get(exportName);
    if (importName === void 0) {
      exportNameToImportName.set(exportName, importName = conflictingNames.has(exportName) ? getUniqueName(exportName, sourceFile) : exportName);
    }
    changes.replaceNode(sourceFile, propertyAccessOrQualifiedName, factory.createIdentifier(importName));
  }
  const importSpecifiers = [];
  exportNameToImportName.forEach((name, propertyName) => {
    importSpecifiers.push(factory.createImportSpecifier(
      /*isTypeOnly*/
      false,
      name === propertyName ? void 0 : factory.createIdentifier(propertyName),
      factory.createIdentifier(name)
    ));
  });
  const importDecl = toConvert.parent.parent;
  if (usedAsNamespaceOrDefault && !allowSyntheticDefaultImports && isImportDeclaration(importDecl)) {
    changes.insertNodeAfter(sourceFile, importDecl, createImport(
      importDecl,
      /*defaultImportName*/
      void 0,
      importSpecifiers
    ));
  } else {
    const defaultImportName = usedAsNamespaceOrDefault ? factory.createIdentifier(toConvert.name.text) : void 0;
    changes.replaceNode(sourceFile, toConvert.parent, createImportClause(defaultImportName, importSpecifiers));
  }
}
function getRightOfPropertyAccessOrQualifiedName(propertyAccessOrQualifiedName) {
  return isPropertyAccessExpression(propertyAccessOrQualifiedName) ? propertyAccessOrQualifiedName.name : propertyAccessOrQualifiedName.right;
}
function getLeftOfPropertyAccessOrQualifiedName(propertyAccessOrQualifiedName) {
  return isPropertyAccessExpression(propertyAccessOrQualifiedName) ? propertyAccessOrQualifiedName.expression : propertyAccessOrQualifiedName.left;
}
function doChangeNamedToNamespaceOrDefault(sourceFile, program, changes, toConvert, shouldUseDefault = getShouldUseDefault(program, toConvert.parent)) {
  const checker = program.getTypeChecker();
  const importDecl = toConvert.parent.parent;
  const { moduleSpecifier } = importDecl;
  const toConvertSymbols = /* @__PURE__ */ new Set();
  toConvert.elements.forEach((namedImport) => {
    const symbol = checker.getSymbolAtLocation(namedImport.name);
    if (symbol) {
      toConvertSymbols.add(symbol);
    }
  });
  const preferredName = moduleSpecifier && isStringLiteral(moduleSpecifier) ? moduleSpecifierToValidIdentifier(moduleSpecifier.text, 99 /* ESNext */) : "module";
  function hasNamespaceNameConflict(namedImport) {
    return !!ts_FindAllReferences_exports.Core.eachSymbolReferenceInFile(namedImport.name, checker, sourceFile, (id) => {
      const symbol = checker.resolveName(
        preferredName,
        id,
        -1 /* All */,
        /*excludeGlobals*/
        true
      );
      if (symbol) {
        if (toConvertSymbols.has(symbol)) {
          return isExportSpecifier(id.parent);
        }
        return true;
      }
      return false;
    });
  }
  const namespaceNameConflicts = toConvert.elements.some(hasNamespaceNameConflict);
  const namespaceImportName = namespaceNameConflicts ? getUniqueName(preferredName, sourceFile) : preferredName;
  const neededNamedImports = /* @__PURE__ */ new Set();
  for (const element of toConvert.elements) {
    const propertyName = (element.propertyName || element.name).text;
    ts_FindAllReferences_exports.Core.eachSymbolReferenceInFile(element.name, checker, sourceFile, (id) => {
      const access = factory.createPropertyAccessExpression(factory.createIdentifier(namespaceImportName), propertyName);
      if (isShorthandPropertyAssignment(id.parent)) {
        changes.replaceNode(sourceFile, id.parent, factory.createPropertyAssignment(id.text, access));
      } else if (isExportSpecifier(id.parent)) {
        neededNamedImports.add(element);
      } else {
        changes.replaceNode(sourceFile, id, access);
      }
    });
  }
  changes.replaceNode(
    sourceFile,
    toConvert,
    shouldUseDefault ? factory.createIdentifier(namespaceImportName) : factory.createNamespaceImport(factory.createIdentifier(namespaceImportName))
  );
  if (neededNamedImports.size && isImportDeclaration(importDecl)) {
    const newNamedImports = arrayFrom(neededNamedImports.values(), (element) => factory.createImportSpecifier(element.isTypeOnly, element.propertyName && factory.createIdentifier(element.propertyName.text), factory.createIdentifier(element.name.text)));
    changes.insertNodeAfter(sourceFile, toConvert.parent.parent, createImport(
      importDecl,
      /*defaultImportName*/
      void 0,
      newNamedImports
    ));
  }
}
function isExportEqualsModule(moduleSpecifier, checker) {
  const externalModule = checker.resolveExternalModuleName(moduleSpecifier);
  if (!externalModule) return false;
  const exportEquals = checker.resolveExternalModuleSymbol(externalModule);
  return externalModule !== exportEquals;
}
function createImport(node, defaultImportName, elements) {
  return factory.createImportDeclaration(
    /*modifiers*/
    void 0,
    createImportClause(defaultImportName, elements),
    node.moduleSpecifier,
    /*attributes*/
    void 0
  );
}
function createImportClause(defaultImportName, elements) {
  return factory.createImportClause(
    /*isTypeOnly*/
    false,
    defaultImportName,
    elements && elements.length ? factory.createNamedImports(elements) : void 0
  );
}

// src/services/refactors/extractType.ts
var refactorName3 = "Extract type";
var extractToTypeAliasAction = {
  name: "Extract to type alias",
  description: getLocaleSpecificMessage(Diagnostics.Extract_to_type_alias),
  kind: "refactor.extract.type"
};
var extractToInterfaceAction = {
  name: "Extract to interface",
  description: getLocaleSpecificMessage(Diagnostics.Extract_to_interface),
  kind: "refactor.extract.interface"
};
var extractToTypeDefAction = {
  name: "Extract to typedef",
  description: getLocaleSpecificMessage(Diagnostics.Extract_to_typedef),
  kind: "refactor.extract.typedef"
};
registerRefactor(refactorName3, {
  kinds: [
    extractToTypeAliasAction.kind,
    extractToInterfaceAction.kind,
    extractToTypeDefAction.kind
  ],
  getAvailableActions: function getRefactorActionsToExtractType(context) {
    const { info, affectedTextRange } = getRangeToExtract(context, context.triggerReason === "invoked");
    if (!info) return emptyArray;
    if (!isRefactorErrorInfo(info)) {
      const refactorInfo = [{
        name: refactorName3,
        description: getLocaleSpecificMessage(Diagnostics.Extract_type),
        actions: info.isJS ? [extractToTypeDefAction] : append([extractToTypeAliasAction], info.typeElements && extractToInterfaceAction)
      }];
      return refactorInfo.map((info2) => ({
        ...info2,
        actions: info2.actions.map((action) => ({
          ...action,
          range: affectedTextRange ? {
            start: { line: getLineAndCharacterOfPosition(context.file, affectedTextRange.pos).line, offset: getLineAndCharacterOfPosition(context.file, affectedTextRange.pos).character },
            end: { line: getLineAndCharacterOfPosition(context.file, affectedTextRange.end).line, offset: getLineAndCharacterOfPosition(context.file, affectedTextRange.end).character }
          } : void 0
        }))
      }));
    }
    if (context.preferences.provideRefactorNotApplicableReason) {
      return [{
        name: refactorName3,
        description: getLocaleSpecificMessage(Diagnostics.Extract_type),
        actions: [
          { ...extractToTypeDefAction, notApplicableReason: info.error },
          { ...extractToTypeAliasAction, notApplicableReason: info.error },
          { ...extractToInterfaceAction, notApplicableReason: info.error }
        ]
      }];
    }
    return emptyArray;
  },
  getEditsForAction: function getRefactorEditsToExtractType(context, actionName2) {
    const { file } = context;
    const { info } = getRangeToExtract(context);
    Debug.assert(info && !isRefactorErrorInfo(info), "Expected to find a range to extract");
    const name = getUniqueName("NewType", file);
    const edits = ts_textChanges_exports.ChangeTracker.with(context, (changes) => {
      switch (actionName2) {
        case extractToTypeAliasAction.name:
          Debug.assert(!info.isJS, "Invalid actionName/JS combo");
          return doTypeAliasChange(changes, file, name, info);
        case extractToTypeDefAction.name:
          Debug.assert(info.isJS, "Invalid actionName/JS combo");
          return doTypedefChange(changes, context, file, name, info);
        case extractToInterfaceAction.name:
          Debug.assert(!info.isJS && !!info.typeElements, "Invalid actionName/JS combo");
          return doInterfaceChange(changes, file, name, info);
        default:
          Debug.fail("Unexpected action name");
      }
    });
    const renameFilename = file.fileName;
    const renameLocation = getRenameLocation(
      edits,
      renameFilename,
      name,
      /*preferLastLocation*/
      false
    );
    return { edits, renameFilename, renameLocation };
  }
});
function getRangeToExtract(context, considerEmptySpans = true) {
  const { file, startPosition } = context;
  const isJS = isSourceFileJS(file);
  const range = createTextRangeFromSpan(getRefactorContextSpan(context));
  const isCursorRequest = range.pos === range.end && considerEmptySpans;
  const firstType = getFirstTypeAt(file, startPosition, range, isCursorRequest);
  if (!firstType || !isTypeNode(firstType)) return { info: { error: getLocaleSpecificMessage(Diagnostics.Selection_is_not_a_valid_type_node) }, affectedTextRange: void 0 };
  const checker = context.program.getTypeChecker();
  const enclosingNode = getEnclosingNode(firstType, isJS);
  if (enclosingNode === void 0) return { info: { error: getLocaleSpecificMessage(Diagnostics.No_type_could_be_extracted_from_this_type_node) }, affectedTextRange: void 0 };
  const expandedFirstType = getExpandedSelectionNode(firstType, enclosingNode);
  if (!isTypeNode(expandedFirstType)) return { info: { error: getLocaleSpecificMessage(Diagnostics.Selection_is_not_a_valid_type_node) }, affectedTextRange: void 0 };
  const typeList = [];
  if ((isUnionTypeNode(expandedFirstType.parent) || isIntersectionTypeNode(expandedFirstType.parent)) && range.end > firstType.end) {
    addRange(
      typeList,
      expandedFirstType.parent.types.filter((type) => {
        return nodeOverlapsWithStartEnd(type, file, range.pos, range.end);
      })
    );
  }
  const selection = typeList.length > 1 ? typeList : expandedFirstType;
  const { typeParameters, affectedTextRange } = collectTypeParameters(checker, selection, enclosingNode, file);
  if (!typeParameters) return { info: { error: getLocaleSpecificMessage(Diagnostics.No_type_could_be_extracted_from_this_type_node) }, affectedTextRange: void 0 };
  const typeElements = flattenTypeLiteralNodeReference(checker, selection);
  return { info: { isJS, selection, enclosingNode, typeParameters, typeElements }, affectedTextRange };
}
function getFirstTypeAt(file, startPosition, range, isCursorRequest) {
  const currentNodes = [
    () => getTokenAtPosition(file, startPosition),
    () => getTouchingToken(file, startPosition, () => true)
  ];
  for (const f of currentNodes) {
    const current = f();
    const overlappingRange = nodeOverlapsWithStartEnd(current, file, range.pos, range.end);
    const firstType = findAncestor(current, (node) => node.parent && isTypeNode(node) && !rangeContainsSkipTrivia(range, node.parent, file) && (isCursorRequest || overlappingRange));
    if (firstType) {
      return firstType;
    }
  }
  return void 0;
}
function flattenTypeLiteralNodeReference(checker, selection) {
  if (!selection) return void 0;
  if (isArray(selection)) {
    const result = [];
    for (const type of selection) {
      const flattenedTypeMembers = flattenTypeLiteralNodeReference(checker, type);
      if (!flattenedTypeMembers) return void 0;
      addRange(result, flattenedTypeMembers);
    }
    return result;
  }
  if (isIntersectionTypeNode(selection)) {
    const result = [];
    const seen = /* @__PURE__ */ new Map();
    for (const type of selection.types) {
      const flattenedTypeMembers = flattenTypeLiteralNodeReference(checker, type);
      if (!flattenedTypeMembers || !flattenedTypeMembers.every((type2) => type2.name && addToSeen(seen, getNameFromPropertyName(type2.name)))) {
        return void 0;
      }
      addRange(result, flattenedTypeMembers);
    }
    return result;
  } else if (isParenthesizedTypeNode(selection)) {
    return flattenTypeLiteralNodeReference(checker, selection.type);
  } else if (isTypeLiteralNode(selection)) {
    return selection.members;
  }
  return void 0;
}
function rangeContainsSkipTrivia(r1, node, file) {
  return rangeContainsStartEnd(r1, skipTrivia(file.text, node.pos), node.end);
}
function collectTypeParameters(checker, selection, enclosingNode, file) {
  const result = [];
  const selectionArray = toArray(selection);
  const selectionRange = { pos: selectionArray[0].getStart(file), end: selectionArray[selectionArray.length - 1].end };
  for (const t of selectionArray) {
    if (visitor(t)) return { typeParameters: void 0, affectedTextRange: void 0 };
  }
  return { typeParameters: result, affectedTextRange: selectionRange };
  function visitor(node) {
    if (isTypeReferenceNode(node)) {
      if (isIdentifier(node.typeName)) {
        const typeName = node.typeName;
        const symbol = checker.resolveName(
          typeName.text,
          typeName,
          262144 /* TypeParameter */,
          /*excludeGlobals*/
          true
        );
        for (const decl of (symbol == null ? void 0 : symbol.declarations) || emptyArray) {
          if (isTypeParameterDeclaration(decl) && decl.getSourceFile() === file) {
            if (decl.name.escapedText === typeName.escapedText && rangeContainsSkipTrivia(decl, selectionRange, file)) {
              return true;
            }
            if (rangeContainsSkipTrivia(enclosingNode, decl, file) && !rangeContainsSkipTrivia(selectionRange, decl, file)) {
              pushIfUnique(result, decl);
              break;
            }
          }
        }
      }
    } else if (isInferTypeNode(node)) {
      const conditionalTypeNode = findAncestor(node, (n) => isConditionalTypeNode(n) && rangeContainsSkipTrivia(n.extendsType, node, file));
      if (!conditionalTypeNode || !rangeContainsSkipTrivia(selectionRange, conditionalTypeNode, file)) {
        return true;
      }
    } else if (isTypePredicateNode(node) || isThisTypeNode(node)) {
      const functionLikeNode = findAncestor(node.parent, isFunctionLike);
      if (functionLikeNode && functionLikeNode.type && rangeContainsSkipTrivia(functionLikeNode.type, node, file) && !rangeContainsSkipTrivia(selectionRange, functionLikeNode, file)) {
        return true;
      }
    } else if (isTypeQueryNode(node)) {
      if (isIdentifier(node.exprName)) {
        const symbol = checker.resolveName(
          node.exprName.text,
          node.exprName,
          111551 /* Value */,
          /*excludeGlobals*/
          false
        );
        if ((symbol == null ? void 0 : symbol.valueDeclaration) && rangeContainsSkipTrivia(enclosingNode, symbol.valueDeclaration, file) && !rangeContainsSkipTrivia(selectionRange, symbol.valueDeclaration, file)) {
          return true;
        }
      } else {
        if (isThisIdentifier(node.exprName.left) && !rangeContainsSkipTrivia(selectionRange, node.parent, file)) {
          return true;
        }
      }
    }
    if (file && isTupleTypeNode(node) && getLineAndCharacterOfPosition(file, node.pos).line === getLineAndCharacterOfPosition(file, node.end).line) {
      setEmitFlags(node, 1 /* SingleLine */);
    }
    return forEachChild(node, visitor);
  }
}
function doTypeAliasChange(changes, file, name, info) {
  const { enclosingNode, typeParameters } = info;
  const { firstTypeNode, lastTypeNode, newTypeNode } = getNodesToEdit(info);
  const newTypeDeclaration = factory.createTypeAliasDeclaration(
    /*modifiers*/
    void 0,
    name,
    typeParameters.map((id) => factory.updateTypeParameterDeclaration(
      id,
      id.modifiers,
      id.name,
      id.constraint,
      /*defaultType*/
      void 0
    )),
    newTypeNode
  );
  changes.insertNodeBefore(
    file,
    enclosingNode,
    ignoreSourceNewlines(newTypeDeclaration),
    /*blankLineBetween*/
    true
  );
  changes.replaceNodeRange(file, firstTypeNode, lastTypeNode, factory.createTypeReferenceNode(name, typeParameters.map((id) => factory.createTypeReferenceNode(
    id.name,
    /*typeArguments*/
    void 0
  ))), { leadingTriviaOption: ts_textChanges_exports.LeadingTriviaOption.Exclude, trailingTriviaOption: ts_textChanges_exports.TrailingTriviaOption.ExcludeWhitespace });
}
function doInterfaceChange(changes, file, name, info) {
  var _a;
  const { enclosingNode, typeParameters, typeElements } = info;
  const newTypeNode = factory.createInterfaceDeclaration(
    /*modifiers*/
    void 0,
    name,
    typeParameters,
    /*heritageClauses*/
    void 0,
    typeElements
  );
  setTextRange(newTypeNode, (_a = typeElements[0]) == null ? void 0 : _a.parent);
  changes.insertNodeBefore(
    file,
    enclosingNode,
    ignoreSourceNewlines(newTypeNode),
    /*blankLineBetween*/
    true
  );
  const { firstTypeNode, lastTypeNode } = getNodesToEdit(info);
  changes.replaceNodeRange(file, firstTypeNode, lastTypeNode, factory.createTypeReferenceNode(name, typeParameters.map((id) => factory.createTypeReferenceNode(
    id.name,
    /*typeArguments*/
    void 0
  ))), { leadingTriviaOption: ts_textChanges_exports.LeadingTriviaOption.Exclude, trailingTriviaOption: ts_textChanges_exports.TrailingTriviaOption.ExcludeWhitespace });
}
function doTypedefChange(changes, context, file, name, info) {
  var _a;
  toArray(info.selection).forEach((typeNode) => {
    setEmitFlags(typeNode, 3072 /* NoComments */ | 4096 /* NoNestedComments */);
  });
  const { enclosingNode, typeParameters } = info;
  const { firstTypeNode, lastTypeNode, newTypeNode } = getNodesToEdit(info);
  const node = factory.createJSDocTypedefTag(
    factory.createIdentifier("typedef"),
    factory.createJSDocTypeExpression(newTypeNode),
    factory.createIdentifier(name)
  );
  const templates = [];
  forEach(typeParameters, (typeParameter) => {
    const constraint = getEffectiveConstraintOfTypeParameter(typeParameter);
    const parameter = factory.createTypeParameterDeclaration(
      /*modifiers*/
      void 0,
      typeParameter.name
    );
    const template = factory.createJSDocTemplateTag(
      factory.createIdentifier("template"),
      constraint && cast(constraint, isJSDocTypeExpression),
      [parameter]
    );
    templates.push(template);
  });
  const jsDoc = factory.createJSDocComment(
    /*comment*/
    void 0,
    factory.createNodeArray(concatenate(templates, [node]))
  );
  if (isJSDoc(enclosingNode)) {
    const pos = enclosingNode.getStart(file);
    const newLineCharacter = getNewLineOrDefaultFromHost(context.host, (_a = context.formatContext) == null ? void 0 : _a.options);
    changes.insertNodeAt(file, enclosingNode.getStart(file), jsDoc, {
      suffix: newLineCharacter + newLineCharacter + file.text.slice(getPrecedingNonSpaceCharacterPosition(file.text, pos - 1), pos)
    });
  } else {
    changes.insertNodeBefore(
      file,
      enclosingNode,
      jsDoc,
      /*blankLineBetween*/
      true
    );
  }
  changes.replaceNodeRange(file, firstTypeNode, lastTypeNode, factory.createTypeReferenceNode(name, typeParameters.map((id) => factory.createTypeReferenceNode(
    id.name,
    /*typeArguments*/
    void 0
  ))));
}
function getNodesToEdit(info) {
  if (isArray(info.selection)) {
    return {
      firstTypeNode: info.selection[0],
      lastTypeNode: info.selection[info.selection.length - 1],
      newTypeNode: isUnionTypeNode(info.selection[0].parent) ? factory.createUnionTypeNode(info.selection) : factory.createIntersectionTypeNode(info.selection)
    };
  }
  return {
    firstTypeNode: info.selection,
    lastTypeNode: info.selection,
    newTypeNode: info.selection
  };
}
function getEnclosingNode(node, isJS) {
  return findAncestor(node, isStatement) || (isJS ? findAncestor(node, isJSDoc) : void 0);
}
function getExpandedSelectionNode(firstType, enclosingNode) {
  return findAncestor(firstType, (node) => {
    if (node === enclosingNode) return "quit";
    if (isUnionTypeNode(node.parent) || isIntersectionTypeNode(node.parent)) {
      return true;
    }
    return false;
  }) ?? firstType;
}

// src/services/refactors/moveToFile.ts
var refactorNameForMoveToFile = "Move to file";
var description = getLocaleSpecificMessage(Diagnostics.Move_to_file);
var moveToFileAction = {
  name: "Move to file",
  description,
  kind: "refactor.move.file"
};
registerRefactor(refactorNameForMoveToFile, {
  kinds: [moveToFileAction.kind],
  getAvailableActions: function getRefactorActionsToMoveToFile(context, interactiveRefactorArguments) {
    const file = context.file;
    const statements = getStatementsToMove(context);
    if (!interactiveRefactorArguments) {
      return emptyArray;
    }
    if (context.triggerReason === "implicit" && context.endPosition !== void 0) {
      const startNodeAncestor = findAncestor(getTokenAtPosition(file, context.startPosition), isBlockLike);
      const endNodeAncestor = findAncestor(getTokenAtPosition(file, context.endPosition), isBlockLike);
      if (startNodeAncestor && !isSourceFile(startNodeAncestor) && endNodeAncestor && !isSourceFile(endNodeAncestor)) {
        return emptyArray;
      }
    }
    if (context.preferences.allowTextChangesInNewFiles && statements) {
      const affectedTextRange = {
        start: { line: getLineAndCharacterOfPosition(file, statements.all[0].getStart(file)).line, offset: getLineAndCharacterOfPosition(file, statements.all[0].getStart(file)).character },
        end: { line: getLineAndCharacterOfPosition(file, last(statements.all).end).line, offset: getLineAndCharacterOfPosition(file, last(statements.all).end).character }
      };
      return [{ name: refactorNameForMoveToFile, description, actions: [{ ...moveToFileAction, range: affectedTextRange }] }];
    }
    if (context.preferences.provideRefactorNotApplicableReason) {
      return [{ name: refactorNameForMoveToFile, description, actions: [{ ...moveToFileAction, notApplicableReason: getLocaleSpecificMessage(Diagnostics.Selection_is_not_a_valid_statement_or_statements) }] }];
    }
    return emptyArray;
  },
  getEditsForAction: function getRefactorEditsToMoveToFile(context, actionName2, interactiveRefactorArguments) {
    Debug.assert(actionName2 === refactorNameForMoveToFile, "Wrong refactor invoked");
    const statements = Debug.checkDefined(getStatementsToMove(context));
    const { host, program } = context;
    Debug.assert(interactiveRefactorArguments, "No interactive refactor arguments available");
    const targetFile = interactiveRefactorArguments.targetFile;
    if (hasJSFileExtension(targetFile) || hasTSFileExtension(targetFile)) {
      if (host.fileExists(targetFile) && program.getSourceFile(targetFile) === void 0) {
        return error(getLocaleSpecificMessage(Diagnostics.Cannot_move_statements_to_the_selected_file));
      }
      const edits = ts_textChanges_exports.ChangeTracker.with(context, (t) => doChange3(context, context.file, interactiveRefactorArguments.targetFile, context.program, statements, t, context.host, context.preferences));
      return { edits, renameFilename: void 0, renameLocation: void 0 };
    }
    return error(getLocaleSpecificMessage(Diagnostics.Cannot_move_to_file_selected_file_is_invalid));
  }
});
function error(notApplicableReason) {
  return { edits: [], renameFilename: void 0, renameLocation: void 0, notApplicableReason };
}
function doChange3(context, oldFile, targetFile, program, toMove, changes, host, preferences) {
  const checker = program.getTypeChecker();
  const isForNewFile = !host.fileExists(targetFile);
  const targetSourceFile = isForNewFile ? createFutureSourceFile(targetFile, oldFile.externalModuleIndicator ? 99 /* ESNext */ : oldFile.commonJsModuleIndicator ? 1 /* CommonJS */ : void 0, program, host) : Debug.checkDefined(program.getSourceFile(targetFile));
  const importAdderForOldFile = ts_codefix_exports.createImportAdder(oldFile, context.program, context.preferences, context.host);
  const importAdderForNewFile = ts_codefix_exports.createImportAdder(targetSourceFile, context.program, context.preferences, context.host);
  getNewStatementsAndRemoveFromOldFile(oldFile, targetSourceFile, getUsageInfo(oldFile, toMove.all, checker, isForNewFile ? void 0 : getExistingLocals(targetSourceFile, toMove.all, checker)), changes, toMove, program, host, preferences, importAdderForNewFile, importAdderForOldFile);
  if (isForNewFile) {
    addNewFileToTsconfig(program, changes, oldFile.fileName, targetFile, hostGetCanonicalFileName(host));
  }
}
function getNewStatementsAndRemoveFromOldFile(oldFile, targetFile, usage, changes, toMove, program, host, preferences, importAdderForNewFile, importAdderForOldFile) {
  const checker = program.getTypeChecker();
  const prologueDirectives = takeWhile(oldFile.statements, isPrologueDirective);
  const useEsModuleSyntax = !fileShouldUseJavaScriptRequire(targetFile.fileName, program, host, !!oldFile.commonJsModuleIndicator);
  const quotePreference = getQuotePreference(oldFile, preferences);
  addImportsForMovedSymbols(usage.oldFileImportsFromTargetFile, targetFile.fileName, importAdderForOldFile, program);
  deleteUnusedOldImports(oldFile, toMove.all, usage.unusedImportsFromOldFile, importAdderForOldFile);
  importAdderForOldFile.writeFixes(changes, quotePreference);
  deleteMovedStatements(oldFile, toMove.ranges, changes);
  updateImportsInOtherFiles(changes, program, host, oldFile, usage.movedSymbols, targetFile.fileName, quotePreference);
  addExportsInOldFile(oldFile, usage.targetFileImportsFromOldFile, changes, useEsModuleSyntax);
  addTargetFileImports(oldFile, usage.oldImportsNeededByTargetFile, usage.targetFileImportsFromOldFile, checker, program, importAdderForNewFile);
  if (!isFullSourceFile(targetFile) && prologueDirectives.length) {
    changes.insertStatementsInNewFile(targetFile.fileName, prologueDirectives, oldFile);
  }
  importAdderForNewFile.writeFixes(changes, quotePreference);
  const body = addExports(oldFile, toMove.all, arrayFrom(usage.oldFileImportsFromTargetFile.keys()), useEsModuleSyntax);
  if (isFullSourceFile(targetFile) && targetFile.statements.length > 0) {
    moveStatementsToTargetFile(changes, program, body, targetFile, toMove);
  } else if (isFullSourceFile(targetFile)) {
    changes.insertNodesAtEndOfFile(
      targetFile,
      body,
      /*blankLineBetween*/
      false
    );
  } else {
    changes.insertStatementsInNewFile(targetFile.fileName, importAdderForNewFile.hasFixes() ? [4 /* NewLineTrivia */, ...body] : body, oldFile);
  }
}
function addNewFileToTsconfig(program, changes, oldFileName, newFileNameWithExtension, getCanonicalFileName) {
  const cfg = program.getCompilerOptions().configFile;
  if (!cfg) return;
  const newFileAbsolutePath = normalizePath(combinePaths(oldFileName, "..", newFileNameWithExtension));
  const newFilePath = getRelativePathFromFile(cfg.fileName, newFileAbsolutePath, getCanonicalFileName);
  const cfgObject = cfg.statements[0] && tryCast(cfg.statements[0].expression, isObjectLiteralExpression);
  const filesProp = cfgObject && find(cfgObject.properties, (prop) => isPropertyAssignment(prop) && isStringLiteral(prop.name) && prop.name.text === "files");
  if (filesProp && isArrayLiteralExpression(filesProp.initializer)) {
    changes.insertNodeInListAfter(cfg, last(filesProp.initializer.elements), factory.createStringLiteral(newFilePath), filesProp.initializer.elements);
  }
}
function deleteMovedStatements(sourceFile, moved, changes) {
  for (const { first: first2, afterLast } of moved) {
    changes.deleteNodeRangeExcludingEnd(sourceFile, first2, afterLast);
  }
}
function deleteUnusedOldImports(oldFile, toMove, toDelete, importAdder) {
  for (const statement of oldFile.statements) {
    if (contains(toMove, statement)) continue;
    forEachImportInStatement(statement, (i) => {
      forEachAliasDeclarationInImportOrRequire(i, (decl) => {
        if (toDelete.has(decl.symbol)) {
          importAdder.removeExistingImport(decl);
        }
      });
    });
  }
}
function addExportsInOldFile(oldFile, targetFileImportsFromOldFile, changes, useEsModuleSyntax) {
  const markSeenTop = nodeSeenTracker();
  targetFileImportsFromOldFile.forEach((_, symbol) => {
    if (!symbol.declarations) {
      return;
    }
    for (const decl of symbol.declarations) {
      if (!isTopLevelDeclaration(decl)) continue;
      const name = nameOfTopLevelDeclaration(decl);
      if (!name) continue;
      const top = getTopLevelDeclarationStatement(decl);
      if (markSeenTop(top)) {
        addExportToChanges(oldFile, top, name, changes, useEsModuleSyntax);
      }
    }
  });
}
function updateImportsInOtherFiles(changes, program, host, oldFile, movedSymbols, targetFileName, quotePreference) {
  const checker = program.getTypeChecker();
  for (const sourceFile of program.getSourceFiles()) {
    if (sourceFile === oldFile) continue;
    for (const statement of sourceFile.statements) {
      forEachImportInStatement(statement, (importNode) => {
        if (checker.getSymbolAtLocation(moduleSpecifierFromImport(importNode)) !== oldFile.symbol) return;
        const shouldMove = (name) => {
          const symbol = isBindingElement(name.parent) ? getPropertySymbolFromBindingElement(checker, name.parent) : skipAlias(checker.getSymbolAtLocation(name), checker);
          return !!symbol && movedSymbols.has(symbol);
        };
        deleteUnusedImports(sourceFile, importNode, changes, shouldMove);
        const pathToTargetFileWithExtension = resolvePath(getDirectoryPath(getNormalizedAbsolutePath(oldFile.fileName, program.getCurrentDirectory())), targetFileName);
        if (getStringComparer(!program.useCaseSensitiveFileNames())(pathToTargetFileWithExtension, sourceFile.fileName) === 0 /* EqualTo */) return;
        const newModuleSpecifier = getModuleSpecifier(program.getCompilerOptions(), sourceFile, sourceFile.fileName, pathToTargetFileWithExtension, createModuleSpecifierResolutionHost(program, host));
        const newImportDeclaration = filterImport(importNode, makeStringLiteral(newModuleSpecifier, quotePreference), shouldMove);
        if (newImportDeclaration) changes.insertNodeAfter(sourceFile, statement, newImportDeclaration);
        const ns = getNamespaceLikeImport(importNode);
        if (ns) updateNamespaceLikeImport(changes, sourceFile, checker, movedSymbols, newModuleSpecifier, ns, importNode, quotePreference);
      });
    }
  }
}
function getNamespaceLikeImport(node) {
  switch (node.kind) {
    case 272 /* ImportDeclaration */:
      return node.importClause && node.importClause.namedBindings && node.importClause.namedBindings.kind === 274 /* NamespaceImport */ ? node.importClause.namedBindings.name : void 0;
    case 271 /* ImportEqualsDeclaration */:
      return node.name;
    case 260 /* VariableDeclaration */:
      return tryCast(node.name, isIdentifier);
    default:
      return Debug.assertNever(node, `Unexpected node kind ${node.kind}`);
  }
}
function updateNamespaceLikeImport(changes, sourceFile, checker, movedSymbols, newModuleSpecifier, oldImportId, oldImportNode, quotePreference) {
  const preferredNewNamespaceName = moduleSpecifierToValidIdentifier(newModuleSpecifier, 99 /* ESNext */);
  let needUniqueName = false;
  const toChange = [];
  ts_FindAllReferences_exports.Core.eachSymbolReferenceInFile(oldImportId, checker, sourceFile, (ref) => {
    if (!isPropertyAccessExpression(ref.parent)) return;
    needUniqueName = needUniqueName || !!checker.resolveName(
      preferredNewNamespaceName,
      ref,
      -1 /* All */,
      /*excludeGlobals*/
      true
    );
    if (movedSymbols.has(checker.getSymbolAtLocation(ref.parent.name))) {
      toChange.push(ref);
    }
  });
  if (toChange.length) {
    const newNamespaceName = needUniqueName ? getUniqueName(preferredNewNamespaceName, sourceFile) : preferredNewNamespaceName;
    for (const ref of toChange) {
      changes.replaceNode(sourceFile, ref, factory.createIdentifier(newNamespaceName));
    }
    changes.insertNodeAfter(sourceFile, oldImportNode, updateNamespaceLikeImportNode(oldImportNode, preferredNewNamespaceName, newModuleSpecifier, quotePreference));
  }
}
function updateNamespaceLikeImportNode(node, newNamespaceName, newModuleSpecifier, quotePreference) {
  const newNamespaceId = factory.createIdentifier(newNamespaceName);
  const newModuleString = makeStringLiteral(newModuleSpecifier, quotePreference);
  switch (node.kind) {
    case 272 /* ImportDeclaration */:
      return factory.createImportDeclaration(
        /*modifiers*/
        void 0,
        factory.createImportClause(
          /*isTypeOnly*/
          false,
          /*name*/
          void 0,
          factory.createNamespaceImport(newNamespaceId)
        ),
        newModuleString,
        /*attributes*/
        void 0
      );
    case 271 /* ImportEqualsDeclaration */:
      return factory.createImportEqualsDeclaration(
        /*modifiers*/
        void 0,
        /*isTypeOnly*/
        false,
        newNamespaceId,
        factory.createExternalModuleReference(newModuleString)
      );
    case 260 /* VariableDeclaration */:
      return factory.createVariableDeclaration(
        newNamespaceId,
        /*exclamationToken*/
        void 0,
        /*type*/
        void 0,
        createRequireCall(newModuleString)
      );
    default:
      return Debug.assertNever(node, `Unexpected node kind ${node.kind}`);
  }
}
function createRequireCall(moduleSpecifier) {
  return factory.createCallExpression(
    factory.createIdentifier("require"),
    /*typeArguments*/
    void 0,
    [moduleSpecifier]
  );
}
function moduleSpecifierFromImport(i) {
  return i.kind === 272 /* ImportDeclaration */ ? i.moduleSpecifier : i.kind === 271 /* ImportEqualsDeclaration */ ? i.moduleReference.expression : i.initializer.arguments[0];
}
function forEachImportInStatement(statement, cb) {
  if (isImportDeclaration(statement)) {
    if (isStringLiteral(statement.moduleSpecifier)) cb(statement);
  } else if (isImportEqualsDeclaration(statement)) {
    if (isExternalModuleReference(statement.moduleReference) && isStringLiteralLike(statement.moduleReference.expression)) {
      cb(statement);
    }
  } else if (isVariableStatement(statement)) {
    for (const decl of statement.declarationList.declarations) {
      if (decl.initializer && isRequireCall(
        decl.initializer,
        /*requireStringLiteralLikeArgument*/
        true
      )) {
        cb(decl);
      }
    }
  }
}
function forEachAliasDeclarationInImportOrRequire(importOrRequire, cb) {
  var _a, _b, _c, _d, _e;
  if (importOrRequire.kind === 272 /* ImportDeclaration */) {
    if ((_a = importOrRequire.importClause) == null ? void 0 : _a.name) {
      cb(importOrRequire.importClause);
    }
    if (((_c = (_b = importOrRequire.importClause) == null ? void 0 : _b.namedBindings) == null ? void 0 : _c.kind) === 274 /* NamespaceImport */) {
      cb(importOrRequire.importClause.namedBindings);
    }
    if (((_e = (_d = importOrRequire.importClause) == null ? void 0 : _d.namedBindings) == null ? void 0 : _e.kind) === 275 /* NamedImports */) {
      for (const element of importOrRequire.importClause.namedBindings.elements) {
        cb(element);
      }
    }
  } else if (importOrRequire.kind === 271 /* ImportEqualsDeclaration */) {
    cb(importOrRequire);
  } else if (importOrRequire.kind === 260 /* VariableDeclaration */) {
    if (importOrRequire.name.kind === 80 /* Identifier */) {
      cb(importOrRequire);
    } else if (importOrRequire.name.kind === 206 /* ObjectBindingPattern */) {
      for (const element of importOrRequire.name.elements) {
        if (isIdentifier(element.name)) {
          cb(element);
        }
      }
    }
  }
}
function addImportsForMovedSymbols(symbols, targetFileName, importAdder, program) {
  for (const [symbol, isValidTypeOnlyUseSite] of symbols) {
    const symbolName2 = getNameForExportedSymbol(symbol, getEmitScriptTarget(program.getCompilerOptions()));
    const exportKind = symbol.name === "default" && symbol.parent ? 1 /* Default */ : 0 /* Named */;
    importAdder.addImportForNonExistentExport(symbolName2, targetFileName, exportKind, symbol.flags, isValidTypeOnlyUseSite);
  }
}
function makeVariableStatement(name, type, initializer, flags = 2 /* Const */) {
  return factory.createVariableStatement(
    /*modifiers*/
    void 0,
    factory.createVariableDeclarationList([factory.createVariableDeclaration(
      name,
      /*exclamationToken*/
      void 0,
      type,
      initializer
    )], flags)
  );
}
function addExports(sourceFile, toMove, needExport, useEs6Exports) {
  return flatMap(toMove, (statement) => {
    if (isTopLevelDeclarationStatement(statement) && !isExported(sourceFile, statement, useEs6Exports) && forEachTopLevelDeclaration(statement, (d) => {
      var _a;
      return needExport.includes(Debug.checkDefined((_a = tryCast(d, canHaveSymbol)) == null ? void 0 : _a.symbol));
    })) {
      const exports2 = addExport(getSynthesizedDeepClone(statement), useEs6Exports);
      if (exports2) return exports2;
    }
    return getSynthesizedDeepClone(statement);
  });
}
function isExported(sourceFile, decl, useEs6Exports, name) {
  var _a;
  if (useEs6Exports) {
    return !isExpressionStatement(decl) && hasSyntacticModifier(decl, 32 /* Export */) || !!(name && sourceFile.symbol && ((_a = sourceFile.symbol.exports) == null ? void 0 : _a.has(name.escapedText)));
  }
  return !!sourceFile.symbol && !!sourceFile.symbol.exports && getNamesToExportInCommonJS(decl).some((name2) => sourceFile.symbol.exports.has(escapeLeadingUnderscores(name2)));
}
function deleteUnusedImports(sourceFile, importDecl, changes, isUnused) {
  if (importDecl.kind === 272 /* ImportDeclaration */ && importDecl.importClause) {
    const { name, namedBindings } = importDecl.importClause;
    if ((!name || isUnused(name)) && (!namedBindings || namedBindings.kind === 275 /* NamedImports */ && namedBindings.elements.length !== 0 && namedBindings.elements.every((e) => isUnused(e.name)))) {
      return changes.delete(sourceFile, importDecl);
    }
  }
  forEachAliasDeclarationInImportOrRequire(importDecl, (i) => {
    if (i.name && isIdentifier(i.name) && isUnused(i.name)) {
      changes.delete(sourceFile, i);
    }
  });
}
function isTopLevelDeclarationStatement(node) {
  Debug.assert(isSourceFile(node.parent), "Node parent should be a SourceFile");
  return isNonVariableTopLevelDeclaration(node) || isVariableStatement(node);
}
function addExport(decl, useEs6Exports) {
  return useEs6Exports ? [addEs6Export(decl)] : addCommonjsExport(decl);
}
function addEs6Export(d) {
  const modifiers = canHaveModifiers(d) ? concatenate([factory.createModifier(95 /* ExportKeyword */)], getModifiers(d)) : void 0;
  switch (d.kind) {
    case 262 /* FunctionDeclaration */:
      return factory.updateFunctionDeclaration(d, modifiers, d.asteriskToken, d.name, d.typeParameters, d.parameters, d.type, d.body);
    case 263 /* ClassDeclaration */:
      const decorators = canHaveDecorators(d) ? getDecorators(d) : void 0;
      return factory.updateClassDeclaration(d, concatenate(decorators, modifiers), d.name, d.typeParameters, d.heritageClauses, d.members);
    case 243 /* VariableStatement */:
      return factory.updateVariableStatement(d, modifiers, d.declarationList);
    case 267 /* ModuleDeclaration */:
      return factory.updateModuleDeclaration(d, modifiers, d.name, d.body);
    case 266 /* EnumDeclaration */:
      return factory.updateEnumDeclaration(d, modifiers, d.name, d.members);
    case 265 /* TypeAliasDeclaration */:
      return factory.updateTypeAliasDeclaration(d, modifiers, d.name, d.typeParameters, d.type);
    case 264 /* InterfaceDeclaration */:
      return factory.updateInterfaceDeclaration(d, modifiers, d.name, d.typeParameters, d.heritageClauses, d.members);
    case 271 /* ImportEqualsDeclaration */:
      return factory.updateImportEqualsDeclaration(d, modifiers, d.isTypeOnly, d.name, d.moduleReference);
    case 244 /* ExpressionStatement */:
      return Debug.fail();
    default:
      return Debug.assertNever(d, `Unexpected declaration kind ${d.kind}`);
  }
}
function addCommonjsExport(decl) {
  return [decl, ...getNamesToExportInCommonJS(decl).map(createExportAssignment)];
}
function createExportAssignment(name) {
  return factory.createExpressionStatement(
    factory.createBinaryExpression(
      factory.createPropertyAccessExpression(factory.createIdentifier("exports"), factory.createIdentifier(name)),
      64 /* EqualsToken */,
      factory.createIdentifier(name)
    )
  );
}
function getNamesToExportInCommonJS(decl) {
  switch (decl.kind) {
    case 262 /* FunctionDeclaration */:
    case 263 /* ClassDeclaration */:
      return [decl.name.text];
    case 243 /* VariableStatement */:
      return mapDefined(decl.declarationList.declarations, (d) => isIdentifier(d.name) ? d.name.text : void 0);
    case 267 /* ModuleDeclaration */:
    case 266 /* EnumDeclaration */:
    case 265 /* TypeAliasDeclaration */:
    case 264 /* InterfaceDeclaration */:
    case 271 /* ImportEqualsDeclaration */:
      return emptyArray;
    case 244 /* ExpressionStatement */:
      return Debug.fail("Can't export an ExpressionStatement");
    default:
      return Debug.assertNever(decl, `Unexpected decl kind ${decl.kind}`);
  }
}
function filterImport(i, moduleSpecifier, keep) {
  switch (i.kind) {
    case 272 /* ImportDeclaration */: {
      const clause = i.importClause;
      if (!clause) return void 0;
      const defaultImport = clause.name && keep(clause.name) ? clause.name : void 0;
      const namedBindings = clause.namedBindings && filterNamedBindings(clause.namedBindings, keep);
      return defaultImport || namedBindings ? factory.createImportDeclaration(
        /*modifiers*/
        void 0,
        factory.createImportClause(clause.isTypeOnly, defaultImport, namedBindings),
        getSynthesizedDeepClone(moduleSpecifier),
        /*attributes*/
        void 0
      ) : void 0;
    }
    case 271 /* ImportEqualsDeclaration */:
      return keep(i.name) ? i : void 0;
    case 260 /* VariableDeclaration */: {
      const name = filterBindingName(i.name, keep);
      return name ? makeVariableStatement(name, i.type, createRequireCall(moduleSpecifier), i.parent.flags) : void 0;
    }
    default:
      return Debug.assertNever(i, `Unexpected import kind ${i.kind}`);
  }
}
function filterNamedBindings(namedBindings, keep) {
  if (namedBindings.kind === 274 /* NamespaceImport */) {
    return keep(namedBindings.name) ? namedBindings : void 0;
  } else {
    const newElements = namedBindings.elements.filter((e) => keep(e.name));
    return newElements.length ? factory.createNamedImports(newElements) : void 0;
  }
}
function filterBindingName(name, keep) {
  switch (name.kind) {
    case 80 /* Identifier */:
      return keep(name) ? name : void 0;
    case 207 /* ArrayBindingPattern */:
      return name;
    case 206 /* ObjectBindingPattern */: {
      const newElements = name.elements.filter((prop) => prop.propertyName || !isIdentifier(prop.name) || keep(prop.name));
      return newElements.length ? factory.createObjectBindingPattern(newElements) : void 0;
    }
  }
}
function nameOfTopLevelDeclaration(d) {
  return isExpressionStatement(d) ? tryCast(d.expression.left.name, isIdentifier) : tryCast(d.name, isIdentifier);
}
function getTopLevelDeclarationStatement(d) {
  switch (d.kind) {
    case 260 /* VariableDeclaration */:
      return d.parent.parent;
    case 208 /* BindingElement */:
      return getTopLevelDeclarationStatement(
        cast(d.parent.parent, (p) => isVariableDeclaration(p) || isBindingElement(p))
      );
    default:
      return d;
  }
}
function addExportToChanges(sourceFile, decl, name, changes, useEs6Exports) {
  if (isExported(sourceFile, decl, useEs6Exports, name)) return;
  if (useEs6Exports) {
    if (!isExpressionStatement(decl)) changes.insertExportModifier(sourceFile, decl);
  } else {
    const names = getNamesToExportInCommonJS(decl);
    if (names.length !== 0) changes.insertNodesAfter(sourceFile, decl, names.map(createExportAssignment));
  }
}
function createNewFileName(oldFile, program, host, toMove) {
  const checker = program.getTypeChecker();
  if (toMove) {
    const usage = getUsageInfo(oldFile, toMove.all, checker);
    const currentDirectory = getDirectoryPath(oldFile.fileName);
    const extension = extensionFromPath(oldFile.fileName);
    const newFileName = combinePaths(
      // new file is always placed in the same directory as the old file
      currentDirectory,
      // ensures the filename computed below isn't already taken
      makeUniqueFilename(
        // infers a name for the new file from the symbols being moved
        inferNewFileName(usage.oldFileImportsFromTargetFile, usage.movedSymbols),
        extension,
        currentDirectory,
        host
      )
    ) + extension;
    return newFileName;
  }
  return "";
}
function getRangeToMove(context) {
  const { file } = context;
  const range = createTextRangeFromSpan(getRefactorContextSpan(context));
  const { statements } = file;
  let startNodeIndex = findIndex(statements, (s) => s.end > range.pos);
  if (startNodeIndex === -1) return void 0;
  const startStatement = statements[startNodeIndex];
  const overloadRangeToMove = getOverloadRangeToMove(file, startStatement);
  if (overloadRangeToMove) {
    startNodeIndex = overloadRangeToMove.start;
  }
  let endNodeIndex = findIndex(statements, (s) => s.end >= range.end, startNodeIndex);
  if (endNodeIndex !== -1 && range.end <= statements[endNodeIndex].getStart()) {
    endNodeIndex--;
  }
  const endingOverloadRangeToMove = getOverloadRangeToMove(file, statements[endNodeIndex]);
  if (endingOverloadRangeToMove) {
    endNodeIndex = endingOverloadRangeToMove.end;
  }
  return {
    toMove: statements.slice(startNodeIndex, endNodeIndex === -1 ? statements.length : endNodeIndex + 1),
    afterLast: endNodeIndex === -1 ? void 0 : statements[endNodeIndex + 1]
  };
}
function getStatementsToMove(context) {
  const rangeToMove = getRangeToMove(context);
  if (rangeToMove === void 0) return void 0;
  const all = [];
  const ranges = [];
  const { toMove, afterLast } = rangeToMove;
  getRangesWhere(toMove, isAllowedStatementToMove, (start, afterEndIndex) => {
    for (let i = start; i < afterEndIndex; i++) all.push(toMove[i]);
    ranges.push({ first: toMove[start], afterLast });
  });
  return all.length === 0 ? void 0 : { all, ranges };
}
function containsJsx(statements) {
  return find(statements, (statement) => !!(statement.transformFlags & 2 /* ContainsJsx */));
}
function isAllowedStatementToMove(statement) {
  return !isPureImport(statement) && !isPrologueDirective(statement);
}
function isPureImport(node) {
  switch (node.kind) {
    case 272 /* ImportDeclaration */:
      return true;
    case 271 /* ImportEqualsDeclaration */:
      return !hasSyntacticModifier(node, 32 /* Export */);
    case 243 /* VariableStatement */:
      return node.declarationList.declarations.every((d) => !!d.initializer && isRequireCall(
        d.initializer,
        /*requireStringLiteralLikeArgument*/
        true
      ));
    default:
      return false;
  }
}
function getUsageInfo(oldFile, toMove, checker, existingTargetLocals = /* @__PURE__ */ new Set()) {
  var _a;
  const movedSymbols = /* @__PURE__ */ new Set();
  const oldImportsNeededByTargetFile = /* @__PURE__ */ new Map();
  const targetFileImportsFromOldFile = /* @__PURE__ */ new Map();
  const jsxNamespaceSymbol = getJsxNamespaceSymbol(containsJsx(toMove));
  if (jsxNamespaceSymbol) {
    oldImportsNeededByTargetFile.set(jsxNamespaceSymbol, [false, tryCast((_a = jsxNamespaceSymbol.declarations) == null ? void 0 : _a[0], (d) => isImportSpecifier(d) || isImportClause(d) || isNamespaceImport(d) || isImportEqualsDeclaration(d) || isBindingElement(d) || isVariableDeclaration(d))]);
  }
  for (const statement of toMove) {
    forEachTopLevelDeclaration(statement, (decl) => {
      movedSymbols.add(Debug.checkDefined(isExpressionStatement(decl) ? checker.getSymbolAtLocation(decl.expression.left) : decl.symbol, "Need a symbol here"));
    });
  }
  const unusedImportsFromOldFile = /* @__PURE__ */ new Set();
  for (const statement of toMove) {
    forEachReference(statement, checker, (symbol, isValidTypeOnlyUseSite) => {
      if (!symbol.declarations || isGlobalType(checker, symbol)) {
        return;
      }
      if (existingTargetLocals.has(skipAlias(symbol, checker))) {
        unusedImportsFromOldFile.add(symbol);
        return;
      }
      for (const decl of symbol.declarations) {
        if (isInImport(decl)) {
          const prevIsTypeOnly = oldImportsNeededByTargetFile.get(symbol);
          oldImportsNeededByTargetFile.set(symbol, [
            prevIsTypeOnly === void 0 ? isValidTypeOnlyUseSite : prevIsTypeOnly && isValidTypeOnlyUseSite,
            tryCast(decl, (d) => isImportSpecifier(d) || isImportClause(d) || isNamespaceImport(d) || isImportEqualsDeclaration(d) || isBindingElement(d) || isVariableDeclaration(d))
          ]);
        } else if (isTopLevelDeclaration(decl) && sourceFileOfTopLevelDeclaration(decl) === oldFile && !movedSymbols.has(symbol)) {
          targetFileImportsFromOldFile.set(symbol, isValidTypeOnlyUseSite);
        }
      }
    });
  }
  for (const unusedImport of oldImportsNeededByTargetFile.keys()) {
    unusedImportsFromOldFile.add(unusedImport);
  }
  const oldFileImportsFromTargetFile = /* @__PURE__ */ new Map();
  for (const statement of oldFile.statements) {
    if (contains(toMove, statement)) continue;
    if (jsxNamespaceSymbol && !!(statement.transformFlags & 2 /* ContainsJsx */)) {
      unusedImportsFromOldFile.delete(jsxNamespaceSymbol);
    }
    forEachReference(statement, checker, (symbol, isValidTypeOnlyUseSite) => {
      if (movedSymbols.has(symbol)) oldFileImportsFromTargetFile.set(symbol, isValidTypeOnlyUseSite);
      unusedImportsFromOldFile.delete(symbol);
    });
  }
  return { movedSymbols, targetFileImportsFromOldFile, oldFileImportsFromTargetFile, oldImportsNeededByTargetFile, unusedImportsFromOldFile };
  function getJsxNamespaceSymbol(containsJsx2) {
    if (containsJsx2 === void 0) {
      return void 0;
    }
    const jsxNamespace = checker.getJsxNamespace(containsJsx2);
    const jsxNamespaceSymbol2 = checker.resolveName(
      jsxNamespace,
      containsJsx2,
      1920 /* Namespace */,
      /*excludeGlobals*/
      true
    );
    return !!jsxNamespaceSymbol2 && some(jsxNamespaceSymbol2.declarations, isInImport) ? jsxNamespaceSymbol2 : void 0;
  }
}
function isGlobalType(checker, symbol) {
  return !!checker.resolveName(
    symbol.name,
    /*location*/
    void 0,
    788968 /* Type */,
    /*excludeGlobals*/
    false
  );
}
function makeUniqueFilename(proposedFilename, extension, inDirectory, host) {
  let newFilename = proposedFilename;
  for (let i = 1; ; i++) {
    const name = combinePaths(inDirectory, newFilename + extension);
    if (!host.fileExists(name)) return newFilename;
    newFilename = `${proposedFilename}.${i}`;
  }
}
function inferNewFileName(importsFromNewFile, movedSymbols) {
  return forEachKey(importsFromNewFile, symbolNameNoDefault) || forEachKey(movedSymbols, symbolNameNoDefault) || "newFile";
}
function forEachReference(node, checker, onReference) {
  node.forEachChild(function cb(node2) {
    if (isIdentifier(node2) && !isDeclarationName(node2)) {
      const sym = checker.getSymbolAtLocation(node2);
      if (sym) onReference(sym, isValidTypeOnlyAliasUseSite(node2));
    } else {
      node2.forEachChild(cb);
    }
  });
}
function forEachTopLevelDeclaration(statement, cb) {
  switch (statement.kind) {
    case 262 /* FunctionDeclaration */:
    case 263 /* ClassDeclaration */:
    case 267 /* ModuleDeclaration */:
    case 266 /* EnumDeclaration */:
    case 265 /* TypeAliasDeclaration */:
    case 264 /* InterfaceDeclaration */:
    case 271 /* ImportEqualsDeclaration */:
      return cb(statement);
    case 243 /* VariableStatement */:
      return firstDefined(statement.declarationList.declarations, (decl) => forEachTopLevelDeclarationInBindingName(decl.name, cb));
    case 244 /* ExpressionStatement */: {
      const { expression } = statement;
      return isBinaryExpression(expression) && getAssignmentDeclarationKind(expression) === 1 /* ExportsProperty */ ? cb(statement) : void 0;
    }
  }
}
function isInImport(decl) {
  switch (decl.kind) {
    case 271 /* ImportEqualsDeclaration */:
    case 276 /* ImportSpecifier */:
    case 273 /* ImportClause */:
    case 274 /* NamespaceImport */:
      return true;
    case 260 /* VariableDeclaration */:
      return isVariableDeclarationInImport(decl);
    case 208 /* BindingElement */:
      return isVariableDeclaration(decl.parent.parent) && isVariableDeclarationInImport(decl.parent.parent);
    default:
      return false;
  }
}
function isVariableDeclarationInImport(decl) {
  return isSourceFile(decl.parent.parent.parent) && !!decl.initializer && isRequireCall(
    decl.initializer,
    /*requireStringLiteralLikeArgument*/
    true
  );
}
function isTopLevelDeclaration(node) {
  return isNonVariableTopLevelDeclaration(node) && isSourceFile(node.parent) || isVariableDeclaration(node) && isSourceFile(node.parent.parent.parent);
}
function sourceFileOfTopLevelDeclaration(node) {
  return isVariableDeclaration(node) ? node.parent.parent.parent : node.parent;
}
function forEachTopLevelDeclarationInBindingName(name, cb) {
  switch (name.kind) {
    case 80 /* Identifier */:
      return cb(cast(name.parent, (x) => isVariableDeclaration(x) || isBindingElement(x)));
    case 207 /* ArrayBindingPattern */:
    case 206 /* ObjectBindingPattern */:
      return firstDefined(name.elements, (em) => isOmittedExpression(em) ? void 0 : forEachTopLevelDeclarationInBindingName(em.name, cb));
    default:
      return Debug.assertNever(name, `Unexpected name kind ${name.kind}`);
  }
}
function isNonVariableTopLevelDeclaration(node) {
  switch (node.kind) {
    case 262 /* FunctionDeclaration */:
    case 263 /* ClassDeclaration */:
    case 267 /* ModuleDeclaration */:
    case 266 /* EnumDeclaration */:
    case 265 /* TypeAliasDeclaration */:
    case 264 /* InterfaceDeclaration */:
    case 271 /* ImportEqualsDeclaration */:
      return true;
    default:
      return false;
  }
}
function moveStatementsToTargetFile(changes, program, statements, targetFile, toMove) {
  var _a;
  const removedExports = /* @__PURE__ */ new Set();
  const targetExports = (_a = targetFile.symbol) == null ? void 0 : _a.exports;
  if (targetExports) {
    const checker = program.getTypeChecker();
    const targetToSourceExports = /* @__PURE__ */ new Map();
    for (const node of toMove.all) {
      if (isTopLevelDeclarationStatement(node) && hasSyntacticModifier(node, 32 /* Export */)) {
        forEachTopLevelDeclaration(node, (declaration) => {
          var _a2;
          const targetDeclarations = canHaveSymbol(declaration) ? (_a2 = targetExports.get(declaration.symbol.escapedName)) == null ? void 0 : _a2.declarations : void 0;
          const exportDeclaration = firstDefined(targetDeclarations, (d) => isExportDeclaration(d) ? d : isExportSpecifier(d) ? tryCast(d.parent.parent, isExportDeclaration) : void 0);
          if (exportDeclaration && exportDeclaration.moduleSpecifier) {
            targetToSourceExports.set(exportDeclaration, (targetToSourceExports.get(exportDeclaration) || /* @__PURE__ */ new Set()).add(declaration));
          }
        });
      }
    }
    for (const [exportDeclaration, topLevelDeclarations] of arrayFrom(targetToSourceExports)) {
      if (exportDeclaration.exportClause && isNamedExports(exportDeclaration.exportClause) && length(exportDeclaration.exportClause.elements)) {
        const elements = exportDeclaration.exportClause.elements;
        const updatedElements = filter(elements, (elem) => find(skipAlias(elem.symbol, checker).declarations, (d) => isTopLevelDeclaration(d) && topLevelDeclarations.has(d)) === void 0);
        if (length(updatedElements) === 0) {
          changes.deleteNode(targetFile, exportDeclaration);
          removedExports.add(exportDeclaration);
          continue;
        }
        if (length(updatedElements) < length(elements)) {
          changes.replaceNode(targetFile, exportDeclaration, factory.updateExportDeclaration(exportDeclaration, exportDeclaration.modifiers, exportDeclaration.isTypeOnly, factory.updateNamedExports(exportDeclaration.exportClause, factory.createNodeArray(updatedElements, elements.hasTrailingComma)), exportDeclaration.moduleSpecifier, exportDeclaration.attributes));
        }
      }
    }
  }
  const lastReExport = findLast(targetFile.statements, (n) => isExportDeclaration(n) && !!n.moduleSpecifier && !removedExports.has(n));
  if (lastReExport) {
    changes.insertNodesBefore(
      targetFile,
      lastReExport,
      statements,
      /*blankLineBetween*/
      true
    );
  } else {
    changes.insertNodesAfter(targetFile, targetFile.statements[targetFile.statements.length - 1], statements);
  }
}
function getOverloadRangeToMove(sourceFile, statement) {
  if (isFunctionLikeDeclaration(statement)) {
    const declarations = statement.symbol.declarations;
    if (declarations === void 0 || length(declarations) <= 1 || !contains(declarations, statement)) {
      return void 0;
    }
    const firstDecl = declarations[0];
    const lastDecl = declarations[length(declarations) - 1];
    const statementsToMove = mapDefined(declarations, (d) => getSourceFileOfNode(d) === sourceFile && isStatement(d) ? d : void 0);
    const end = findIndex(sourceFile.statements, (s) => s.end >= lastDecl.end);
    const start = findIndex(sourceFile.statements, (s) => s.end >= firstDecl.end);
    return { toMove: statementsToMove, start, end };
  }
  return void 0;
}
function getExistingLocals(sourceFile, statements, checker) {
  const existingLocals = /* @__PURE__ */ new Set();
  for (const moduleSpecifier of sourceFile.imports) {
    const declaration = importFromModuleSpecifier(moduleSpecifier);
    if (isImportDeclaration(declaration) && declaration.importClause && declaration.importClause.namedBindings && isNamedImports(declaration.importClause.namedBindings)) {
      for (const e of declaration.importClause.namedBindings.elements) {
        const symbol = checker.getSymbolAtLocation(e.propertyName || e.name);
        if (symbol) {
          existingLocals.add(skipAlias(symbol, checker));
        }
      }
    }
    if (isVariableDeclarationInitializedToRequire(declaration.parent) && isObjectBindingPattern(declaration.parent.name)) {
      for (const e of declaration.parent.name.elements) {
        const symbol = checker.getSymbolAtLocation(e.propertyName || e.name);
        if (symbol) {
          existingLocals.add(skipAlias(symbol, checker));
        }
      }
    }
  }
  for (const statement of statements) {
    forEachReference(statement, checker, (s) => {
      const symbol = skipAlias(s, checker);
      if (symbol.valueDeclaration && getSourceFileOfNode(symbol.valueDeclaration).path === sourceFile.path) {
        existingLocals.add(symbol);
      }
    });
  }
  return existingLocals;
}

// src/services/refactors/helpers.ts
function isRefactorErrorInfo(info) {
  return info.error !== void 0;
}
function refactorKindBeginsWith(known, requested) {
  if (!requested) return true;
  return known.substr(0, requested.length) === requested;
}
function getIdentifierForNode(node, scope, checker, file) {
  return isPropertyAccessExpression(node) && !isClassLike(scope) && !checker.resolveName(
    node.name.text,
    node,
    111551 /* Value */,
    /*excludeGlobals*/
    false
  ) && !isPrivateIdentifier(node.name) && !identifierToKeywordKind(node.name) ? node.name.text : getUniqueName(isClassLike(scope) ? "newProperty" : "newLocal", file);
}
function addTargetFileImports(oldFile, importsToCopy, targetFileImportsFromOldFile, checker, program, importAdder) {
  importsToCopy.forEach(([isValidTypeOnlyUseSite, declaration], symbol) => {
    var _a;
    const targetSymbol = skipAlias(symbol, checker);
    if (checker.isUnknownSymbol(targetSymbol)) {
      importAdder.addVerbatimImport(Debug.checkDefined(declaration ?? findAncestor((_a = symbol.declarations) == null ? void 0 : _a[0], isAnyImportOrRequireStatement)));
    } else {
      importAdder.addImportFromExportedSymbol(targetSymbol, isValidTypeOnlyUseSite, declaration);
    }
  });
  addImportsForMovedSymbols(targetFileImportsFromOldFile, oldFile.fileName, importAdder, program);
}

// src/services/refactors/inlineVariable.ts
var refactorName4 = "Inline variable";
var refactorDescription = getLocaleSpecificMessage(Diagnostics.Inline_variable);
var inlineVariableAction = {
  name: refactorName4,
  description: refactorDescription,
  kind: "refactor.inline.variable"
};
registerRefactor(refactorName4, {
  kinds: [inlineVariableAction.kind],
  getAvailableActions(context) {
    const {
      file,
      program,
      preferences,
      startPosition,
      triggerReason
    } = context;
    const info = getInliningInfo(file, startPosition, triggerReason === "invoked", program);
    if (!info) {
      return emptyArray;
    }
    if (!ts_refactor_exports.isRefactorErrorInfo(info)) {
      return [{
        name: refactorName4,
        description: refactorDescription,
        actions: [inlineVariableAction]
      }];
    }
    if (preferences.provideRefactorNotApplicableReason) {
      return [{
        name: refactorName4,
        description: refactorDescription,
        actions: [{
          ...inlineVariableAction,
          notApplicableReason: info.error
        }]
      }];
    }
    return emptyArray;
  },
  getEditsForAction(context, actionName2) {
    Debug.assert(actionName2 === refactorName4, "Unexpected refactor invoked");
    const { file, program, startPosition } = context;
    const info = getInliningInfo(
      file,
      startPosition,
      /*tryWithReferenceToken*/
      true,
      program
    );
    if (!info || ts_refactor_exports.isRefactorErrorInfo(info)) {
      return void 0;
    }
    const { references, declaration, replacement } = info;
    const edits = ts_textChanges_exports.ChangeTracker.with(context, (tracker) => {
      for (const node of references) {
        tracker.replaceNode(file, node, getReplacementExpression(node, replacement));
      }
      tracker.delete(file, declaration);
    });
    return { edits };
  }
});
function getInliningInfo(file, startPosition, tryWithReferenceToken, program) {
  var _a, _b;
  const checker = program.getTypeChecker();
  const token = getTouchingPropertyName(file, startPosition);
  const parent2 = token.parent;
  if (!isIdentifier(token)) {
    return void 0;
  }
  if (isInitializedVariable(parent2) && isVariableDeclarationInVariableStatement(parent2) && isIdentifier(parent2.name)) {
    if (((_a = checker.getMergedSymbol(parent2.symbol).declarations) == null ? void 0 : _a.length) !== 1) {
      return { error: getLocaleSpecificMessage(Diagnostics.Variables_with_multiple_declarations_cannot_be_inlined) };
    }
    if (isDeclarationExported(parent2)) {
      return void 0;
    }
    const references = getReferenceNodes(parent2, checker, file);
    return references && { references, declaration: parent2, replacement: parent2.initializer };
  }
  if (tryWithReferenceToken) {
    let definition = checker.resolveName(
      token.text,
      token,
      111551 /* Value */,
      /*excludeGlobals*/
      false
    );
    definition = definition && checker.getMergedSymbol(definition);
    if (((_b = definition == null ? void 0 : definition.declarations) == null ? void 0 : _b.length) !== 1) {
      return { error: getLocaleSpecificMessage(Diagnostics.Variables_with_multiple_declarations_cannot_be_inlined) };
    }
    const declaration = definition.declarations[0];
    if (!isInitializedVariable(declaration) || !isVariableDeclarationInVariableStatement(declaration) || !isIdentifier(declaration.name)) {
      return void 0;
    }
    if (isDeclarationExported(declaration)) {
      return void 0;
    }
    const references = getReferenceNodes(declaration, checker, file);
    return references && { references, declaration, replacement: declaration.initializer };
  }
  return { error: getLocaleSpecificMessage(Diagnostics.Could_not_find_variable_to_inline) };
}
function isDeclarationExported(declaration) {
  const variableStatement = cast(declaration.parent.parent, isVariableStatement);
  return some(variableStatement.modifiers, isExportModifier);
}
function getReferenceNodes(declaration, checker, file) {
  const references = [];
  const cannotInline = ts_FindAllReferences_exports.Core.eachSymbolReferenceInFile(declaration.name, checker, file, (ref) => {
    if (ts_FindAllReferences_exports.isWriteAccessForReference(ref) && !isShorthandPropertyAssignment(ref.parent)) {
      return true;
    }
    if (isExportSpecifier(ref.parent) || isExportAssignment(ref.parent)) {
      return true;
    }
    if (isTypeQueryNode(ref.parent)) {
      return true;
    }
    if (textRangeContainsPositionInclusive(declaration, ref.pos)) {
      return true;
    }
    references.push(ref);
  });
  return references.length === 0 || cannotInline ? void 0 : references;
}
function getReplacementExpression(reference, replacement) {
  replacement = getSynthesizedDeepClone(replacement);
  const { parent: parent2 } = reference;
  if (isExpression(parent2) && (getExpressionPrecedence(replacement) < getExpressionPrecedence(parent2) || needsParentheses(parent2))) {
    return factory.createParenthesizedExpression(replacement);
  }
  if (isFunctionLike(replacement) && (isCallLikeExpression(parent2) || isPropertyAccessExpression(parent2))) {
    return factory.createParenthesizedExpression(replacement);
  }
  if (isPropertyAccessExpression(parent2) && (isNumericLiteral(replacement) || isObjectLiteralExpression(replacement))) {
    return factory.createParenthesizedExpression(replacement);
  }
  if (isIdentifier(reference) && isShorthandPropertyAssignment(parent2)) {
    return factory.createPropertyAssignment(reference, replacement);
  }
  return replacement;
}

// src/services/refactors/moveToNewFile.ts
var refactorName5 = "Move to a new file";
var description2 = getLocaleSpecificMessage(Diagnostics.Move_to_a_new_file);
var moveToNewFileAction = {
  name: refactorName5,
  description: description2,
  kind: "refactor.move.newFile"
};
registerRefactor(refactorName5, {
  kinds: [moveToNewFileAction.kind],
  getAvailableActions: function getRefactorActionsToMoveToNewFile(context) {
    const statements = getStatementsToMove(context);
    const file = context.file;
    if (context.triggerReason === "implicit" && context.endPosition !== void 0) {
      const startNodeAncestor = findAncestor(getTokenAtPosition(file, context.startPosition), isBlockLike);
      const endNodeAncestor = findAncestor(getTokenAtPosition(file, context.endPosition), isBlockLike);
      if (startNodeAncestor && !isSourceFile(startNodeAncestor) && endNodeAncestor && !isSourceFile(endNodeAncestor)) {
        return emptyArray;
      }
    }
    if (context.preferences.allowTextChangesInNewFiles && statements) {
      const file2 = context.file;
      const affectedTextRange = {
        start: { line: getLineAndCharacterOfPosition(file2, statements.all[0].getStart(file2)).line, offset: getLineAndCharacterOfPosition(file2, statements.all[0].getStart(file2)).character },
        end: { line: getLineAndCharacterOfPosition(file2, last(statements.all).end).line, offset: getLineAndCharacterOfPosition(file2, last(statements.all).end).character }
      };
      return [{ name: refactorName5, description: description2, actions: [{ ...moveToNewFileAction, range: affectedTextRange }] }];
    }
    if (context.preferences.provideRefactorNotApplicableReason) {
      return [{ name: refactorName5, description: description2, actions: [{ ...moveToNewFileAction, notApplicableReason: getLocaleSpecificMessage(Diagnostics.Selection_is_not_a_valid_statement_or_statements) }] }];
    }
    return emptyArray;
  },
  getEditsForAction: function getRefactorEditsToMoveToNewFile(context, actionName2) {
    Debug.assert(actionName2 === refactorName5, "Wrong refactor invoked");
    const statements = Debug.checkDefined(getStatementsToMove(context));
    const edits = ts_textChanges_exports.ChangeTracker.with(context, (t) => doChange4(context.file, context.program, statements, t, context.host, context, context.preferences));
    return { edits, renameFilename: void 0, renameLocation: void 0 };
  }
});
function doChange4(oldFile, program, toMove, changes, host, context, preferences) {
  const checker = program.getTypeChecker();
  const usage = getUsageInfo(oldFile, toMove.all, checker);
  const newFilename = createNewFileName(oldFile, program, host, toMove);
  const newSourceFile = createFutureSourceFile(newFilename, oldFile.externalModuleIndicator ? 99 /* ESNext */ : oldFile.commonJsModuleIndicator ? 1 /* CommonJS */ : void 0, program, host);
  const importAdderForOldFile = ts_codefix_exports.createImportAdder(oldFile, context.program, context.preferences, context.host);
  const importAdderForNewFile = ts_codefix_exports.createImportAdder(newSourceFile, context.program, context.preferences, context.host);
  getNewStatementsAndRemoveFromOldFile(oldFile, newSourceFile, usage, changes, toMove, program, host, preferences, importAdderForNewFile, importAdderForOldFile);
  addNewFileToTsconfig(program, changes, oldFile.fileName, newFilename, hostGetCanonicalFileName(host));
}

// src/services/_namespaces/ts.refactor.addOrRemoveBracesToArrowFunction.ts
var ts_refactor_addOrRemoveBracesToArrowFunction_exports = {};

// src/services/refactors/convertOverloadListToSingleSignature.ts
var refactorName6 = "Convert overload list to single signature";
var refactorDescription2 = getLocaleSpecificMessage(Diagnostics.Convert_overload_list_to_single_signature);
var functionOverloadAction = {
  name: refactorName6,
  description: refactorDescription2,
  kind: "refactor.rewrite.function.overloadList"
};
registerRefactor(refactorName6, {
  kinds: [functionOverloadAction.kind],
  getEditsForAction: getRefactorEditsToConvertOverloadsToOneSignature,
  getAvailableActions: getRefactorActionsToConvertOverloadsToOneSignature
});
function getRefactorActionsToConvertOverloadsToOneSignature(context) {
  const { file, startPosition, program } = context;
  const info = getConvertableOverloadListAtPosition(file, startPosition, program);
  if (!info) return emptyArray;
  return [{
    name: refactorName6,
    description: refactorDescription2,
    actions: [functionOverloadAction]
  }];
}
function getRefactorEditsToConvertOverloadsToOneSignature(context) {
  const { file, startPosition, program } = context;
  const signatureDecls = getConvertableOverloadListAtPosition(file, startPosition, program);
  if (!signatureDecls) return void 0;
  const checker = program.getTypeChecker();
  const lastDeclaration = signatureDecls[signatureDecls.length - 1];
  let updated = lastDeclaration;
  switch (lastDeclaration.kind) {
    case 173 /* MethodSignature */: {
      updated = factory.updateMethodSignature(
        lastDeclaration,
        lastDeclaration.modifiers,
        lastDeclaration.name,
        lastDeclaration.questionToken,
        lastDeclaration.typeParameters,
        getNewParametersForCombinedSignature(signatureDecls),
        lastDeclaration.type
      );
      break;
    }
    case 174 /* MethodDeclaration */: {
      updated = factory.updateMethodDeclaration(
        lastDeclaration,
        lastDeclaration.modifiers,
        lastDeclaration.asteriskToken,
        lastDeclaration.name,
        lastDeclaration.questionToken,
        lastDeclaration.typeParameters,
        getNewParametersForCombinedSignature(signatureDecls),
        lastDeclaration.type,
        lastDeclaration.body
      );
      break;
    }
    case 179 /* CallSignature */: {
      updated = factory.updateCallSignature(
        lastDeclaration,
        lastDeclaration.typeParameters,
        getNewParametersForCombinedSignature(signatureDecls),
        lastDeclaration.type
      );
      break;
    }
    case 176 /* Constructor */: {
      updated = factory.updateConstructorDeclaration(
        lastDeclaration,
        lastDeclaration.modifiers,
        getNewParametersForCombinedSignature(signatureDecls),
        lastDeclaration.body
      );
      break;
    }
    case 180 /* ConstructSignature */: {
      updated = factory.updateConstructSignature(
        lastDeclaration,
        lastDeclaration.typeParameters,
        getNewParametersForCombinedSignature(signatureDecls),
        lastDeclaration.type
      );
      break;
    }
    case 262 /* FunctionDeclaration */: {
      updated = factory.updateFunctionDeclaration(
        lastDeclaration,
        lastDeclaration.modifiers,
        lastDeclaration.asteriskToken,
        lastDeclaration.name,
        lastDeclaration.typeParameters,
        getNewParametersForCombinedSignature(signatureDecls),
        lastDeclaration.type,
        lastDeclaration.body
      );
      break;
    }
    default:
      return Debug.failBadSyntaxKind(lastDeclaration, "Unhandled signature kind in overload list conversion refactoring");
  }
  if (updated === lastDeclaration) {
    return;
  }
  const edits = ts_textChanges_exports.ChangeTracker.with(context, (t) => {
    t.replaceNodeRange(file, signatureDecls[0], signatureDecls[signatureDecls.length - 1], updated);
  });
  return { renameFilename: void 0, renameLocation: void 0, edits };
  function getNewParametersForCombinedSignature(signatureDeclarations) {
    const lastSig = signatureDeclarations[signatureDeclarations.length - 1];
    if (isFunctionLikeDeclaration(lastSig) && lastSig.body) {
      signatureDeclarations = signatureDeclarations.slice(0, signatureDeclarations.length - 1);
    }
    return factory.createNodeArray([
      factory.createParameterDeclaration(
        /*modifiers*/
        void 0,
        factory.createToken(26 /* DotDotDotToken */),
        "args",
        /*questionToken*/
        void 0,
        factory.createUnionTypeNode(map(signatureDeclarations, convertSignatureParametersToTuple))
      )
    ]);
  }
  function convertSignatureParametersToTuple(decl) {
    const members = map(decl.parameters, convertParameterToNamedTupleMember);
    return setEmitFlags(factory.createTupleTypeNode(members), some(members, (m) => !!length(getSyntheticLeadingComments(m))) ? 0 /* None */ : 1 /* SingleLine */);
  }
  function convertParameterToNamedTupleMember(p) {
    Debug.assert(isIdentifier(p.name));
    const result = setTextRange(
      factory.createNamedTupleMember(
        p.dotDotDotToken,
        p.name,
        p.questionToken,
        p.type || factory.createKeywordTypeNode(133 /* AnyKeyword */)
      ),
      p
    );
    const parameterDocComment = p.symbol && p.symbol.getDocumentationComment(checker);
    if (parameterDocComment) {
      const newComment = displayPartsToString(parameterDocComment);
      if (newComment.length) {
        setSyntheticLeadingComments(result, [{
          text: `*
${newComment.split("\n").map((c) => ` * ${c}`).join("\n")}
 `,
          kind: 3 /* MultiLineCommentTrivia */,
          pos: -1,
          end: -1,
          hasTrailingNewLine: true,
          hasLeadingNewline: true
        }]);
      }
    }
    return result;
  }
}
function isConvertableSignatureDeclaration(d) {
  switch (d.kind) {
    case 173 /* MethodSignature */:
    case 174 /* MethodDeclaration */:
    case 179 /* CallSignature */:
    case 176 /* Constructor */:
    case 180 /* ConstructSignature */:
    case 262 /* FunctionDeclaration */:
      return true;
  }
  return false;
}
function getConvertableOverloadListAtPosition(file, startPosition, program) {
  const node = getTokenAtPosition(file, startPosition);
  const containingDecl = findAncestor(node, isConvertableSignatureDeclaration);
  if (!containingDecl) {
    return;
  }
  if (isFunctionLikeDeclaration(containingDecl) && containingDecl.body && rangeContainsPosition(containingDecl.body, startPosition)) {
    return;
  }
  const checker = program.getTypeChecker();
  const signatureSymbol = containingDecl.symbol;
  if (!signatureSymbol) {
    return;
  }
  const decls = signatureSymbol.declarations;
  if (length(decls) <= 1) {
    return;
  }
  if (!every(decls, (d) => getSourceFileOfNode(d) === file)) {
    return;
  }
  if (!isConvertableSignatureDeclaration(decls[0])) {
    return;
  }
  const kindOne = decls[0].kind;
  if (!every(decls, (d) => d.kind === kindOne)) {
    return;
  }
  const signatureDecls = decls;
  if (some(signatureDecls, (d) => !!d.typeParameters || some(d.parameters, (p) => !!p.modifiers || !isIdentifier(p.name)))) {
    return;
  }
  const signatures = mapDefined(signatureDecls, (d) => checker.getSignatureFromDeclaration(d));
  if (length(signatures) !== length(decls)) {
    return;
  }
  const returnOne = checker.getReturnTypeOfSignature(signatures[0]);
  if (!every(signatures, (s) => checker.getReturnTypeOfSignature(s) === returnOne)) {
    return;
  }
  return signatureDecls;
}

// src/services/refactors/addOrRemoveBracesToArrowFunction.ts
var refactorName7 = "Add or remove braces in an arrow function";
var refactorDescription3 = getLocaleSpecificMessage(Diagnostics.Add_or_remove_braces_in_an_arrow_function);
var addBracesAction = {
  name: "Add braces to arrow function",
  description: getLocaleSpecificMessage(Diagnostics.Add_braces_to_arrow_function),
  kind: "refactor.rewrite.arrow.braces.add"
};
var removeBracesAction = {
  name: "Remove braces from arrow function",
  description: getLocaleSpecificMessage(Diagnostics.Remove_braces_from_arrow_function),
  kind: "refactor.rewrite.arrow.braces.remove"
};
registerRefactor(refactorName7, {
  kinds: [removeBracesAction.kind],
  getEditsForAction: getRefactorEditsToRemoveFunctionBraces,
  getAvailableActions: getRefactorActionsToRemoveFunctionBraces
});
function getRefactorActionsToRemoveFunctionBraces(context) {
  const { file, startPosition, triggerReason } = context;
  const info = getConvertibleArrowFunctionAtPosition(file, startPosition, triggerReason === "invoked");
  if (!info) return emptyArray;
  if (!isRefactorErrorInfo(info)) {
    return [{
      name: refactorName7,
      description: refactorDescription3,
      actions: [
        info.addBraces ? addBracesAction : removeBracesAction
      ]
    }];
  }
  if (context.preferences.provideRefactorNotApplicableReason) {
    return [{
      name: refactorName7,
      description: refactorDescription3,
      actions: [
        { ...addBracesAction, notApplicableReason: info.error },
        { ...removeBracesAction, notApplicableReason: info.error }
      ]
    }];
  }
  return emptyArray;
}
function getRefactorEditsToRemoveFunctionBraces(context, actionName2) {
  const { file, startPosition } = context;
  const info = getConvertibleArrowFunctionAtPosition(file, startPosition);
  Debug.assert(info && !isRefactorErrorInfo(info), "Expected applicable refactor info");
  const { expression, returnStatement, func } = info;
  let body;
  if (actionName2 === addBracesAction.name) {
    const returnStatement2 = factory.createReturnStatement(expression);
    body = factory.createBlock(
      [returnStatement2],
      /*multiLine*/
      true
    );
    copyLeadingComments(
      expression,
      returnStatement2,
      file,
      3 /* MultiLineCommentTrivia */,
      /*hasTrailingNewLine*/
      true
    );
  } else if (actionName2 === removeBracesAction.name && returnStatement) {
    const actualExpression = expression || factory.createVoidZero();
    body = needsParentheses(actualExpression) ? factory.createParenthesizedExpression(actualExpression) : actualExpression;
    copyTrailingAsLeadingComments(
      returnStatement,
      body,
      file,
      3 /* MultiLineCommentTrivia */,
      /*hasTrailingNewLine*/
      false
    );
    copyLeadingComments(
      returnStatement,
      body,
      file,
      3 /* MultiLineCommentTrivia */,
      /*hasTrailingNewLine*/
      false
    );
    copyTrailingComments(
      returnStatement,
      body,
      file,
      3 /* MultiLineCommentTrivia */,
      /*hasTrailingNewLine*/
      false
    );
  } else {
    Debug.fail("invalid action");
  }
  const edits = ts_textChanges_exports.ChangeTracker.with(context, (t) => {
    t.replaceNode(file, func.body, body);
  });
  return { renameFilename: void 0, renameLocation: void 0, edits };
}
function getConvertibleArrowFunctionAtPosition(file, startPosition, considerFunctionBodies = true, kind) {
  const node = getTokenAtPosition(file, startPosition);
  const func = getContainingFunction(node);
  if (!func) {
    return {
      error: getLocaleSpecificMessage(Diagnostics.Could_not_find_a_containing_arrow_function)
    };
  }
  if (!isArrowFunction(func)) {
    return {
      error: getLocaleSpecificMessage(Diagnostics.Containing_function_is_not_an_arrow_function)
    };
  }
  if (!rangeContainsRange(func, node) || rangeContainsRange(func.body, node) && !considerFunctionBodies) {
    return void 0;
  }
  if (refactorKindBeginsWith(addBracesAction.kind, kind) && isExpression(func.body)) {
    return { func, addBraces: true, expression: func.body };
  } else if (refactorKindBeginsWith(removeBracesAction.kind, kind) && isBlock(func.body) && func.body.statements.length === 1) {
    const firstStatement = first(func.body.statements);
    if (isReturnStatement(firstStatement)) {
      const expression = firstStatement.expression && isObjectLiteralExpression(getLeftmostExpression(
        firstStatement.expression,
        /*stopAtCallExpressions*/
        false
      )) ? factory.createParenthesizedExpression(firstStatement.expression) : firstStatement.expression;
      return { func, addBraces: false, expression, returnStatement: firstStatement };
    }
  }
  return void 0;
}

// src/services/_namespaces/ts.refactor.convertArrowFunctionOrFunctionExpression.ts
var ts_refactor_convertArrowFunctionOrFunctionExpression_exports = {};

// src/services/refactors/convertArrowFunctionOrFunctionExpression.ts
var refactorName8 = "Convert arrow function or function expression";
var refactorDescription4 = getLocaleSpecificMessage(Diagnostics.Convert_arrow_function_or_function_expression);
var toAnonymousFunctionAction = {
  name: "Convert to anonymous function",
  description: getLocaleSpecificMessage(Diagnostics.Convert_to_anonymous_function),
  kind: "refactor.rewrite.function.anonymous"
};
var toNamedFunctionAction = {
  name: "Convert to named function",
  description: getLocaleSpecificMessage(Diagnostics.Convert_to_named_function),
  kind: "refactor.rewrite.function.named"
};
var toArrowFunctionAction = {
  name: "Convert to arrow function",
  description: getLocaleSpecificMessage(Diagnostics.Convert_to_arrow_function),
  kind: "refactor.rewrite.function.arrow"
};
registerRefactor(refactorName8, {
  kinds: [
    toAnonymousFunctionAction.kind,
    toNamedFunctionAction.kind,
    toArrowFunctionAction.kind
  ],
  getEditsForAction: getRefactorEditsToConvertFunctionExpressions,
  getAvailableActions: getRefactorActionsToConvertFunctionExpressions
});
function getRefactorActionsToConvertFunctionExpressions(context) {
  const { file, startPosition, program, kind } = context;
  const info = getFunctionInfo(file, startPosition, program);
  if (!info) return emptyArray;
  const { selectedVariableDeclaration, func } = info;
  const possibleActions = [];
  const errors = [];
  if (refactorKindBeginsWith(toNamedFunctionAction.kind, kind)) {
    const error2 = selectedVariableDeclaration || isArrowFunction(func) && isVariableDeclaration(func.parent) ? void 0 : getLocaleSpecificMessage(Diagnostics.Could_not_convert_to_named_function);
    if (error2) {
      errors.push({ ...toNamedFunctionAction, notApplicableReason: error2 });
    } else {
      possibleActions.push(toNamedFunctionAction);
    }
  }
  if (refactorKindBeginsWith(toAnonymousFunctionAction.kind, kind)) {
    const error2 = !selectedVariableDeclaration && isArrowFunction(func) ? void 0 : getLocaleSpecificMessage(Diagnostics.Could_not_convert_to_anonymous_function);
    if (error2) {
      errors.push({ ...toAnonymousFunctionAction, notApplicableReason: error2 });
    } else {
      possibleActions.push(toAnonymousFunctionAction);
    }
  }
  if (refactorKindBeginsWith(toArrowFunctionAction.kind, kind)) {
    const error2 = isFunctionExpression(func) ? void 0 : getLocaleSpecificMessage(Diagnostics.Could_not_convert_to_arrow_function);
    if (error2) {
      errors.push({ ...toArrowFunctionAction, notApplicableReason: error2 });
    } else {
      possibleActions.push(toArrowFunctionAction);
    }
  }
  return [{
    name: refactorName8,
    description: refactorDescription4,
    actions: possibleActions.length === 0 && context.preferences.provideRefactorNotApplicableReason ? errors : possibleActions
  }];
}
function getRefactorEditsToConvertFunctionExpressions(context, actionName2) {
  const { file, startPosition, program } = context;
  const info = getFunctionInfo(file, startPosition, program);
  if (!info) return void 0;
  const { func } = info;
  const edits = [];
  switch (actionName2) {
    case toAnonymousFunctionAction.name:
      edits.push(...getEditInfoForConvertToAnonymousFunction(context, func));
      break;
    case toNamedFunctionAction.name:
      const variableInfo = getVariableInfo(func);
      if (!variableInfo) return void 0;
      edits.push(...getEditInfoForConvertToNamedFunction(context, func, variableInfo));
      break;
    case toArrowFunctionAction.name:
      if (!isFunctionExpression(func)) return void 0;
      edits.push(...getEditInfoForConvertToArrowFunction(context, func));
      break;
    default:
      return Debug.fail("invalid action");
  }
  return { renameFilename: void 0, renameLocation: void 0, edits };
}
function containingThis(node) {
  let containsThis = false;
  node.forEachChild(function checkThis(child) {
    if (isThis(child)) {
      containsThis = true;
      return;
    }
    if (!isClassLike(child) && !isFunctionDeclaration(child) && !isFunctionExpression(child)) {
      forEachChild(child, checkThis);
    }
  });
  return containsThis;
}
function getFunctionInfo(file, startPosition, program) {
  const token = getTokenAtPosition(file, startPosition);
  const typeChecker = program.getTypeChecker();
  const func = tryGetFunctionFromVariableDeclaration(file, typeChecker, token.parent);
  if (func && !containingThis(func.body) && !typeChecker.containsArgumentsReference(func)) {
    return { selectedVariableDeclaration: true, func };
  }
  const maybeFunc = getContainingFunction(token);
  if (maybeFunc && (isFunctionExpression(maybeFunc) || isArrowFunction(maybeFunc)) && !rangeContainsRange(maybeFunc.body, token) && !containingThis(maybeFunc.body) && !typeChecker.containsArgumentsReference(maybeFunc)) {
    if (isFunctionExpression(maybeFunc) && isFunctionReferencedInFile(file, typeChecker, maybeFunc)) return void 0;
    return { selectedVariableDeclaration: false, func: maybeFunc };
  }
  return void 0;
}
function isSingleVariableDeclaration(parent2) {
  return isVariableDeclaration(parent2) || isVariableDeclarationList(parent2) && parent2.declarations.length === 1;
}
function tryGetFunctionFromVariableDeclaration(sourceFile, typeChecker, parent2) {
  if (!isSingleVariableDeclaration(parent2)) {
    return void 0;
  }
  const variableDeclaration = isVariableDeclaration(parent2) ? parent2 : first(parent2.declarations);
  const initializer = variableDeclaration.initializer;
  if (initializer && (isArrowFunction(initializer) || isFunctionExpression(initializer) && !isFunctionReferencedInFile(sourceFile, typeChecker, initializer))) {
    return initializer;
  }
  return void 0;
}
function convertToBlock(body) {
  if (isExpression(body)) {
    const returnStatement = factory.createReturnStatement(body);
    const file = body.getSourceFile();
    setTextRange(returnStatement, body);
    suppressLeadingAndTrailingTrivia(returnStatement);
    copyTrailingAsLeadingComments(
      body,
      returnStatement,
      file,
      /*commentKind*/
      void 0,
      /*hasTrailingNewLine*/
      true
    );
    return factory.createBlock(
      [returnStatement],
      /*multiLine*/
      true
    );
  } else {
    return body;
  }
}
function getVariableInfo(func) {
  const variableDeclaration = func.parent;
  if (!isVariableDeclaration(variableDeclaration) || !isVariableDeclarationInVariableStatement(variableDeclaration)) return void 0;
  const variableDeclarationList = variableDeclaration.parent;
  const statement = variableDeclarationList.parent;
  if (!isVariableDeclarationList(variableDeclarationList) || !isVariableStatement(statement) || !isIdentifier(variableDeclaration.name)) return void 0;
  return { variableDeclaration, variableDeclarationList, statement, name: variableDeclaration.name };
}
function getEditInfoForConvertToAnonymousFunction(context, func) {
  const { file } = context;
  const body = convertToBlock(func.body);
  const newNode = factory.createFunctionExpression(
    func.modifiers,
    func.asteriskToken,
    /*name*/
    void 0,
    func.typeParameters,
    func.parameters,
    func.type,
    body
  );
  return ts_textChanges_exports.ChangeTracker.with(context, (t) => t.replaceNode(file, func, newNode));
}
function getEditInfoForConvertToNamedFunction(context, func, variableInfo) {
  const { file } = context;
  const body = convertToBlock(func.body);
  const { variableDeclaration, variableDeclarationList, statement, name } = variableInfo;
  suppressLeadingTrivia(statement);
  const modifiersFlags = getCombinedModifierFlags(variableDeclaration) & 32 /* Export */ | getEffectiveModifierFlags(func);
  const modifiers = factory.createModifiersFromModifierFlags(modifiersFlags);
  const newNode = factory.createFunctionDeclaration(length(modifiers) ? modifiers : void 0, func.asteriskToken, name, func.typeParameters, func.parameters, func.type, body);
  if (variableDeclarationList.declarations.length === 1) {
    return ts_textChanges_exports.ChangeTracker.with(context, (t) => t.replaceNode(file, statement, newNode));
  } else {
    return ts_textChanges_exports.ChangeTracker.with(context, (t) => {
      t.delete(file, variableDeclaration);
      t.insertNodeAfter(file, statement, newNode);
    });
  }
}
function getEditInfoForConvertToArrowFunction(context, func) {
  const { file } = context;
  const statements = func.body.statements;
  const head = statements[0];
  let body;
  if (canBeConvertedToExpression(func.body, head)) {
    body = head.expression;
    suppressLeadingAndTrailingTrivia(body);
    copyComments(head, body);
  } else {
    body = func.body;
  }
  const newNode = factory.createArrowFunction(func.modifiers, func.typeParameters, func.parameters, func.type, factory.createToken(39 /* EqualsGreaterThanToken */), body);
  return ts_textChanges_exports.ChangeTracker.with(context, (t) => t.replaceNode(file, func, newNode));
}
function canBeConvertedToExpression(body, head) {
  return body.statements.length === 1 && (isReturnStatement(head) && !!head.expression);
}
function isFunctionReferencedInFile(sourceFile, typeChecker, node) {
  return !!node.name && ts_FindAllReferences_exports.Core.isSymbolReferencedInFile(node.name, typeChecker, sourceFile);
}

// src/services/_namespaces/ts.refactor.convertParamsToDestructuredObject.ts
var ts_refactor_convertParamsToDestructuredObject_exports = {};

// src/services/refactors/convertParamsToDestructuredObject.ts
var refactorName9 = "Convert parameters to destructured object";
var minimumParameterLength = 1;
var refactorDescription5 = getLocaleSpecificMessage(Diagnostics.Convert_parameters_to_destructured_object);
var toDestructuredAction = {
  name: refactorName9,
  description: refactorDescription5,
  kind: "refactor.rewrite.parameters.toDestructured"
};
registerRefactor(refactorName9, {
  kinds: [toDestructuredAction.kind],
  getEditsForAction: getRefactorEditsToConvertParametersToDestructuredObject,
  getAvailableActions: getRefactorActionsToConvertParametersToDestructuredObject
});
function getRefactorActionsToConvertParametersToDestructuredObject(context) {
  const { file, startPosition } = context;
  const isJSFile = isSourceFileJS(file);
  if (isJSFile) return emptyArray;
  const functionDeclaration = getFunctionDeclarationAtPosition(file, startPosition, context.program.getTypeChecker());
  if (!functionDeclaration) return emptyArray;
  return [{
    name: refactorName9,
    description: refactorDescription5,
    actions: [toDestructuredAction]
  }];
}
function getRefactorEditsToConvertParametersToDestructuredObject(context, actionName2) {
  Debug.assert(actionName2 === refactorName9, "Unexpected action name");
  const { file, startPosition, program, cancellationToken, host } = context;
  const functionDeclaration = getFunctionDeclarationAtPosition(file, startPosition, program.getTypeChecker());
  if (!functionDeclaration || !cancellationToken) return void 0;
  const groupedReferences = getGroupedReferences(functionDeclaration, program, cancellationToken);
  if (groupedReferences.valid) {
    const edits = ts_textChanges_exports.ChangeTracker.with(context, (t) => doChange5(file, program, host, t, functionDeclaration, groupedReferences));
    return { renameFilename: void 0, renameLocation: void 0, edits };
  }
  return { edits: [] };
}
function doChange5(sourceFile, program, host, changes, functionDeclaration, groupedReferences) {
  const signature = groupedReferences.signature;
  const newFunctionDeclarationParams = map(createNewParameters(functionDeclaration, program, host), (param) => getSynthesizedDeepClone(param));
  if (signature) {
    const newSignatureParams = map(createNewParameters(signature, program, host), (param) => getSynthesizedDeepClone(param));
    replaceParameters(signature, newSignatureParams);
  }
  replaceParameters(functionDeclaration, newFunctionDeclarationParams);
  const functionCalls = sortAndDeduplicate(
    groupedReferences.functionCalls,
    /*comparer*/
    (a, b) => compareValues(a.pos, b.pos)
  );
  for (const call of functionCalls) {
    if (call.arguments && call.arguments.length) {
      const newArgument = getSynthesizedDeepClone(
        createNewArgument(functionDeclaration, call.arguments),
        /*includeTrivia*/
        true
      );
      changes.replaceNodeRange(
        getSourceFileOfNode(call),
        first(call.arguments),
        last(call.arguments),
        newArgument,
        { leadingTriviaOption: ts_textChanges_exports.LeadingTriviaOption.IncludeAll, trailingTriviaOption: ts_textChanges_exports.TrailingTriviaOption.Include }
      );
    }
  }
  function replaceParameters(declarationOrSignature, parameterDeclarations) {
    changes.replaceNodeRangeWithNodes(
      sourceFile,
      first(declarationOrSignature.parameters),
      last(declarationOrSignature.parameters),
      parameterDeclarations,
      {
        joiner: ", ",
        // indentation is set to 0 because otherwise the object parameter will be indented if there is a `this` parameter
        indentation: 0,
        leadingTriviaOption: ts_textChanges_exports.LeadingTriviaOption.IncludeAll,
        trailingTriviaOption: ts_textChanges_exports.TrailingTriviaOption.Include
      }
    );
  }
}
function getGroupedReferences(functionDeclaration, program, cancellationToken) {
  const functionNames = getFunctionNames(functionDeclaration);
  const classNames = isConstructorDeclaration(functionDeclaration) ? getClassNames(functionDeclaration) : [];
  const names = deduplicate([...functionNames, ...classNames], equateValues);
  const checker = program.getTypeChecker();
  const references = flatMap(
    names,
    /*mapfn*/
    (name) => ts_FindAllReferences_exports.getReferenceEntriesForNode(-1, name, program, program.getSourceFiles(), cancellationToken)
  );
  const groupedReferences = groupReferences(references);
  if (!every(
    groupedReferences.declarations,
    /*callback*/
    (decl) => contains(names, decl)
  )) {
    groupedReferences.valid = false;
  }
  return groupedReferences;
  function groupReferences(referenceEntries) {
    const classReferences = { accessExpressions: [], typeUsages: [] };
    const groupedReferences2 = { functionCalls: [], declarations: [], classReferences, valid: true };
    const functionSymbols = map(functionNames, getSymbolTargetAtLocation);
    const classSymbols = map(classNames, getSymbolTargetAtLocation);
    const isConstructor = isConstructorDeclaration(functionDeclaration);
    const contextualSymbols = map(functionNames, (name) => getSymbolForContextualType(name, checker));
    for (const entry of referenceEntries) {
      if (entry.kind === ts_FindAllReferences_exports.EntryKind.Span) {
        groupedReferences2.valid = false;
        continue;
      }
      if (contains(contextualSymbols, getSymbolTargetAtLocation(entry.node))) {
        if (isValidMethodSignature(entry.node.parent)) {
          groupedReferences2.signature = entry.node.parent;
          continue;
        }
        const call = entryToFunctionCall(entry);
        if (call) {
          groupedReferences2.functionCalls.push(call);
          continue;
        }
      }
      const contextualSymbol = getSymbolForContextualType(entry.node, checker);
      if (contextualSymbol && contains(contextualSymbols, contextualSymbol)) {
        const decl = entryToDeclaration(entry);
        if (decl) {
          groupedReferences2.declarations.push(decl);
          continue;
        }
      }
      if (contains(functionSymbols, getSymbolTargetAtLocation(entry.node)) || isNewExpressionTarget(entry.node)) {
        const importOrExportReference = entryToImportOrExport(entry);
        if (importOrExportReference) {
          continue;
        }
        const decl = entryToDeclaration(entry);
        if (decl) {
          groupedReferences2.declarations.push(decl);
          continue;
        }
        const call = entryToFunctionCall(entry);
        if (call) {
          groupedReferences2.functionCalls.push(call);
          continue;
        }
      }
      if (isConstructor && contains(classSymbols, getSymbolTargetAtLocation(entry.node))) {
        const importOrExportReference = entryToImportOrExport(entry);
        if (importOrExportReference) {
          continue;
        }
        const decl = entryToDeclaration(entry);
        if (decl) {
          groupedReferences2.declarations.push(decl);
          continue;
        }
        const accessExpression = entryToAccessExpression(entry);
        if (accessExpression) {
          classReferences.accessExpressions.push(accessExpression);
          continue;
        }
        if (isClassDeclaration(functionDeclaration.parent)) {
          const type = entryToType(entry);
          if (type) {
            classReferences.typeUsages.push(type);
            continue;
          }
        }
      }
      groupedReferences2.valid = false;
    }
    return groupedReferences2;
  }
  function getSymbolTargetAtLocation(node) {
    const symbol = checker.getSymbolAtLocation(node);
    return symbol && getSymbolTarget(symbol, checker);
  }
}
function getSymbolForContextualType(node, checker) {
  const element = getContainingObjectLiteralElement(node);
  if (element) {
    const contextualType = checker.getContextualTypeForObjectLiteralElement(element);
    const symbol = contextualType == null ? void 0 : contextualType.getSymbol();
    if (symbol && !(getCheckFlags(symbol) & 6 /* Synthetic */)) {
      return symbol;
    }
  }
}
function entryToImportOrExport(entry) {
  const node = entry.node;
  if (isImportSpecifier(node.parent) || isImportClause(node.parent) || isImportEqualsDeclaration(node.parent) || isNamespaceImport(node.parent)) {
    return node;
  }
  if (isExportSpecifier(node.parent) || isExportAssignment(node.parent)) {
    return node;
  }
  return void 0;
}
function entryToDeclaration(entry) {
  if (isDeclaration(entry.node.parent)) {
    return entry.node;
  }
  return void 0;
}
function entryToFunctionCall(entry) {
  if (entry.node.parent) {
    const functionReference = entry.node;
    const parent2 = functionReference.parent;
    switch (parent2.kind) {
      case 213 /* CallExpression */:
      case 214 /* NewExpression */:
        const callOrNewExpression = tryCast(parent2, isCallOrNewExpression);
        if (callOrNewExpression && callOrNewExpression.expression === functionReference) {
          return callOrNewExpression;
        }
        break;
      case 211 /* PropertyAccessExpression */:
        const propertyAccessExpression = tryCast(parent2, isPropertyAccessExpression);
        if (propertyAccessExpression && propertyAccessExpression.parent && propertyAccessExpression.name === functionReference) {
          const callOrNewExpression2 = tryCast(propertyAccessExpression.parent, isCallOrNewExpression);
          if (callOrNewExpression2 && callOrNewExpression2.expression === propertyAccessExpression) {
            return callOrNewExpression2;
          }
        }
        break;
      case 212 /* ElementAccessExpression */:
        const elementAccessExpression = tryCast(parent2, isElementAccessExpression);
        if (elementAccessExpression && elementAccessExpression.parent && elementAccessExpression.argumentExpression === functionReference) {
          const callOrNewExpression2 = tryCast(elementAccessExpression.parent, isCallOrNewExpression);
          if (callOrNewExpression2 && callOrNewExpression2.expression === elementAccessExpression) {
            return callOrNewExpression2;
          }
        }
        break;
    }
  }
  return void 0;
}
function entryToAccessExpression(entry) {
  if (entry.node.parent) {
    const reference = entry.node;
    const parent2 = reference.parent;
    switch (parent2.kind) {
      case 211 /* PropertyAccessExpression */:
        const propertyAccessExpression = tryCast(parent2, isPropertyAccessExpression);
        if (propertyAccessExpression && propertyAccessExpression.expression === reference) {
          return propertyAccessExpression;
        }
        break;
      case 212 /* ElementAccessExpression */:
        const elementAccessExpression = tryCast(parent2, isElementAccessExpression);
        if (elementAccessExpression && elementAccessExpression.expression === reference) {
          return elementAccessExpression;
        }
        break;
    }
  }
  return void 0;
}
function entryToType(entry) {
  const reference = entry.node;
  if (getMeaningFromLocation(reference) === 2 /* Type */ || isExpressionWithTypeArgumentsInClassExtendsClause(reference.parent)) {
    return reference;
  }
  return void 0;
}
function getFunctionDeclarationAtPosition(file, startPosition, checker) {
  const node = getTouchingToken(file, startPosition);
  const functionDeclaration = getContainingFunctionDeclaration(node);
  if (isTopLevelJSDoc(node)) return void 0;
  if (functionDeclaration && isValidFunctionDeclaration(functionDeclaration, checker) && rangeContainsRange(functionDeclaration, node) && !(functionDeclaration.body && rangeContainsRange(functionDeclaration.body, node))) return functionDeclaration;
  return void 0;
}
function isTopLevelJSDoc(node) {
  const containingJSDoc = findAncestor(node, isJSDocNode);
  if (containingJSDoc) {
    const containingNonJSDoc = findAncestor(containingJSDoc, (n) => !isJSDocNode(n));
    return !!containingNonJSDoc && isFunctionLikeDeclaration(containingNonJSDoc);
  }
  return false;
}
function isValidMethodSignature(node) {
  return isMethodSignature(node) && (isInterfaceDeclaration(node.parent) || isTypeLiteralNode(node.parent));
}
function isValidFunctionDeclaration(functionDeclaration, checker) {
  var _a;
  if (!isValidParameterNodeArray(functionDeclaration.parameters, checker)) return false;
  switch (functionDeclaration.kind) {
    case 262 /* FunctionDeclaration */:
      return hasNameOrDefault(functionDeclaration) && isSingleImplementation(functionDeclaration, checker);
    case 174 /* MethodDeclaration */:
      if (isObjectLiteralExpression(functionDeclaration.parent)) {
        const contextualSymbol = getSymbolForContextualType(functionDeclaration.name, checker);
        return ((_a = contextualSymbol == null ? void 0 : contextualSymbol.declarations) == null ? void 0 : _a.length) === 1 && isSingleImplementation(functionDeclaration, checker);
      }
      return isSingleImplementation(functionDeclaration, checker);
    case 176 /* Constructor */:
      if (isClassDeclaration(functionDeclaration.parent)) {
        return hasNameOrDefault(functionDeclaration.parent) && isSingleImplementation(functionDeclaration, checker);
      } else {
        return isValidVariableDeclaration(functionDeclaration.parent.parent) && isSingleImplementation(functionDeclaration, checker);
      }
    case 218 /* FunctionExpression */:
    case 219 /* ArrowFunction */:
      return isValidVariableDeclaration(functionDeclaration.parent);
  }
  return false;
}
function isSingleImplementation(functionDeclaration, checker) {
  return !!functionDeclaration.body && !checker.isImplementationOfOverload(functionDeclaration);
}
function hasNameOrDefault(functionOrClassDeclaration) {
  if (!functionOrClassDeclaration.name) {
    const defaultKeyword = findModifier(functionOrClassDeclaration, 90 /* DefaultKeyword */);
    return !!defaultKeyword;
  }
  return true;
}
function isValidParameterNodeArray(parameters, checker) {
  return getRefactorableParametersLength(parameters) >= minimumParameterLength && every(
    parameters,
    /*callback*/
    (paramDecl) => isValidParameterDeclaration(paramDecl, checker)
  );
}
function isValidParameterDeclaration(parameterDeclaration, checker) {
  if (isRestParameter(parameterDeclaration)) {
    const type = checker.getTypeAtLocation(parameterDeclaration);
    if (!checker.isArrayType(type) && !checker.isTupleType(type)) return false;
  }
  return !parameterDeclaration.modifiers && isIdentifier(parameterDeclaration.name);
}
function isValidVariableDeclaration(node) {
  return isVariableDeclaration(node) && isVarConst(node) && isIdentifier(node.name) && !node.type;
}
function hasThisParameter(parameters) {
  return parameters.length > 0 && isThis(parameters[0].name);
}
function getRefactorableParametersLength(parameters) {
  if (hasThisParameter(parameters)) {
    return parameters.length - 1;
  }
  return parameters.length;
}
function getRefactorableParameters(parameters) {
  if (hasThisParameter(parameters)) {
    parameters = factory.createNodeArray(parameters.slice(1), parameters.hasTrailingComma);
  }
  return parameters;
}
function createPropertyOrShorthandAssignment(name, initializer) {
  if (isIdentifier(initializer) && getTextOfIdentifierOrLiteral(initializer) === name) {
    return factory.createShorthandPropertyAssignment(name);
  }
  return factory.createPropertyAssignment(name, initializer);
}
function createNewArgument(functionDeclaration, functionArguments) {
  const parameters = getRefactorableParameters(functionDeclaration.parameters);
  const hasRestParameter2 = isRestParameter(last(parameters));
  const nonRestArguments = hasRestParameter2 ? functionArguments.slice(0, parameters.length - 1) : functionArguments;
  const properties = map(nonRestArguments, (arg, i) => {
    const parameterName = getParameterName(parameters[i]);
    const property = createPropertyOrShorthandAssignment(parameterName, arg);
    suppressLeadingAndTrailingTrivia(property.name);
    if (isPropertyAssignment(property)) suppressLeadingAndTrailingTrivia(property.initializer);
    copyComments(arg, property);
    return property;
  });
  if (hasRestParameter2 && functionArguments.length >= parameters.length) {
    const restArguments = functionArguments.slice(parameters.length - 1);
    const restProperty = factory.createPropertyAssignment(getParameterName(last(parameters)), factory.createArrayLiteralExpression(restArguments));
    properties.push(restProperty);
  }
  const objectLiteral = factory.createObjectLiteralExpression(
    properties,
    /*multiLine*/
    false
  );
  return objectLiteral;
}
function createNewParameters(functionDeclaration, program, host) {
  const checker = program.getTypeChecker();
  const refactorableParameters = getRefactorableParameters(functionDeclaration.parameters);
  const bindingElements = map(refactorableParameters, createBindingElementFromParameterDeclaration);
  const objectParameterName = factory.createObjectBindingPattern(bindingElements);
  const objectParameterType = createParameterTypeNode(refactorableParameters);
  let objectInitializer;
  if (every(refactorableParameters, isOptionalParameter)) {
    objectInitializer = factory.createObjectLiteralExpression();
  }
  const objectParameter = factory.createParameterDeclaration(
    /*modifiers*/
    void 0,
    /*dotDotDotToken*/
    void 0,
    objectParameterName,
    /*questionToken*/
    void 0,
    objectParameterType,
    objectInitializer
  );
  if (hasThisParameter(functionDeclaration.parameters)) {
    const thisParameter = functionDeclaration.parameters[0];
    const newThisParameter = factory.createParameterDeclaration(
      /*modifiers*/
      void 0,
      /*dotDotDotToken*/
      void 0,
      thisParameter.name,
      /*questionToken*/
      void 0,
      thisParameter.type
    );
    suppressLeadingAndTrailingTrivia(newThisParameter.name);
    copyComments(thisParameter.name, newThisParameter.name);
    if (thisParameter.type) {
      suppressLeadingAndTrailingTrivia(newThisParameter.type);
      copyComments(thisParameter.type, newThisParameter.type);
    }
    return factory.createNodeArray([newThisParameter, objectParameter]);
  }
  return factory.createNodeArray([objectParameter]);
  function createBindingElementFromParameterDeclaration(parameterDeclaration) {
    const element = factory.createBindingElement(
      /*dotDotDotToken*/
      void 0,
      /*propertyName*/
      void 0,
      getParameterName(parameterDeclaration),
      isRestParameter(parameterDeclaration) && isOptionalParameter(parameterDeclaration) ? factory.createArrayLiteralExpression() : parameterDeclaration.initializer
    );
    suppressLeadingAndTrailingTrivia(element);
    if (parameterDeclaration.initializer && element.initializer) {
      copyComments(parameterDeclaration.initializer, element.initializer);
    }
    return element;
  }
  function createParameterTypeNode(parameters) {
    const members = map(parameters, createPropertySignatureFromParameterDeclaration);
    const typeNode = addEmitFlags(factory.createTypeLiteralNode(members), 1 /* SingleLine */);
    return typeNode;
  }
  function createPropertySignatureFromParameterDeclaration(parameterDeclaration) {
    let parameterType = parameterDeclaration.type;
    if (!parameterType && (parameterDeclaration.initializer || isRestParameter(parameterDeclaration))) {
      parameterType = getTypeNode3(parameterDeclaration);
    }
    const propertySignature = factory.createPropertySignature(
      /*modifiers*/
      void 0,
      getParameterName(parameterDeclaration),
      isOptionalParameter(parameterDeclaration) ? factory.createToken(58 /* QuestionToken */) : parameterDeclaration.questionToken,
      parameterType
    );
    suppressLeadingAndTrailingTrivia(propertySignature);
    copyComments(parameterDeclaration.name, propertySignature.name);
    if (parameterDeclaration.type && propertySignature.type) {
      copyComments(parameterDeclaration.type, propertySignature.type);
    }
    return propertySignature;
  }
  function getTypeNode3(node) {
    const type = checker.getTypeAtLocation(node);
    return getTypeNodeIfAccessible(type, node, program, host);
  }
  function isOptionalParameter(parameterDeclaration) {
    if (isRestParameter(parameterDeclaration)) {
      const type = checker.getTypeAtLocation(parameterDeclaration);
      return !checker.isTupleType(type);
    }
    return checker.isOptionalParameter(parameterDeclaration);
  }
}
function getParameterName(paramDeclaration) {
  return getTextOfIdentifierOrLiteral(paramDeclaration.name);
}
function getClassNames(constructorDeclaration) {
  switch (constructorDeclaration.parent.kind) {
    case 263 /* ClassDeclaration */:
      const classDeclaration = constructorDeclaration.parent;
      if (classDeclaration.name) return [classDeclaration.name];
      const defaultModifier = Debug.checkDefined(
        findModifier(classDeclaration, 90 /* DefaultKeyword */),
        "Nameless class declaration should be a default export"
      );
      return [defaultModifier];
    case 231 /* ClassExpression */:
      const classExpression = constructorDeclaration.parent;
      const variableDeclaration = constructorDeclaration.parent.parent;
      const className = classExpression.name;
      if (className) return [className, variableDeclaration.name];
      return [variableDeclaration.name];
  }
}
function getFunctionNames(functionDeclaration) {
  switch (functionDeclaration.kind) {
    case 262 /* FunctionDeclaration */:
      if (functionDeclaration.name) return [functionDeclaration.name];
      const defaultModifier = Debug.checkDefined(
        findModifier(functionDeclaration, 90 /* DefaultKeyword */),
        "Nameless function declaration should be a default export"
      );
      return [defaultModifier];
    case 174 /* MethodDeclaration */:
      return [functionDeclaration.name];
    case 176 /* Constructor */:
      const ctrKeyword = Debug.checkDefined(
        findChildOfKind(functionDeclaration, 137 /* ConstructorKeyword */, functionDeclaration.getSourceFile()),
        "Constructor declaration should have constructor keyword"
      );
      if (functionDeclaration.parent.kind === 231 /* ClassExpression */) {
        const variableDeclaration = functionDeclaration.parent.parent;
        return [variableDeclaration.name, ctrKeyword];
      }
      return [ctrKeyword];
    case 219 /* ArrowFunction */:
      return [functionDeclaration.parent.name];
    case 218 /* FunctionExpression */:
      if (functionDeclaration.name) return [functionDeclaration.name, functionDeclaration.parent.name];
      return [functionDeclaration.parent.name];
    default:
      return Debug.assertNever(functionDeclaration, `Unexpected function declaration kind ${functionDeclaration.kind}`);
  }
}

// src/services/_namespaces/ts.refactor.convertStringOrTemplateLiteral.ts
var ts_refactor_convertStringOrTemplateLiteral_exports = {};

// src/services/refactors/convertStringOrTemplateLiteral.ts
var refactorName10 = "Convert to template string";
var refactorDescription6 = getLocaleSpecificMessage(Diagnostics.Convert_to_template_string);
var convertStringAction = {
  name: refactorName10,
  description: refactorDescription6,
  kind: "refactor.rewrite.string"
};
registerRefactor(refactorName10, {
  kinds: [convertStringAction.kind],
  getEditsForAction: getRefactorEditsToConvertToTemplateString,
  getAvailableActions: getRefactorActionsToConvertToTemplateString
});
function getRefactorActionsToConvertToTemplateString(context) {
  const { file, startPosition } = context;
  const node = getNodeOrParentOfParentheses(file, startPosition);
  const maybeBinary = getParentBinaryExpression(node);
  const nodeIsStringLiteral = isStringLiteral(maybeBinary);
  const refactorInfo = { name: refactorName10, description: refactorDescription6, actions: [] };
  if (nodeIsStringLiteral && context.triggerReason !== "invoked") {
    return emptyArray;
  }
  if (isExpressionNode(maybeBinary) && (nodeIsStringLiteral || isBinaryExpression(maybeBinary) && treeToArray(maybeBinary).isValidConcatenation)) {
    refactorInfo.actions.push(convertStringAction);
    return [refactorInfo];
  } else if (context.preferences.provideRefactorNotApplicableReason) {
    refactorInfo.actions.push({ ...convertStringAction, notApplicableReason: getLocaleSpecificMessage(Diagnostics.Can_only_convert_string_concatenations_and_string_literals) });
    return [refactorInfo];
  }
  return emptyArray;
}
function getNodeOrParentOfParentheses(file, startPosition) {
  const node = getTokenAtPosition(file, startPosition);
  const nestedBinary = getParentBinaryExpression(node);
  const isNonStringBinary = !treeToArray(nestedBinary).isValidConcatenation;
  if (isNonStringBinary && isParenthesizedExpression(nestedBinary.parent) && isBinaryExpression(nestedBinary.parent.parent)) {
    return nestedBinary.parent.parent;
  }
  return node;
}
function getRefactorEditsToConvertToTemplateString(context, actionName2) {
  const { file, startPosition } = context;
  const node = getNodeOrParentOfParentheses(file, startPosition);
  switch (actionName2) {
    case refactorDescription6:
      return { edits: getEditsForToTemplateLiteral(context, node) };
    default:
      return Debug.fail("invalid action");
  }
}
function getEditsForToTemplateLiteral(context, node) {
  const maybeBinary = getParentBinaryExpression(node);
  const file = context.file;
  const templateLiteral = nodesToTemplate(treeToArray(maybeBinary), file);
  const trailingCommentRanges = getTrailingCommentRanges(file.text, maybeBinary.end);
  if (trailingCommentRanges) {
    const lastComment = trailingCommentRanges[trailingCommentRanges.length - 1];
    const trailingRange = { pos: trailingCommentRanges[0].pos, end: lastComment.end };
    return ts_textChanges_exports.ChangeTracker.with(context, (t) => {
      t.deleteRange(file, trailingRange);
      t.replaceNode(file, maybeBinary, templateLiteral);
    });
  } else {
    return ts_textChanges_exports.ChangeTracker.with(context, (t) => t.replaceNode(file, maybeBinary, templateLiteral));
  }
}
function isNotEqualsOperator(node) {
  return !(node.operatorToken.kind === 64 /* EqualsToken */ || node.operatorToken.kind === 65 /* PlusEqualsToken */);
}
function getParentBinaryExpression(expr) {
  const container = findAncestor(expr.parent, (n) => {
    switch (n.kind) {
      case 211 /* PropertyAccessExpression */:
      case 212 /* ElementAccessExpression */:
        return false;
      case 228 /* TemplateExpression */:
      case 226 /* BinaryExpression */:
        return !(isBinaryExpression(n.parent) && isNotEqualsOperator(n.parent));
      default:
        return "quit";
    }
  });
  return container || expr;
}
function treeToArray(current) {
  const loop = (current2) => {
    if (!isBinaryExpression(current2)) {
      return { nodes: [current2], operators: [], validOperators: true, hasString: isStringLiteral(current2) || isNoSubstitutionTemplateLiteral(current2) };
    }
    const { nodes: nodes2, operators: operators2, hasString: leftHasString, validOperators: leftOperatorValid } = loop(current2.left);
    if (!(leftHasString || isStringLiteral(current2.right) || isTemplateExpression(current2.right))) {
      return { nodes: [current2], operators: [], hasString: false, validOperators: true };
    }
    const currentOperatorValid = current2.operatorToken.kind === 40 /* PlusToken */;
    const validOperators2 = leftOperatorValid && currentOperatorValid;
    nodes2.push(current2.right);
    operators2.push(current2.operatorToken);
    return { nodes: nodes2, operators: operators2, hasString: true, validOperators: validOperators2 };
  };
  const { nodes, operators, validOperators, hasString } = loop(current);
  return { nodes, operators, isValidConcatenation: validOperators && hasString };
}
var copyTrailingOperatorComments = (operators, file) => (index, targetNode) => {
  if (index < operators.length) {
    copyTrailingComments(
      operators[index],
      targetNode,
      file,
      3 /* MultiLineCommentTrivia */,
      /*hasTrailingNewLine*/
      false
    );
  }
};
var copyCommentFromMultiNode = (nodes, file, copyOperatorComments) => (indexes, targetNode) => {
  while (indexes.length > 0) {
    const index = indexes.shift();
    copyTrailingComments(
      nodes[index],
      targetNode,
      file,
      3 /* MultiLineCommentTrivia */,
      /*hasTrailingNewLine*/
      false
    );
    copyOperatorComments(index, targetNode);
  }
};
function escapeRawStringForTemplate(s) {
  return s.replace(/\\.|[$`]/g, (m) => m[0] === "\\" ? m : "\\" + m);
}
function getRawTextOfTemplate(node) {
  const rightShaving = isTemplateHead(node) || isTemplateMiddle(node) ? -2 : -1;
  return getTextOfNode(node).slice(1, rightShaving);
}
function concatConsecutiveString(index, nodes) {
  const indexes = [];
  let text = "", rawText = "";
  while (index < nodes.length) {
    const node = nodes[index];
    if (isStringLiteralLike(node)) {
      text += node.text;
      rawText += escapeRawStringForTemplate(getTextOfNode(node).slice(1, -1));
      indexes.push(index);
      index++;
    } else if (isTemplateExpression(node)) {
      text += node.head.text;
      rawText += getRawTextOfTemplate(node.head);
      break;
    } else {
      break;
    }
  }
  return [index, text, rawText, indexes];
}
function nodesToTemplate({ nodes, operators }, file) {
  const copyOperatorComments = copyTrailingOperatorComments(operators, file);
  const copyCommentFromStringLiterals = copyCommentFromMultiNode(nodes, file, copyOperatorComments);
  const [begin, headText, rawHeadText, headIndexes] = concatConsecutiveString(0, nodes);
  if (begin === nodes.length) {
    const noSubstitutionTemplateLiteral = factory.createNoSubstitutionTemplateLiteral(headText, rawHeadText);
    copyCommentFromStringLiterals(headIndexes, noSubstitutionTemplateLiteral);
    return noSubstitutionTemplateLiteral;
  }
  const templateSpans = [];
  const templateHead = factory.createTemplateHead(headText, rawHeadText);
  copyCommentFromStringLiterals(headIndexes, templateHead);
  for (let i = begin; i < nodes.length; i++) {
    const currentNode = getExpressionFromParenthesesOrExpression(nodes[i]);
    copyOperatorComments(i, currentNode);
    const [newIndex, subsequentText, rawSubsequentText, stringIndexes] = concatConsecutiveString(i + 1, nodes);
    i = newIndex - 1;
    const isLast = i === nodes.length - 1;
    if (isTemplateExpression(currentNode)) {
      const spans = map(currentNode.templateSpans, (span, index) => {
        copyExpressionComments(span);
        const isLastSpan = index === currentNode.templateSpans.length - 1;
        const text = span.literal.text + (isLastSpan ? subsequentText : "");
        const rawText = getRawTextOfTemplate(span.literal) + (isLastSpan ? rawSubsequentText : "");
        return factory.createTemplateSpan(
          span.expression,
          isLast && isLastSpan ? factory.createTemplateTail(text, rawText) : factory.createTemplateMiddle(text, rawText)
        );
      });
      templateSpans.push(...spans);
    } else {
      const templatePart = isLast ? factory.createTemplateTail(subsequentText, rawSubsequentText) : factory.createTemplateMiddle(subsequentText, rawSubsequentText);
      copyCommentFromStringLiterals(stringIndexes, templatePart);
      templateSpans.push(factory.createTemplateSpan(currentNode, templatePart));
    }
  }
  return factory.createTemplateExpression(templateHead, templateSpans);
}
function copyExpressionComments(node) {
  const file = node.getSourceFile();
  copyTrailingComments(
    node,
    node.expression,
    file,
    3 /* MultiLineCommentTrivia */,
    /*hasTrailingNewLine*/
    false
  );
  copyTrailingAsLeadingComments(
    node.expression,
    node.expression,
    file,
    3 /* MultiLineCommentTrivia */,
    /*hasTrailingNewLine*/
    false
  );
}
function getExpressionFromParenthesesOrExpression(node) {
  if (isParenthesizedExpression(node)) {
    copyExpressionComments(node);
    node = node.expression;
  }
  return node;
}

// src/services/_namespaces/ts.refactor.convertToOptionalChainExpression.ts
var ts_refactor_convertToOptionalChainExpression_exports = {};

// src/services/refactors/convertToOptionalChainExpression.ts
var refactorName11 = "Convert to optional chain expression";
var convertToOptionalChainExpressionMessage = getLocaleSpecificMessage(Diagnostics.Convert_to_optional_chain_expression);
var toOptionalChainAction = {
  name: refactorName11,
  description: convertToOptionalChainExpressionMessage,
  kind: "refactor.rewrite.expression.optionalChain"
};
registerRefactor(refactorName11, {
  kinds: [toOptionalChainAction.kind],
  getEditsForAction: getRefactorEditsToConvertToOptionalChain,
  getAvailableActions: getRefactorActionsToConvertToOptionalChain
});
function getRefactorActionsToConvertToOptionalChain(context) {
  const info = getInfo3(context, context.triggerReason === "invoked");
  if (!info) return emptyArray;
  if (!isRefactorErrorInfo(info)) {
    return [{
      name: refactorName11,
      description: convertToOptionalChainExpressionMessage,
      actions: [toOptionalChainAction]
    }];
  }
  if (context.preferences.provideRefactorNotApplicableReason) {
    return [{
      name: refactorName11,
      description: convertToOptionalChainExpressionMessage,
      actions: [{ ...toOptionalChainAction, notApplicableReason: info.error }]
    }];
  }
  return emptyArray;
}
function getRefactorEditsToConvertToOptionalChain(context, actionName2) {
  const info = getInfo3(context);
  Debug.assert(info && !isRefactorErrorInfo(info), "Expected applicable refactor info");
  const edits = ts_textChanges_exports.ChangeTracker.with(context, (t) => doChange6(context.file, context.program.getTypeChecker(), t, info, actionName2));
  return { edits, renameFilename: void 0, renameLocation: void 0 };
}
function isValidExpression(node) {
  return isBinaryExpression(node) || isConditionalExpression(node);
}
function isValidStatement(node) {
  return isExpressionStatement(node) || isReturnStatement(node) || isVariableStatement(node);
}
function isValidExpressionOrStatement(node) {
  return isValidExpression(node) || isValidStatement(node);
}
function getInfo3(context, considerEmptySpans = true) {
  const { file, program } = context;
  const span = getRefactorContextSpan(context);
  const forEmptySpan = span.length === 0;
  if (forEmptySpan && !considerEmptySpans) return void 0;
  const startToken = getTokenAtPosition(file, span.start);
  const endToken = findTokenOnLeftOfPosition(file, span.start + span.length);
  const adjustedSpan = createTextSpanFromBounds(startToken.pos, endToken && endToken.end >= startToken.pos ? endToken.getEnd() : startToken.getEnd());
  const parent2 = forEmptySpan ? getValidParentNodeOfEmptySpan(startToken) : getValidParentNodeContainingSpan(startToken, adjustedSpan);
  const expression = parent2 && isValidExpressionOrStatement(parent2) ? getExpression(parent2) : void 0;
  if (!expression) return { error: getLocaleSpecificMessage(Diagnostics.Could_not_find_convertible_access_expression) };
  const checker = program.getTypeChecker();
  return isConditionalExpression(expression) ? getConditionalInfo(expression, checker) : getBinaryInfo(expression);
}
function getConditionalInfo(expression, checker) {
  const condition = expression.condition;
  const finalExpression = getFinalExpressionInChain(expression.whenTrue);
  if (!finalExpression || checker.isNullableType(checker.getTypeAtLocation(finalExpression))) {
    return { error: getLocaleSpecificMessage(Diagnostics.Could_not_find_convertible_access_expression) };
  }
  if ((isPropertyAccessExpression(condition) || isIdentifier(condition)) && getMatchingStart(condition, finalExpression.expression)) {
    return { finalExpression, occurrences: [condition], expression };
  } else if (isBinaryExpression(condition)) {
    const occurrences = getOccurrencesInExpression(finalExpression.expression, condition);
    return occurrences ? { finalExpression, occurrences, expression } : { error: getLocaleSpecificMessage(Diagnostics.Could_not_find_matching_access_expressions) };
  }
}
function getBinaryInfo(expression) {
  if (expression.operatorToken.kind !== 56 /* AmpersandAmpersandToken */) {
    return { error: getLocaleSpecificMessage(Diagnostics.Can_only_convert_logical_AND_access_chains) };
  }
  const finalExpression = getFinalExpressionInChain(expression.right);
  if (!finalExpression) return { error: getLocaleSpecificMessage(Diagnostics.Could_not_find_convertible_access_expression) };
  const occurrences = getOccurrencesInExpression(finalExpression.expression, expression.left);
  return occurrences ? { finalExpression, occurrences, expression } : { error: getLocaleSpecificMessage(Diagnostics.Could_not_find_matching_access_expressions) };
}
function getOccurrencesInExpression(matchTo, expression) {
  const occurrences = [];
  while (isBinaryExpression(expression) && expression.operatorToken.kind === 56 /* AmpersandAmpersandToken */) {
    const match = getMatchingStart(skipParentheses(matchTo), skipParentheses(expression.right));
    if (!match) {
      break;
    }
    occurrences.push(match);
    matchTo = match;
    expression = expression.left;
  }
  const finalMatch = getMatchingStart(matchTo, expression);
  if (finalMatch) {
    occurrences.push(finalMatch);
  }
  return occurrences.length > 0 ? occurrences : void 0;
}
function getMatchingStart(chain, subchain) {
  if (!isIdentifier(subchain) && !isPropertyAccessExpression(subchain) && !isElementAccessExpression(subchain)) {
    return void 0;
  }
  return chainStartsWith(chain, subchain) ? subchain : void 0;
}
function chainStartsWith(chain, subchain) {
  while (isCallExpression(chain) || isPropertyAccessExpression(chain) || isElementAccessExpression(chain)) {
    if (getTextOfChainNode(chain) === getTextOfChainNode(subchain)) break;
    chain = chain.expression;
  }
  while (isPropertyAccessExpression(chain) && isPropertyAccessExpression(subchain) || isElementAccessExpression(chain) && isElementAccessExpression(subchain)) {
    if (getTextOfChainNode(chain) !== getTextOfChainNode(subchain)) return false;
    chain = chain.expression;
    subchain = subchain.expression;
  }
  return isIdentifier(chain) && isIdentifier(subchain) && chain.getText() === subchain.getText();
}
function getTextOfChainNode(node) {
  if (isIdentifier(node) || isStringOrNumericLiteralLike(node)) {
    return node.getText();
  }
  if (isPropertyAccessExpression(node)) {
    return getTextOfChainNode(node.name);
  }
  if (isElementAccessExpression(node)) {
    return getTextOfChainNode(node.argumentExpression);
  }
  return void 0;
}
function getValidParentNodeContainingSpan(node, span) {
  while (node.parent) {
    if (isValidExpressionOrStatement(node) && span.length !== 0 && node.end >= span.start + span.length) {
      return node;
    }
    node = node.parent;
  }
  return void 0;
}
function getValidParentNodeOfEmptySpan(node) {
  while (node.parent) {
    if (isValidExpressionOrStatement(node) && !isValidExpressionOrStatement(node.parent)) {
      return node;
    }
    node = node.parent;
  }
  return void 0;
}
function getExpression(node) {
  if (isValidExpression(node)) {
    return node;
  }
  if (isVariableStatement(node)) {
    const variable = getSingleVariableOfVariableStatement(node);
    const initializer = variable == null ? void 0 : variable.initializer;
    return initializer && isValidExpression(initializer) ? initializer : void 0;
  }
  return node.expression && isValidExpression(node.expression) ? node.expression : void 0;
}
function getFinalExpressionInChain(node) {
  node = skipParentheses(node);
  if (isBinaryExpression(node)) {
    return getFinalExpressionInChain(node.left);
  } else if ((isPropertyAccessExpression(node) || isElementAccessExpression(node) || isCallExpression(node)) && !isOptionalChain(node)) {
    return node;
  }
  return void 0;
}
function convertOccurrences(checker, toConvert, occurrences) {
  if (isPropertyAccessExpression(toConvert) || isElementAccessExpression(toConvert) || isCallExpression(toConvert)) {
    const chain = convertOccurrences(checker, toConvert.expression, occurrences);
    const lastOccurrence = occurrences.length > 0 ? occurrences[occurrences.length - 1] : void 0;
    const isOccurrence = (lastOccurrence == null ? void 0 : lastOccurrence.getText()) === toConvert.expression.getText();
    if (isOccurrence) occurrences.pop();
    if (isCallExpression(toConvert)) {
      return isOccurrence ? factory.createCallChain(chain, factory.createToken(29 /* QuestionDotToken */), toConvert.typeArguments, toConvert.arguments) : factory.createCallChain(chain, toConvert.questionDotToken, toConvert.typeArguments, toConvert.arguments);
    } else if (isPropertyAccessExpression(toConvert)) {
      return isOccurrence ? factory.createPropertyAccessChain(chain, factory.createToken(29 /* QuestionDotToken */), toConvert.name) : factory.createPropertyAccessChain(chain, toConvert.questionDotToken, toConvert.name);
    } else if (isElementAccessExpression(toConvert)) {
      return isOccurrence ? factory.createElementAccessChain(chain, factory.createToken(29 /* QuestionDotToken */), toConvert.argumentExpression) : factory.createElementAccessChain(chain, toConvert.questionDotToken, toConvert.argumentExpression);
    }
  }
  return toConvert;
}
function doChange6(sourceFile, checker, changes, info, _actionName) {
  const { finalExpression, occurrences, expression } = info;
  const firstOccurrence = occurrences[occurrences.length - 1];
  const convertedChain = convertOccurrences(checker, finalExpression, occurrences);
  if (convertedChain && (isPropertyAccessExpression(convertedChain) || isElementAccessExpression(convertedChain) || isCallExpression(convertedChain))) {
    if (isBinaryExpression(expression)) {
      changes.replaceNodeRange(sourceFile, firstOccurrence, finalExpression, convertedChain);
    } else if (isConditionalExpression(expression)) {
      changes.replaceNode(sourceFile, expression, factory.createBinaryExpression(convertedChain, factory.createToken(61 /* QuestionQuestionToken */), expression.whenFalse));
    }
  }
}

// src/services/_namespaces/ts.refactor.extractSymbol.ts
var ts_refactor_extractSymbol_exports = {};
__export(ts_refactor_extractSymbol_exports, {
  Messages: () => Messages,
  RangeFacts: () => RangeFacts,
  getRangeToExtract: () => getRangeToExtract2,
  getRefactorActionsToExtractSymbol: () => getRefactorActionsToExtractSymbol,
  getRefactorEditsToExtractSymbol: () => getRefactorEditsToExtractSymbol
});

// src/services/refactors/extractSymbol.ts
var refactorName12 = "Extract Symbol";
var extractConstantAction = {
  name: "Extract Constant",
  description: getLocaleSpecificMessage(Diagnostics.Extract_constant),
  kind: "refactor.extract.constant"
};
var extractFunctionAction = {
  name: "Extract Function",
  description: getLocaleSpecificMessage(Diagnostics.Extract_function),
  kind: "refactor.extract.function"
};
registerRefactor(refactorName12, {
  kinds: [
    extractConstantAction.kind,
    extractFunctionAction.kind
  ],
  getEditsForAction: getRefactorEditsToExtractSymbol,
  getAvailableActions: getRefactorActionsToExtractSymbol
});
function getRefactorActionsToExtractSymbol(context) {
  const requestedRefactor = context.kind;
  const rangeToExtract = getRangeToExtract2(context.file, getRefactorContextSpan(context), context.triggerReason === "invoked");
  const targetRange = rangeToExtract.targetRange;
  if (targetRange === void 0) {
    if (!rangeToExtract.errors || rangeToExtract.errors.length === 0 || !context.preferences.provideRefactorNotApplicableReason) {
      return emptyArray;
    }
    const errors = [];
    if (refactorKindBeginsWith(extractFunctionAction.kind, requestedRefactor)) {
      errors.push({
        name: refactorName12,
        description: extractFunctionAction.description,
        actions: [{ ...extractFunctionAction, notApplicableReason: getStringError(rangeToExtract.errors) }]
      });
    }
    if (refactorKindBeginsWith(extractConstantAction.kind, requestedRefactor)) {
      errors.push({
        name: refactorName12,
        description: extractConstantAction.description,
        actions: [{ ...extractConstantAction, notApplicableReason: getStringError(rangeToExtract.errors) }]
      });
    }
    return errors;
  }
  const { affectedTextRange, extractions } = getPossibleExtractions(targetRange, context);
  if (extractions === void 0) {
    return emptyArray;
  }
  const functionActions = [];
  const usedFunctionNames = /* @__PURE__ */ new Map();
  let innermostErrorFunctionAction;
  const constantActions = [];
  const usedConstantNames = /* @__PURE__ */ new Map();
  let innermostErrorConstantAction;
  let i = 0;
  for (const { functionExtraction, constantExtraction } of extractions) {
    if (refactorKindBeginsWith(extractFunctionAction.kind, requestedRefactor)) {
      const description3 = functionExtraction.description;
      if (functionExtraction.errors.length === 0) {
        if (!usedFunctionNames.has(description3)) {
          usedFunctionNames.set(description3, true);
          functionActions.push({
            description: description3,
            name: `function_scope_${i}`,
            kind: extractFunctionAction.kind,
            range: {
              start: { line: getLineAndCharacterOfPosition(context.file, affectedTextRange.pos).line, offset: getLineAndCharacterOfPosition(context.file, affectedTextRange.pos).character },
              end: { line: getLineAndCharacterOfPosition(context.file, affectedTextRange.end).line, offset: getLineAndCharacterOfPosition(context.file, affectedTextRange.end).character }
            }
          });
        }
      } else if (!innermostErrorFunctionAction) {
        innermostErrorFunctionAction = {
          description: description3,
          name: `function_scope_${i}`,
          notApplicableReason: getStringError(functionExtraction.errors),
          kind: extractFunctionAction.kind
        };
      }
    }
    if (refactorKindBeginsWith(extractConstantAction.kind, requestedRefactor)) {
      const description3 = constantExtraction.description;
      if (constantExtraction.errors.length === 0) {
        if (!usedConstantNames.has(description3)) {
          usedConstantNames.set(description3, true);
          constantActions.push({
            description: description3,
            name: `constant_scope_${i}`,
            kind: extractConstantAction.kind,
            range: {
              start: { line: getLineAndCharacterOfPosition(context.file, affectedTextRange.pos).line, offset: getLineAndCharacterOfPosition(context.file, affectedTextRange.pos).character },
              end: { line: getLineAndCharacterOfPosition(context.file, affectedTextRange.end).line, offset: getLineAndCharacterOfPosition(context.file, affectedTextRange.end).character }
            }
          });
        }
      } else if (!innermostErrorConstantAction) {
        innermostErrorConstantAction = {
          description: description3,
          name: `constant_scope_${i}`,
          notApplicableReason: getStringError(constantExtraction.errors),
          kind: extractConstantAction.kind
        };
      }
    }
    i++;
  }
  const infos = [];
  if (functionActions.length) {
    infos.push({
      name: refactorName12,
      description: getLocaleSpecificMessage(Diagnostics.Extract_function),
      actions: functionActions
    });
  } else if (context.preferences.provideRefactorNotApplicableReason && innermostErrorFunctionAction) {
    infos.push({
      name: refactorName12,
      description: getLocaleSpecificMessage(Diagnostics.Extract_function),
      actions: [innermostErrorFunctionAction]
    });
  }
  if (constantActions.length) {
    infos.push({
      name: refactorName12,
      description: getLocaleSpecificMessage(Diagnostics.Extract_constant),
      actions: constantActions
    });
  } else if (context.preferences.provideRefactorNotApplicableReason && innermostErrorConstantAction) {
    infos.push({
      name: refactorName12,
      description: getLocaleSpecificMessage(Diagnostics.Extract_constant),
      actions: [innermostErrorConstantAction]
    });
  }
  return infos.length ? infos : emptyArray;
  function getStringError(errors) {
    let error2 = errors[0].messageText;
    if (typeof error2 !== "string") {
      error2 = error2.messageText;
    }
    return error2;
  }
}
function getRefactorEditsToExtractSymbol(context, actionName2) {
  const rangeToExtract = getRangeToExtract2(context.file, getRefactorContextSpan(context));
  const targetRange = rangeToExtract.targetRange;
  const parsedFunctionIndexMatch = /^function_scope_(\d+)$/.exec(actionName2);
  if (parsedFunctionIndexMatch) {
    const index = +parsedFunctionIndexMatch[1];
    Debug.assert(isFinite(index), "Expected to parse a finite number from the function scope index");
    return getFunctionExtractionAtIndex(targetRange, context, index);
  }
  const parsedConstantIndexMatch = /^constant_scope_(\d+)$/.exec(actionName2);
  if (parsedConstantIndexMatch) {
    const index = +parsedConstantIndexMatch[1];
    Debug.assert(isFinite(index), "Expected to parse a finite number from the constant scope index");
    return getConstantExtractionAtIndex(targetRange, context, index);
  }
  Debug.fail("Unrecognized action name");
}
var Messages;
((Messages2) => {
  function createMessage(message) {
    return { message, code: 0, category: 3 /* Message */, key: message };
  }
  Messages2.cannotExtractRange = createMessage("Cannot extract range.");
  Messages2.cannotExtractImport = createMessage("Cannot extract import statement.");
  Messages2.cannotExtractSuper = createMessage("Cannot extract super call.");
  Messages2.cannotExtractJSDoc = createMessage("Cannot extract JSDoc.");
  Messages2.cannotExtractEmpty = createMessage("Cannot extract empty range.");
  Messages2.expressionExpected = createMessage("expression expected.");
  Messages2.uselessConstantType = createMessage("No reason to extract constant of type.");
  Messages2.statementOrExpressionExpected = createMessage("Statement or expression expected.");
  Messages2.cannotExtractRangeContainingConditionalBreakOrContinueStatements = createMessage("Cannot extract range containing conditional break or continue statements.");
  Messages2.cannotExtractRangeContainingConditionalReturnStatement = createMessage("Cannot extract range containing conditional return statement.");
  Messages2.cannotExtractRangeContainingLabeledBreakOrContinueStatementWithTargetOutsideOfTheRange = createMessage("Cannot extract range containing labeled break or continue with target outside of the range.");
  Messages2.cannotExtractRangeThatContainsWritesToReferencesLocatedOutsideOfTheTargetRangeInGenerators = createMessage("Cannot extract range containing writes to references located outside of the target range in generators.");
  Messages2.typeWillNotBeVisibleInTheNewScope = createMessage("Type will not visible in the new scope.");
  Messages2.functionWillNotBeVisibleInTheNewScope = createMessage("Function will not visible in the new scope.");
  Messages2.cannotExtractIdentifier = createMessage("Select more than a single identifier.");
  Messages2.cannotExtractExportedEntity = createMessage("Cannot extract exported declaration");
  Messages2.cannotWriteInExpression = createMessage("Cannot write back side-effects when extracting an expression");
  Messages2.cannotExtractReadonlyPropertyInitializerOutsideConstructor = createMessage("Cannot move initialization of read-only class property outside of the constructor");
  Messages2.cannotExtractAmbientBlock = createMessage("Cannot extract code from ambient contexts");
  Messages2.cannotAccessVariablesFromNestedScopes = createMessage("Cannot access variables from nested scopes");
  Messages2.cannotExtractToJSClass = createMessage("Cannot extract constant to a class scope in JS");
  Messages2.cannotExtractToExpressionArrowFunction = createMessage("Cannot extract constant to an arrow function without a block");
  Messages2.cannotExtractFunctionsContainingThisToMethod = createMessage("Cannot extract functions containing this to method");
})(Messages || (Messages = {}));
var RangeFacts = /* @__PURE__ */ ((RangeFacts2) => {
  RangeFacts2[RangeFacts2["None"] = 0] = "None";
  RangeFacts2[RangeFacts2["HasReturn"] = 1] = "HasReturn";
  RangeFacts2[RangeFacts2["IsGenerator"] = 2] = "IsGenerator";
  RangeFacts2[RangeFacts2["IsAsyncFunction"] = 4] = "IsAsyncFunction";
  RangeFacts2[RangeFacts2["UsesThis"] = 8] = "UsesThis";
  RangeFacts2[RangeFacts2["UsesThisInFunction"] = 16] = "UsesThisInFunction";
  RangeFacts2[RangeFacts2["InStaticRegion"] = 32] = "InStaticRegion";
  return RangeFacts2;
})(RangeFacts || {});
function getRangeToExtract2(sourceFile, span, invoked = true) {
  const { length: length2 } = span;
  if (length2 === 0 && !invoked) {
    return { errors: [createFileDiagnostic(sourceFile, span.start, length2, Messages.cannotExtractEmpty)] };
  }
  const cursorRequest = length2 === 0 && invoked;
  const startToken = findFirstNonJsxWhitespaceToken(sourceFile, span.start);
  const endToken = findTokenOnLeftOfPosition(sourceFile, textSpanEnd(span));
  const adjustedSpan = startToken && endToken && invoked ? getAdjustedSpanFromNodes(startToken, endToken, sourceFile) : span;
  const start = cursorRequest ? getExtractableParent(startToken) : getParentNodeInSpan(startToken, sourceFile, adjustedSpan);
  const end = cursorRequest ? start : getParentNodeInSpan(endToken, sourceFile, adjustedSpan);
  let rangeFacts = 0 /* None */;
  let thisNode;
  if (!start || !end) {
    return { errors: [createFileDiagnostic(sourceFile, span.start, length2, Messages.cannotExtractRange)] };
  }
  if (start.flags & 16777216 /* JSDoc */) {
    return { errors: [createFileDiagnostic(sourceFile, span.start, length2, Messages.cannotExtractJSDoc)] };
  }
  if (start.parent !== end.parent) {
    return { errors: [createFileDiagnostic(sourceFile, span.start, length2, Messages.cannotExtractRange)] };
  }
  if (start !== end) {
    if (!isBlockLike(start.parent)) {
      return { errors: [createFileDiagnostic(sourceFile, span.start, length2, Messages.cannotExtractRange)] };
    }
    const statements = [];
    for (const statement of start.parent.statements) {
      if (statement === start || statements.length) {
        const errors2 = checkNode(statement);
        if (errors2) {
          return { errors: errors2 };
        }
        statements.push(statement);
      }
      if (statement === end) {
        break;
      }
    }
    if (!statements.length) {
      return { errors: [createFileDiagnostic(sourceFile, span.start, length2, Messages.cannotExtractRange)] };
    }
    return { targetRange: { range: statements, facts: rangeFacts, thisNode } };
  }
  if (isReturnStatement(start) && !start.expression) {
    return { errors: [createFileDiagnostic(sourceFile, span.start, length2, Messages.cannotExtractRange)] };
  }
  const node = refineNode(start);
  const errors = checkRootNode(node) || checkNode(node);
  if (errors) {
    return { errors };
  }
  return { targetRange: { range: getStatementOrExpressionRange(node), facts: rangeFacts, thisNode } };
  function refineNode(node2) {
    if (isReturnStatement(node2)) {
      if (node2.expression) {
        return node2.expression;
      }
    } else if (isVariableStatement(node2) || isVariableDeclarationList(node2)) {
      const declarations = isVariableStatement(node2) ? node2.declarationList.declarations : node2.declarations;
      let numInitializers = 0;
      let lastInitializer;
      for (const declaration of declarations) {
        if (declaration.initializer) {
          numInitializers++;
          lastInitializer = declaration.initializer;
        }
      }
      if (numInitializers === 1) {
        return lastInitializer;
      }
    } else if (isVariableDeclaration(node2)) {
      if (node2.initializer) {
        return node2.initializer;
      }
    }
    return node2;
  }
  function checkRootNode(node2) {
    if (isIdentifier(isExpressionStatement(node2) ? node2.expression : node2)) {
      return [createDiagnosticForNode(node2, Messages.cannotExtractIdentifier)];
    }
    return void 0;
  }
  function checkForStaticContext(nodeToCheck, containingClass) {
    let current = nodeToCheck;
    while (current !== containingClass) {
      if (current.kind === 172 /* PropertyDeclaration */) {
        if (isStatic(current)) {
          rangeFacts |= 32 /* InStaticRegion */;
        }
        break;
      } else if (current.kind === 169 /* Parameter */) {
        const ctorOrMethod = getContainingFunction(current);
        if (ctorOrMethod.kind === 176 /* Constructor */) {
          rangeFacts |= 32 /* InStaticRegion */;
        }
        break;
      } else if (current.kind === 174 /* MethodDeclaration */) {
        if (isStatic(current)) {
          rangeFacts |= 32 /* InStaticRegion */;
        }
      }
      current = current.parent;
    }
  }
  function checkNode(nodeToCheck) {
    let PermittedJumps;
    ((PermittedJumps2) => {
      PermittedJumps2[PermittedJumps2["None"] = 0] = "None";
      PermittedJumps2[PermittedJumps2["Break"] = 1] = "Break";
      PermittedJumps2[PermittedJumps2["Continue"] = 2] = "Continue";
      PermittedJumps2[PermittedJumps2["Return"] = 4] = "Return";
    })(PermittedJumps || (PermittedJumps = {}));
    Debug.assert(nodeToCheck.pos <= nodeToCheck.end, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809 (1)");
    Debug.assert(!positionIsSynthesized(nodeToCheck.pos), "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809 (2)");
    if (!isStatement(nodeToCheck) && !(isExpressionNode(nodeToCheck) && isExtractableExpression(nodeToCheck)) && !isStringLiteralJsxAttribute(nodeToCheck)) {
      return [createDiagnosticForNode(nodeToCheck, Messages.statementOrExpressionExpected)];
    }
    if (nodeToCheck.flags & 33554432 /* Ambient */) {
      return [createDiagnosticForNode(nodeToCheck, Messages.cannotExtractAmbientBlock)];
    }
    const containingClass = getContainingClass(nodeToCheck);
    if (containingClass) {
      checkForStaticContext(nodeToCheck, containingClass);
    }
    let errors2;
    let permittedJumps = 4 /* Return */;
    let seenLabels;
    visit(nodeToCheck);
    if (rangeFacts & 8 /* UsesThis */) {
      const container = getThisContainer(
        nodeToCheck,
        /*includeArrowFunctions*/
        false,
        /*includeClassComputedPropertyName*/
        false
      );
      if (container.kind === 262 /* FunctionDeclaration */ || container.kind === 174 /* MethodDeclaration */ && container.parent.kind === 210 /* ObjectLiteralExpression */ || container.kind === 218 /* FunctionExpression */) {
        rangeFacts |= 16 /* UsesThisInFunction */;
      }
    }
    return errors2;
    function visit(node2) {
      if (errors2) {
        return true;
      }
      if (isDeclaration(node2)) {
        const declaringNode = node2.kind === 260 /* VariableDeclaration */ ? node2.parent.parent : node2;
        if (hasSyntacticModifier(declaringNode, 32 /* Export */)) {
          (errors2 || (errors2 = [])).push(createDiagnosticForNode(node2, Messages.cannotExtractExportedEntity));
          return true;
        }
      }
      switch (node2.kind) {
        case 272 /* ImportDeclaration */:
          (errors2 || (errors2 = [])).push(createDiagnosticForNode(node2, Messages.cannotExtractImport));
          return true;
        case 277 /* ExportAssignment */:
          (errors2 || (errors2 = [])).push(createDiagnosticForNode(node2, Messages.cannotExtractExportedEntity));
          return true;
        case 108 /* SuperKeyword */:
          if (node2.parent.kind === 213 /* CallExpression */) {
            const containingClass2 = getContainingClass(node2);
            if (containingClass2 === void 0 || containingClass2.pos < span.start || containingClass2.end >= span.start + span.length) {
              (errors2 || (errors2 = [])).push(createDiagnosticForNode(node2, Messages.cannotExtractSuper));
              return true;
            }
          } else {
            rangeFacts |= 8 /* UsesThis */;
            thisNode = node2;
          }
          break;
        case 219 /* ArrowFunction */:
          forEachChild(node2, function check(n) {
            if (isThis(n)) {
              rangeFacts |= 8 /* UsesThis */;
              thisNode = node2;
            } else if (isClassLike(n) || isFunctionLike(n) && !isArrowFunction(n)) {
              return false;
            } else {
              forEachChild(n, check);
            }
          });
        case 263 /* ClassDeclaration */:
        case 262 /* FunctionDeclaration */:
          if (isSourceFile(node2.parent) && node2.parent.externalModuleIndicator === void 0) {
            (errors2 || (errors2 = [])).push(createDiagnosticForNode(node2, Messages.functionWillNotBeVisibleInTheNewScope));
          }
        case 231 /* ClassExpression */:
        case 218 /* FunctionExpression */:
        case 174 /* MethodDeclaration */:
        case 176 /* Constructor */:
        case 177 /* GetAccessor */:
        case 178 /* SetAccessor */:
          return false;
      }
      const savedPermittedJumps = permittedJumps;
      switch (node2.kind) {
        case 245 /* IfStatement */:
          permittedJumps &= ~4 /* Return */;
          break;
        case 258 /* TryStatement */:
          permittedJumps = 0 /* None */;
          break;
        case 241 /* Block */:
          if (node2.parent && node2.parent.kind === 258 /* TryStatement */ && node2.parent.finallyBlock === node2) {
            permittedJumps = 4 /* Return */;
          }
          break;
        case 297 /* DefaultClause */:
        case 296 /* CaseClause */:
          permittedJumps |= 1 /* Break */;
          break;
        default:
          if (isIterationStatement(
            node2,
            /*lookInLabeledStatements*/
            false
          )) {
            permittedJumps |= 1 /* Break */ | 2 /* Continue */;
          }
          break;
      }
      switch (node2.kind) {
        case 197 /* ThisType */:
        case 110 /* ThisKeyword */:
          rangeFacts |= 8 /* UsesThis */;
          thisNode = node2;
          break;
        case 256 /* LabeledStatement */: {
          const label = node2.label;
          (seenLabels || (seenLabels = [])).push(label.escapedText);
          forEachChild(node2, visit);
          seenLabels.pop();
          break;
        }
        case 252 /* BreakStatement */:
        case 251 /* ContinueStatement */: {
          const label = node2.label;
          if (label) {
            if (!contains(seenLabels, label.escapedText)) {
              (errors2 || (errors2 = [])).push(createDiagnosticForNode(node2, Messages.cannotExtractRangeContainingLabeledBreakOrContinueStatementWithTargetOutsideOfTheRange));
            }
          } else {
            if (!(permittedJumps & (node2.kind === 252 /* BreakStatement */ ? 1 /* Break */ : 2 /* Continue */))) {
              (errors2 || (errors2 = [])).push(createDiagnosticForNode(node2, Messages.cannotExtractRangeContainingConditionalBreakOrContinueStatements));
            }
          }
          break;
        }
        case 223 /* AwaitExpression */:
          rangeFacts |= 4 /* IsAsyncFunction */;
          break;
        case 229 /* YieldExpression */:
          rangeFacts |= 2 /* IsGenerator */;
          break;
        case 253 /* ReturnStatement */:
          if (permittedJumps & 4 /* Return */) {
            rangeFacts |= 1 /* HasReturn */;
          } else {
            (errors2 || (errors2 = [])).push(createDiagnosticForNode(node2, Messages.cannotExtractRangeContainingConditionalReturnStatement));
          }
          break;
        default:
          forEachChild(node2, visit);
          break;
      }
      permittedJumps = savedPermittedJumps;
    }
  }
}
function getAdjustedSpanFromNodes(startNode2, endNode2, sourceFile) {
  const start = startNode2.getStart(sourceFile);
  let end = endNode2.getEnd();
  if (sourceFile.text.charCodeAt(end) === 59 /* semicolon */) {
    end++;
  }
  return { start, length: end - start };
}
function getStatementOrExpressionRange(node) {
  if (isStatement(node)) {
    return [node];
  }
  if (isExpressionNode(node)) {
    return isExpressionStatement(node.parent) ? [node.parent] : node;
  }
  if (isStringLiteralJsxAttribute(node)) {
    return node;
  }
  return void 0;
}
function isScope(node) {
  return isArrowFunction(node) ? isFunctionBody(node.body) : isFunctionLikeDeclaration(node) || isSourceFile(node) || isModuleBlock(node) || isClassLike(node);
}
function collectEnclosingScopes(range) {
  let current = isReadonlyArray(range.range) ? first(range.range) : range.range;
  if (range.facts & 8 /* UsesThis */ && !(range.facts & 16 /* UsesThisInFunction */)) {
    const containingClass = getContainingClass(current);
    if (containingClass) {
      const containingFunction = findAncestor(current, isFunctionLikeDeclaration);
      return containingFunction ? [containingFunction, containingClass] : [containingClass];
    }
  }
  const scopes = [];
  while (true) {
    current = current.parent;
    if (current.kind === 169 /* Parameter */) {
      current = findAncestor(current, (parent2) => isFunctionLikeDeclaration(parent2)).parent;
    }
    if (isScope(current)) {
      scopes.push(current);
      if (current.kind === 307 /* SourceFile */) {
        return scopes;
      }
    }
  }
}
function getFunctionExtractionAtIndex(targetRange, context, requestedChangesIndex) {
  const { scopes, readsAndWrites: { target, usagesPerScope, functionErrorsPerScope, exposedVariableDeclarations } } = getPossibleExtractionsWorker(targetRange, context);
  Debug.assert(!functionErrorsPerScope[requestedChangesIndex].length, "The extraction went missing? How?");
  context.cancellationToken.throwIfCancellationRequested();
  return extractFunctionInScope(target, scopes[requestedChangesIndex], usagesPerScope[requestedChangesIndex], exposedVariableDeclarations, targetRange, context);
}
function getConstantExtractionAtIndex(targetRange, context, requestedChangesIndex) {
  const { scopes, readsAndWrites: { target, usagesPerScope, constantErrorsPerScope, exposedVariableDeclarations } } = getPossibleExtractionsWorker(targetRange, context);
  Debug.assert(!constantErrorsPerScope[requestedChangesIndex].length, "The extraction went missing? How?");
  Debug.assert(exposedVariableDeclarations.length === 0, "Extract constant accepted a range containing a variable declaration?");
  context.cancellationToken.throwIfCancellationRequested();
  const expression = isExpression(target) ? target : target.statements[0].expression;
  return extractConstantInScope(expression, scopes[requestedChangesIndex], usagesPerScope[requestedChangesIndex], targetRange.facts, context);
}
function getPossibleExtractions(targetRange, context) {
  const { scopes, affectedTextRange, readsAndWrites: { functionErrorsPerScope, constantErrorsPerScope } } = getPossibleExtractionsWorker(targetRange, context);
  const extractions = scopes.map((scope, i) => {
    const functionDescriptionPart = getDescriptionForFunctionInScope(scope);
    const constantDescriptionPart = getDescriptionForConstantInScope(scope);
    const scopeDescription = isFunctionLikeDeclaration(scope) ? getDescriptionForFunctionLikeDeclaration(scope) : isClassLike(scope) ? getDescriptionForClassLikeDeclaration(scope) : getDescriptionForModuleLikeDeclaration(scope);
    let functionDescription;
    let constantDescription;
    if (scopeDescription === 1 /* Global */) {
      functionDescription = formatStringFromArgs(getLocaleSpecificMessage(Diagnostics.Extract_to_0_in_1_scope), [functionDescriptionPart, "global"]);
      constantDescription = formatStringFromArgs(getLocaleSpecificMessage(Diagnostics.Extract_to_0_in_1_scope), [constantDescriptionPart, "global"]);
    } else if (scopeDescription === 0 /* Module */) {
      functionDescription = formatStringFromArgs(getLocaleSpecificMessage(Diagnostics.Extract_to_0_in_1_scope), [functionDescriptionPart, "module"]);
      constantDescription = formatStringFromArgs(getLocaleSpecificMessage(Diagnostics.Extract_to_0_in_1_scope), [constantDescriptionPart, "module"]);
    } else {
      functionDescription = formatStringFromArgs(getLocaleSpecificMessage(Diagnostics.Extract_to_0_in_1), [functionDescriptionPart, scopeDescription]);
      constantDescription = formatStringFromArgs(getLocaleSpecificMessage(Diagnostics.Extract_to_0_in_1), [constantDescriptionPart, scopeDescription]);
    }
    if (i === 0 && !isClassLike(scope)) {
      constantDescription = formatStringFromArgs(getLocaleSpecificMessage(Diagnostics.Extract_to_0_in_enclosing_scope), [constantDescriptionPart]);
    }
    return {
      functionExtraction: {
        description: functionDescription,
        errors: functionErrorsPerScope[i]
      },
      constantExtraction: {
        description: constantDescription,
        errors: constantErrorsPerScope[i]
      }
    };
  });
  return { affectedTextRange, extractions };
}
function getPossibleExtractionsWorker(targetRange, context) {
  const { file: sourceFile } = context;
  const scopes = collectEnclosingScopes(targetRange);
  const enclosingTextRange = getEnclosingTextRange(targetRange, sourceFile);
  const readsAndWrites = collectReadsAndWrites(
    targetRange,
    scopes,
    enclosingTextRange,
    sourceFile,
    context.program.getTypeChecker(),
    context.cancellationToken
  );
  return { scopes, affectedTextRange: enclosingTextRange, readsAndWrites };
}
function getDescriptionForFunctionInScope(scope) {
  return isFunctionLikeDeclaration(scope) ? "inner function" : isClassLike(scope) ? "method" : "function";
}
function getDescriptionForConstantInScope(scope) {
  return isClassLike(scope) ? "readonly field" : "constant";
}
function getDescriptionForFunctionLikeDeclaration(scope) {
  switch (scope.kind) {
    case 176 /* Constructor */:
      return "constructor";
    case 218 /* FunctionExpression */:
    case 262 /* FunctionDeclaration */:
      return scope.name ? `function '${scope.name.text}'` : ANONYMOUS;
    case 219 /* ArrowFunction */:
      return "arrow function";
    case 174 /* MethodDeclaration */:
      return `method '${scope.name.getText()}'`;
    case 177 /* GetAccessor */:
      return `'get ${scope.name.getText()}'`;
    case 178 /* SetAccessor */:
      return `'set ${scope.name.getText()}'`;
    default:
      Debug.assertNever(scope, `Unexpected scope kind ${scope.kind}`);
  }
}
function getDescriptionForClassLikeDeclaration(scope) {
  return scope.kind === 263 /* ClassDeclaration */ ? scope.name ? `class '${scope.name.text}'` : "anonymous class declaration" : scope.name ? `class expression '${scope.name.text}'` : "anonymous class expression";
}
function getDescriptionForModuleLikeDeclaration(scope) {
  return scope.kind === 268 /* ModuleBlock */ ? `namespace '${scope.parent.name.getText()}'` : scope.externalModuleIndicator ? 0 /* Module */ : 1 /* Global */;
}
function extractFunctionInScope(node, scope, { usages: usagesInScope, typeParameterUsages, substitutions }, exposedVariableDeclarations, range, context) {
  const checker = context.program.getTypeChecker();
  const scriptTarget = getEmitScriptTarget(context.program.getCompilerOptions());
  const importAdder = ts_codefix_exports.createImportAdder(context.file, context.program, context.preferences, context.host);
  const file = scope.getSourceFile();
  const functionNameText = getUniqueName(isClassLike(scope) ? "newMethod" : "newFunction", file);
  const isJS = isInJSFile(scope);
  const functionName = factory.createIdentifier(functionNameText);
  let returnType;
  const parameters = [];
  const callArguments = [];
  let writes;
  usagesInScope.forEach((usage, name) => {
    let typeNode;
    if (!isJS) {
      let type = checker.getTypeOfSymbolAtLocation(usage.symbol, usage.node);
      type = checker.getBaseTypeOfLiteralType(type);
      typeNode = ts_codefix_exports.typeToAutoImportableTypeNode(checker, importAdder, type, scope, scriptTarget, 1 /* NoTruncation */);
    }
    const paramDecl = factory.createParameterDeclaration(
      /*modifiers*/
      void 0,
      /*dotDotDotToken*/
      void 0,
      /*name*/
      name,
      /*questionToken*/
      void 0,
      typeNode
    );
    parameters.push(paramDecl);
    if (usage.usage === 2 /* Write */) {
      (writes || (writes = [])).push(usage);
    }
    callArguments.push(factory.createIdentifier(name));
  });
  const typeParametersAndDeclarations = arrayFrom(typeParameterUsages.values(), (type) => ({ type, declaration: getFirstDeclarationBeforePosition(type, context.startPosition) }));
  const sortedTypeParametersAndDeclarations = typeParametersAndDeclarations.sort(compareTypesByDeclarationOrder);
  const typeParameters = sortedTypeParametersAndDeclarations.length === 0 ? void 0 : mapDefined(sortedTypeParametersAndDeclarations, ({ declaration }) => declaration);
  const callTypeArguments = typeParameters !== void 0 ? typeParameters.map((decl) => factory.createTypeReferenceNode(
    decl.name,
    /*typeArguments*/
    void 0
  )) : void 0;
  if (isExpression(node) && !isJS) {
    const contextualType = checker.getContextualType(node);
    returnType = checker.typeToTypeNode(contextualType, scope, 1 /* NoTruncation */);
  }
  const { body, returnValueProperty } = transformFunctionBody(node, exposedVariableDeclarations, writes, substitutions, !!(range.facts & 1 /* HasReturn */));
  suppressLeadingAndTrailingTrivia(body);
  let newFunction;
  const callThis = !!(range.facts & 16 /* UsesThisInFunction */);
  if (isClassLike(scope)) {
    const modifiers = isJS ? [] : [factory.createModifier(123 /* PrivateKeyword */)];
    if (range.facts & 32 /* InStaticRegion */) {
      modifiers.push(factory.createModifier(126 /* StaticKeyword */));
    }
    if (range.facts & 4 /* IsAsyncFunction */) {
      modifiers.push(factory.createModifier(134 /* AsyncKeyword */));
    }
    newFunction = factory.createMethodDeclaration(
      modifiers.length ? modifiers : void 0,
      range.facts & 2 /* IsGenerator */ ? factory.createToken(42 /* AsteriskToken */) : void 0,
      functionName,
      /*questionToken*/
      void 0,
      typeParameters,
      parameters,
      returnType,
      body
    );
  } else {
    if (callThis) {
      parameters.unshift(
        factory.createParameterDeclaration(
          /*modifiers*/
          void 0,
          /*dotDotDotToken*/
          void 0,
          /*name*/
          "this",
          /*questionToken*/
          void 0,
          checker.typeToTypeNode(
            checker.getTypeAtLocation(range.thisNode),
            scope,
            1 /* NoTruncation */
          ),
          /*initializer*/
          void 0
        )
      );
    }
    newFunction = factory.createFunctionDeclaration(
      range.facts & 4 /* IsAsyncFunction */ ? [factory.createToken(134 /* AsyncKeyword */)] : void 0,
      range.facts & 2 /* IsGenerator */ ? factory.createToken(42 /* AsteriskToken */) : void 0,
      functionName,
      typeParameters,
      parameters,
      returnType,
      body
    );
  }
  const changeTracker = ts_textChanges_exports.ChangeTracker.fromContext(context);
  const minInsertionPos = (isReadonlyArray(range.range) ? last(range.range) : range.range).end;
  const nodeToInsertBefore = getNodeToInsertFunctionBefore(minInsertionPos, scope);
  if (nodeToInsertBefore) {
    changeTracker.insertNodeBefore(
      context.file,
      nodeToInsertBefore,
      newFunction,
      /*blankLineBetween*/
      true
    );
  } else {
    changeTracker.insertNodeAtEndOfScope(context.file, scope, newFunction);
  }
  importAdder.writeFixes(changeTracker);
  const newNodes = [];
  const called = getCalledExpression(scope, range, functionNameText);
  if (callThis) {
    callArguments.unshift(factory.createIdentifier("this"));
  }
  let call = factory.createCallExpression(
    callThis ? factory.createPropertyAccessExpression(
      called,
      "call"
    ) : called,
    callTypeArguments,
    // Note that no attempt is made to take advantage of type argument inference
    callArguments
  );
  if (range.facts & 2 /* IsGenerator */) {
    call = factory.createYieldExpression(factory.createToken(42 /* AsteriskToken */), call);
  }
  if (range.facts & 4 /* IsAsyncFunction */) {
    call = factory.createAwaitExpression(call);
  }
  if (isInJSXContent(node)) {
    call = factory.createJsxExpression(
      /*dotDotDotToken*/
      void 0,
      call
    );
  }
  if (exposedVariableDeclarations.length && !writes) {
    Debug.assert(!returnValueProperty, "Expected no returnValueProperty");
    Debug.assert(!(range.facts & 1 /* HasReturn */), "Expected RangeFacts.HasReturn flag to be unset");
    if (exposedVariableDeclarations.length === 1) {
      const variableDeclaration = exposedVariableDeclarations[0];
      newNodes.push(factory.createVariableStatement(
        /*modifiers*/
        void 0,
        factory.createVariableDeclarationList(
          [factory.createVariableDeclaration(
            getSynthesizedDeepClone(variableDeclaration.name),
            /*exclamationToken*/
            void 0,
            /*type*/
            getSynthesizedDeepClone(variableDeclaration.type),
            /*initializer*/
            call
          )],
          variableDeclaration.parent.flags
        )
      ));
    } else {
      const bindingElements = [];
      const typeElements = [];
      let commonNodeFlags = exposedVariableDeclarations[0].parent.flags;
      let sawExplicitType = false;
      for (const variableDeclaration of exposedVariableDeclarations) {
        bindingElements.push(factory.createBindingElement(
          /*dotDotDotToken*/
          void 0,
          /*propertyName*/
          void 0,
          /*name*/
          getSynthesizedDeepClone(variableDeclaration.name)
        ));
        const variableType = checker.typeToTypeNode(
          checker.getBaseTypeOfLiteralType(checker.getTypeAtLocation(variableDeclaration)),
          scope,
          1 /* NoTruncation */
        );
        typeElements.push(factory.createPropertySignature(
          /*modifiers*/
          void 0,
          /*name*/
          variableDeclaration.symbol.name,
          /*questionToken*/
          void 0,
          /*type*/
          variableType
        ));
        sawExplicitType = sawExplicitType || variableDeclaration.type !== void 0;
        commonNodeFlags = commonNodeFlags & variableDeclaration.parent.flags;
      }
      const typeLiteral = sawExplicitType ? factory.createTypeLiteralNode(typeElements) : void 0;
      if (typeLiteral) {
        setEmitFlags(typeLiteral, 1 /* SingleLine */);
      }
      newNodes.push(factory.createVariableStatement(
        /*modifiers*/
        void 0,
        factory.createVariableDeclarationList(
          [factory.createVariableDeclaration(
            factory.createObjectBindingPattern(bindingElements),
            /*exclamationToken*/
            void 0,
            /*type*/
            typeLiteral,
            /*initializer*/
            call
          )],
          commonNodeFlags
        )
      ));
    }
  } else if (exposedVariableDeclarations.length || writes) {
    if (exposedVariableDeclarations.length) {
      for (const variableDeclaration of exposedVariableDeclarations) {
        let flags = variableDeclaration.parent.flags;
        if (flags & 2 /* Const */) {
          flags = flags & ~2 /* Const */ | 1 /* Let */;
        }
        newNodes.push(factory.createVariableStatement(
          /*modifiers*/
          void 0,
          factory.createVariableDeclarationList(
            [factory.createVariableDeclaration(
              variableDeclaration.symbol.name,
              /*exclamationToken*/
              void 0,
              getTypeDeepCloneUnionUndefined(variableDeclaration.type)
            )],
            flags
          )
        ));
      }
    }
    if (returnValueProperty) {
      newNodes.push(factory.createVariableStatement(
        /*modifiers*/
        void 0,
        factory.createVariableDeclarationList(
          [factory.createVariableDeclaration(
            returnValueProperty,
            /*exclamationToken*/
            void 0,
            getTypeDeepCloneUnionUndefined(returnType)
          )],
          1 /* Let */
        )
      ));
    }
    const assignments = getPropertyAssignmentsForWritesAndVariableDeclarations(exposedVariableDeclarations, writes);
    if (returnValueProperty) {
      assignments.unshift(factory.createShorthandPropertyAssignment(returnValueProperty));
    }
    if (assignments.length === 1) {
      Debug.assert(!returnValueProperty, "Shouldn't have returnValueProperty here");
      newNodes.push(factory.createExpressionStatement(factory.createAssignment(assignments[0].name, call)));
      if (range.facts & 1 /* HasReturn */) {
        newNodes.push(factory.createReturnStatement());
      }
    } else {
      newNodes.push(factory.createExpressionStatement(factory.createAssignment(factory.createObjectLiteralExpression(assignments), call)));
      if (returnValueProperty) {
        newNodes.push(factory.createReturnStatement(factory.createIdentifier(returnValueProperty)));
      }
    }
  } else {
    if (range.facts & 1 /* HasReturn */) {
      newNodes.push(factory.createReturnStatement(call));
    } else if (isReadonlyArray(range.range)) {
      newNodes.push(factory.createExpressionStatement(call));
    } else {
      newNodes.push(call);
    }
  }
  if (isReadonlyArray(range.range)) {
    changeTracker.replaceNodeRangeWithNodes(context.file, first(range.range), last(range.range), newNodes);
  } else {
    changeTracker.replaceNodeWithNodes(context.file, range.range, newNodes);
  }
  const edits = changeTracker.getChanges();
  const renameRange = isReadonlyArray(range.range) ? first(range.range) : range.range;
  const renameFilename = renameRange.getSourceFile().fileName;
  const renameLocation = getRenameLocation(
    edits,
    renameFilename,
    functionNameText,
    /*preferLastLocation*/
    false
  );
  return { renameFilename, renameLocation, edits };
  function getTypeDeepCloneUnionUndefined(typeNode) {
    if (typeNode === void 0) {
      return void 0;
    }
    const clone2 = getSynthesizedDeepClone(typeNode);
    let withoutParens = clone2;
    while (isParenthesizedTypeNode(withoutParens)) {
      withoutParens = withoutParens.type;
    }
    return isUnionTypeNode(withoutParens) && find(withoutParens.types, (t) => t.kind === 157 /* UndefinedKeyword */) ? clone2 : factory.createUnionTypeNode([clone2, factory.createKeywordTypeNode(157 /* UndefinedKeyword */)]);
  }
}
function extractConstantInScope(node, scope, { substitutions }, rangeFacts, context) {
  const checker = context.program.getTypeChecker();
  const file = scope.getSourceFile();
  const localNameText = getIdentifierForNode(node, scope, checker, file);
  const isJS = isInJSFile(scope);
  let variableType = isJS || !checker.isContextSensitive(node) ? void 0 : checker.typeToTypeNode(checker.getContextualType(node), scope, 1 /* NoTruncation */);
  let initializer = transformConstantInitializer(skipParentheses(node), substitutions);
  ({ variableType, initializer } = transformFunctionInitializerAndType(variableType, initializer));
  suppressLeadingAndTrailingTrivia(initializer);
  const changeTracker = ts_textChanges_exports.ChangeTracker.fromContext(context);
  if (isClassLike(scope)) {
    Debug.assert(!isJS, "Cannot extract to a JS class");
    const modifiers = [];
    modifiers.push(factory.createModifier(123 /* PrivateKeyword */));
    if (rangeFacts & 32 /* InStaticRegion */) {
      modifiers.push(factory.createModifier(126 /* StaticKeyword */));
    }
    modifiers.push(factory.createModifier(148 /* ReadonlyKeyword */));
    const newVariable = factory.createPropertyDeclaration(
      modifiers,
      localNameText,
      /*questionOrExclamationToken*/
      void 0,
      variableType,
      initializer
    );
    let localReference = factory.createPropertyAccessExpression(
      rangeFacts & 32 /* InStaticRegion */ ? factory.createIdentifier(scope.name.getText()) : factory.createThis(),
      factory.createIdentifier(localNameText)
    );
    if (isInJSXContent(node)) {
      localReference = factory.createJsxExpression(
        /*dotDotDotToken*/
        void 0,
        localReference
      );
    }
    const maxInsertionPos = node.pos;
    const nodeToInsertBefore = getNodeToInsertPropertyBefore(maxInsertionPos, scope);
    changeTracker.insertNodeBefore(
      context.file,
      nodeToInsertBefore,
      newVariable,
      /*blankLineBetween*/
      true
    );
    changeTracker.replaceNode(context.file, node, localReference);
  } else {
    const newVariableDeclaration = factory.createVariableDeclaration(
      localNameText,
      /*exclamationToken*/
      void 0,
      variableType,
      initializer
    );
    const oldVariableDeclaration = getContainingVariableDeclarationIfInList(node, scope);
    if (oldVariableDeclaration) {
      changeTracker.insertNodeBefore(context.file, oldVariableDeclaration, newVariableDeclaration);
      const localReference = factory.createIdentifier(localNameText);
      changeTracker.replaceNode(context.file, node, localReference);
    } else if (node.parent.kind === 244 /* ExpressionStatement */ && scope === findAncestor(node, isScope)) {
      const newVariableStatement = factory.createVariableStatement(
        /*modifiers*/
        void 0,
        factory.createVariableDeclarationList([newVariableDeclaration], 2 /* Const */)
      );
      changeTracker.replaceNode(context.file, node.parent, newVariableStatement);
    } else {
      const newVariableStatement = factory.createVariableStatement(
        /*modifiers*/
        void 0,
        factory.createVariableDeclarationList([newVariableDeclaration], 2 /* Const */)
      );
      const nodeToInsertBefore = getNodeToInsertConstantBefore(node, scope);
      if (nodeToInsertBefore.pos === 0) {
        changeTracker.insertNodeAtTopOfFile(
          context.file,
          newVariableStatement,
          /*blankLineBetween*/
          false
        );
      } else {
        changeTracker.insertNodeBefore(
          context.file,
          nodeToInsertBefore,
          newVariableStatement,
          /*blankLineBetween*/
          false
        );
      }
      if (node.parent.kind === 244 /* ExpressionStatement */) {
        changeTracker.delete(context.file, node.parent);
      } else {
        let localReference = factory.createIdentifier(localNameText);
        if (isInJSXContent(node)) {
          localReference = factory.createJsxExpression(
            /*dotDotDotToken*/
            void 0,
            localReference
          );
        }
        changeTracker.replaceNode(context.file, node, localReference);
      }
    }
  }
  const edits = changeTracker.getChanges();
  const renameFilename = node.getSourceFile().fileName;
  const renameLocation = getRenameLocation(
    edits,
    renameFilename,
    localNameText,
    /*preferLastLocation*/
    true
  );
  return { renameFilename, renameLocation, edits };
  function transformFunctionInitializerAndType(variableType2, initializer2) {
    if (variableType2 === void 0) return { variableType: variableType2, initializer: initializer2 };
    if (!isFunctionExpression(initializer2) && !isArrowFunction(initializer2) || !!initializer2.typeParameters) return { variableType: variableType2, initializer: initializer2 };
    const functionType = checker.getTypeAtLocation(node);
    const functionSignature = singleOrUndefined(checker.getSignaturesOfType(functionType, 0 /* Call */));
    if (!functionSignature) return { variableType: variableType2, initializer: initializer2 };
    if (!!functionSignature.getTypeParameters()) return { variableType: variableType2, initializer: initializer2 };
    const parameters = [];
    let hasAny = false;
    for (const p of initializer2.parameters) {
      if (p.type) {
        parameters.push(p);
      } else {
        const paramType = checker.getTypeAtLocation(p);
        if (paramType === checker.getAnyType()) hasAny = true;
        parameters.push(factory.updateParameterDeclaration(p, p.modifiers, p.dotDotDotToken, p.name, p.questionToken, p.type || checker.typeToTypeNode(paramType, scope, 1 /* NoTruncation */), p.initializer));
      }
    }
    if (hasAny) return { variableType: variableType2, initializer: initializer2 };
    variableType2 = void 0;
    if (isArrowFunction(initializer2)) {
      initializer2 = factory.updateArrowFunction(initializer2, canHaveModifiers(node) ? getModifiers(node) : void 0, initializer2.typeParameters, parameters, initializer2.type || checker.typeToTypeNode(functionSignature.getReturnType(), scope, 1 /* NoTruncation */), initializer2.equalsGreaterThanToken, initializer2.body);
    } else {
      if (functionSignature && !!functionSignature.thisParameter) {
        const firstParameter = firstOrUndefined(parameters);
        if (!firstParameter || isIdentifier(firstParameter.name) && firstParameter.name.escapedText !== "this") {
          const thisType = checker.getTypeOfSymbolAtLocation(functionSignature.thisParameter, node);
          parameters.splice(
            0,
            0,
            factory.createParameterDeclaration(
              /*modifiers*/
              void 0,
              /*dotDotDotToken*/
              void 0,
              "this",
              /*questionToken*/
              void 0,
              checker.typeToTypeNode(thisType, scope, 1 /* NoTruncation */)
            )
          );
        }
      }
      initializer2 = factory.updateFunctionExpression(initializer2, canHaveModifiers(node) ? getModifiers(node) : void 0, initializer2.asteriskToken, initializer2.name, initializer2.typeParameters, parameters, initializer2.type || checker.typeToTypeNode(functionSignature.getReturnType(), scope, 1 /* NoTruncation */), initializer2.body);
    }
    return { variableType: variableType2, initializer: initializer2 };
  }
}
function getContainingVariableDeclarationIfInList(node, scope) {
  let prevNode;
  while (node !== void 0 && node !== scope) {
    if (isVariableDeclaration(node) && node.initializer === prevNode && isVariableDeclarationList(node.parent) && node.parent.declarations.length > 1) {
      return node;
    }
    prevNode = node;
    node = node.parent;
  }
}
function getFirstDeclarationBeforePosition(type, position) {
  let firstDeclaration;
  const symbol = type.symbol;
  if (symbol && symbol.declarations) {
    for (const declaration of symbol.declarations) {
      if ((firstDeclaration === void 0 || declaration.pos < firstDeclaration.pos) && declaration.pos < position) {
        firstDeclaration = declaration;
      }
    }
  }
  return firstDeclaration;
}
function compareTypesByDeclarationOrder({ type: type1, declaration: declaration1 }, { type: type2, declaration: declaration2 }) {
  return compareProperties(declaration1, declaration2, "pos", compareValues) || compareStringsCaseSensitive(
    type1.symbol ? type1.symbol.getName() : "",
    type2.symbol ? type2.symbol.getName() : ""
  ) || compareValues(type1.id, type2.id);
}
function getCalledExpression(scope, range, functionNameText) {
  const functionReference = factory.createIdentifier(functionNameText);
  if (isClassLike(scope)) {
    const lhs = range.facts & 32 /* InStaticRegion */ ? factory.createIdentifier(scope.name.text) : factory.createThis();
    return factory.createPropertyAccessExpression(lhs, functionReference);
  } else {
    return functionReference;
  }
}
function transformFunctionBody(body, exposedVariableDeclarations, writes, substitutions, hasReturn2) {
  const hasWritesOrVariableDeclarations = writes !== void 0 || exposedVariableDeclarations.length > 0;
  if (isBlock(body) && !hasWritesOrVariableDeclarations && substitutions.size === 0) {
    return { body: factory.createBlock(
      body.statements,
      /*multiLine*/
      true
    ), returnValueProperty: void 0 };
  }
  let returnValueProperty;
  let ignoreReturns = false;
  const statements = factory.createNodeArray(isBlock(body) ? body.statements.slice(0) : [isStatement(body) ? body : factory.createReturnStatement(skipParentheses(body))]);
  if (hasWritesOrVariableDeclarations || substitutions.size) {
    const rewrittenStatements = visitNodes2(statements, visitor, isStatement).slice();
    if (hasWritesOrVariableDeclarations && !hasReturn2 && isStatement(body)) {
      const assignments = getPropertyAssignmentsForWritesAndVariableDeclarations(exposedVariableDeclarations, writes);
      if (assignments.length === 1) {
        rewrittenStatements.push(factory.createReturnStatement(assignments[0].name));
      } else {
        rewrittenStatements.push(factory.createReturnStatement(factory.createObjectLiteralExpression(assignments)));
      }
    }
    return { body: factory.createBlock(
      rewrittenStatements,
      /*multiLine*/
      true
    ), returnValueProperty };
  } else {
    return { body: factory.createBlock(
      statements,
      /*multiLine*/
      true
    ), returnValueProperty: void 0 };
  }
  function visitor(node) {
    if (!ignoreReturns && isReturnStatement(node) && hasWritesOrVariableDeclarations) {
      const assignments = getPropertyAssignmentsForWritesAndVariableDeclarations(exposedVariableDeclarations, writes);
      if (node.expression) {
        if (!returnValueProperty) {
          returnValueProperty = "__return";
        }
        assignments.unshift(factory.createPropertyAssignment(returnValueProperty, visitNode(node.expression, visitor, isExpression)));
      }
      if (assignments.length === 1) {
        return factory.createReturnStatement(assignments[0].name);
      } else {
        return factory.createReturnStatement(factory.createObjectLiteralExpression(assignments));
      }
    } else {
      const oldIgnoreReturns = ignoreReturns;
      ignoreReturns = ignoreReturns || isFunctionLikeDeclaration(node) || isClassLike(node);
      const substitution = substitutions.get(getNodeId(node).toString());
      const result = substitution ? getSynthesizedDeepClone(substitution) : visitEachChild(
        node,
        visitor,
        /*context*/
        void 0
      );
      ignoreReturns = oldIgnoreReturns;
      return result;
    }
  }
}
function transformConstantInitializer(initializer, substitutions) {
  return substitutions.size ? visitor(initializer) : initializer;
  function visitor(node) {
    const substitution = substitutions.get(getNodeId(node).toString());
    return substitution ? getSynthesizedDeepClone(substitution) : visitEachChild(
      node,
      visitor,
      /*context*/
      void 0
    );
  }
}
function getStatementsOrClassElements(scope) {
  if (isFunctionLikeDeclaration(scope)) {
    const body = scope.body;
    if (isBlock(body)) {
      return body.statements;
    }
  } else if (isModuleBlock(scope) || isSourceFile(scope)) {
    return scope.statements;
  } else if (isClassLike(scope)) {
    return scope.members;
  } else {
    assertType(scope);
  }
  return emptyArray;
}
function getNodeToInsertFunctionBefore(minPos, scope) {
  return find(getStatementsOrClassElements(scope), (child) => child.pos >= minPos && isFunctionLikeDeclaration(child) && !isConstructorDeclaration(child));
}
function getNodeToInsertPropertyBefore(maxPos, scope) {
  const members = scope.members;
  Debug.assert(members.length > 0, "Found no members");
  let prevMember;
  let allProperties = true;
  for (const member of members) {
    if (member.pos > maxPos) {
      return prevMember || members[0];
    }
    if (allProperties && !isPropertyDeclaration(member)) {
      if (prevMember !== void 0) {
        return member;
      }
      allProperties = false;
    }
    prevMember = member;
  }
  if (prevMember === void 0) return Debug.fail();
  return prevMember;
}
function getNodeToInsertConstantBefore(node, scope) {
  Debug.assert(!isClassLike(scope));
  let prevScope;
  for (let curr = node; curr !== scope; curr = curr.parent) {
    if (isScope(curr)) {
      prevScope = curr;
    }
  }
  for (let curr = (prevScope || node).parent; ; curr = curr.parent) {
    if (isBlockLike(curr)) {
      let prevStatement;
      for (const statement of curr.statements) {
        if (statement.pos > node.pos) {
          break;
        }
        prevStatement = statement;
      }
      if (!prevStatement && isCaseClause(curr)) {
        Debug.assert(isSwitchStatement(curr.parent.parent), "Grandparent isn't a switch statement");
        return curr.parent.parent;
      }
      return Debug.checkDefined(prevStatement, "prevStatement failed to get set");
    }
    Debug.assert(curr !== scope, "Didn't encounter a block-like before encountering scope");
  }
}
function getPropertyAssignmentsForWritesAndVariableDeclarations(exposedVariableDeclarations, writes) {
  const variableAssignments = map(exposedVariableDeclarations, (v) => factory.createShorthandPropertyAssignment(v.symbol.name));
  const writeAssignments = map(writes, (w) => factory.createShorthandPropertyAssignment(w.symbol.name));
  return variableAssignments === void 0 ? writeAssignments : writeAssignments === void 0 ? variableAssignments : variableAssignments.concat(writeAssignments);
}
function isReadonlyArray(v) {
  return isArray(v);
}
function getEnclosingTextRange(targetRange, sourceFile) {
  return isReadonlyArray(targetRange.range) ? { pos: first(targetRange.range).getStart(sourceFile), end: last(targetRange.range).getEnd() } : targetRange.range;
}
function collectReadsAndWrites(targetRange, scopes, enclosingTextRange, sourceFile, checker, cancellationToken) {
  const allTypeParameterUsages = /* @__PURE__ */ new Map();
  const usagesPerScope = [];
  const substitutionsPerScope = [];
  const functionErrorsPerScope = [];
  const constantErrorsPerScope = [];
  const visibleDeclarationsInExtractedRange = [];
  const exposedVariableSymbolSet = /* @__PURE__ */ new Map();
  const exposedVariableDeclarations = [];
  let firstExposedNonVariableDeclaration;
  const expression = !isReadonlyArray(targetRange.range) ? targetRange.range : targetRange.range.length === 1 && isExpressionStatement(targetRange.range[0]) ? targetRange.range[0].expression : void 0;
  let expressionDiagnostic;
  if (expression === void 0) {
    const statements = targetRange.range;
    const start = first(statements).getStart();
    const end = last(statements).end;
    expressionDiagnostic = createFileDiagnostic(sourceFile, start, end - start, Messages.expressionExpected);
  } else if (checker.getTypeAtLocation(expression).flags & (16384 /* Void */ | 131072 /* Never */)) {
    expressionDiagnostic = createDiagnosticForNode(expression, Messages.uselessConstantType);
  }
  for (const scope of scopes) {
    usagesPerScope.push({ usages: /* @__PURE__ */ new Map(), typeParameterUsages: /* @__PURE__ */ new Map(), substitutions: /* @__PURE__ */ new Map() });
    substitutionsPerScope.push(/* @__PURE__ */ new Map());
    functionErrorsPerScope.push([]);
    const constantErrors = [];
    if (expressionDiagnostic) {
      constantErrors.push(expressionDiagnostic);
    }
    if (isClassLike(scope) && isInJSFile(scope)) {
      constantErrors.push(createDiagnosticForNode(scope, Messages.cannotExtractToJSClass));
    }
    if (isArrowFunction(scope) && !isBlock(scope.body)) {
      constantErrors.push(createDiagnosticForNode(scope, Messages.cannotExtractToExpressionArrowFunction));
    }
    constantErrorsPerScope.push(constantErrors);
  }
  const seenUsages = /* @__PURE__ */ new Map();
  const target = isReadonlyArray(targetRange.range) ? factory.createBlock(targetRange.range) : targetRange.range;
  const unmodifiedNode = isReadonlyArray(targetRange.range) ? first(targetRange.range) : targetRange.range;
  const inGenericContext = isInGenericContext(unmodifiedNode);
  collectUsages(target);
  if (inGenericContext && !isReadonlyArray(targetRange.range) && !isJsxAttribute(targetRange.range)) {
    const contextualType = checker.getContextualType(targetRange.range);
    recordTypeParameterUsages(contextualType);
  }
  if (allTypeParameterUsages.size > 0) {
    const seenTypeParameterUsages = /* @__PURE__ */ new Map();
    let i = 0;
    for (let curr = unmodifiedNode; curr !== void 0 && i < scopes.length; curr = curr.parent) {
      if (curr === scopes[i]) {
        seenTypeParameterUsages.forEach((typeParameter, id) => {
          usagesPerScope[i].typeParameterUsages.set(id, typeParameter);
        });
        i++;
      }
      if (isDeclarationWithTypeParameters(curr)) {
        for (const typeParameterDecl of getEffectiveTypeParameterDeclarations(curr)) {
          const typeParameter = checker.getTypeAtLocation(typeParameterDecl);
          if (allTypeParameterUsages.has(typeParameter.id.toString())) {
            seenTypeParameterUsages.set(typeParameter.id.toString(), typeParameter);
          }
        }
      }
    }
    Debug.assert(i === scopes.length, "Should have iterated all scopes");
  }
  if (visibleDeclarationsInExtractedRange.length) {
    const containingLexicalScopeOfExtraction = isBlockScope(scopes[0], scopes[0].parent) ? scopes[0] : getEnclosingBlockScopeContainer(scopes[0]);
    forEachChild(containingLexicalScopeOfExtraction, checkForUsedDeclarations);
  }
  for (let i = 0; i < scopes.length; i++) {
    const scopeUsages = usagesPerScope[i];
    if (i > 0 && (scopeUsages.usages.size > 0 || scopeUsages.typeParameterUsages.size > 0)) {
      const errorNode = isReadonlyArray(targetRange.range) ? targetRange.range[0] : targetRange.range;
      constantErrorsPerScope[i].push(createDiagnosticForNode(errorNode, Messages.cannotAccessVariablesFromNestedScopes));
    }
    if (targetRange.facts & 16 /* UsesThisInFunction */ && isClassLike(scopes[i])) {
      functionErrorsPerScope[i].push(createDiagnosticForNode(targetRange.thisNode, Messages.cannotExtractFunctionsContainingThisToMethod));
    }
    let hasWrite = false;
    let readonlyClassPropertyWrite;
    usagesPerScope[i].usages.forEach((value) => {
      if (value.usage === 2 /* Write */) {
        hasWrite = true;
        if (value.symbol.flags & 106500 /* ClassMember */ && value.symbol.valueDeclaration && hasEffectiveModifier(value.symbol.valueDeclaration, 8 /* Readonly */)) {
          readonlyClassPropertyWrite = value.symbol.valueDeclaration;
        }
      }
    });
    Debug.assert(isReadonlyArray(targetRange.range) || exposedVariableDeclarations.length === 0, "No variable declarations expected if something was extracted");
    if (hasWrite && !isReadonlyArray(targetRange.range)) {
      const diag2 = createDiagnosticForNode(targetRange.range, Messages.cannotWriteInExpression);
      functionErrorsPerScope[i].push(diag2);
      constantErrorsPerScope[i].push(diag2);
    } else if (readonlyClassPropertyWrite && i > 0) {
      const diag2 = createDiagnosticForNode(readonlyClassPropertyWrite, Messages.cannotExtractReadonlyPropertyInitializerOutsideConstructor);
      functionErrorsPerScope[i].push(diag2);
      constantErrorsPerScope[i].push(diag2);
    } else if (firstExposedNonVariableDeclaration) {
      const diag2 = createDiagnosticForNode(firstExposedNonVariableDeclaration, Messages.cannotExtractExportedEntity);
      functionErrorsPerScope[i].push(diag2);
      constantErrorsPerScope[i].push(diag2);
    }
  }
  return { target, usagesPerScope, functionErrorsPerScope, constantErrorsPerScope, exposedVariableDeclarations };
  function isInGenericContext(node) {
    return !!findAncestor(node, (n) => isDeclarationWithTypeParameters(n) && getEffectiveTypeParameterDeclarations(n).length !== 0);
  }
  function recordTypeParameterUsages(type) {
    const symbolWalker = checker.getSymbolWalker(() => (cancellationToken.throwIfCancellationRequested(), true));
    const { visitedTypes } = symbolWalker.walkType(type);
    for (const visitedType of visitedTypes) {
      if (visitedType.isTypeParameter()) {
        allTypeParameterUsages.set(visitedType.id.toString(), visitedType);
      }
    }
  }
  function collectUsages(node, valueUsage = 1 /* Read */) {
    if (inGenericContext) {
      const type = checker.getTypeAtLocation(node);
      recordTypeParameterUsages(type);
    }
    if (isDeclaration(node) && node.symbol) {
      visibleDeclarationsInExtractedRange.push(node);
    }
    if (isAssignmentExpression(node)) {
      collectUsages(node.left, 2 /* Write */);
      collectUsages(node.right);
    } else if (isUnaryExpressionWithWrite(node)) {
      collectUsages(node.operand, 2 /* Write */);
    } else if (isPropertyAccessExpression(node) || isElementAccessExpression(node)) {
      forEachChild(node, collectUsages);
    } else if (isIdentifier(node)) {
      if (!node.parent) {
        return;
      }
      if (isQualifiedName(node.parent) && node !== node.parent.left) {
        return;
      }
      if (isPropertyAccessExpression(node.parent) && node !== node.parent.expression) {
        return;
      }
      recordUsage(
        node,
        valueUsage,
        /*isTypeNode*/
        isPartOfTypeNode(node)
      );
    } else {
      forEachChild(node, collectUsages);
    }
  }
  function recordUsage(n, usage, isTypeNode2) {
    const symbolId = recordUsagebySymbol(n, usage, isTypeNode2);
    if (symbolId) {
      for (let i = 0; i < scopes.length; i++) {
        const substitution = substitutionsPerScope[i].get(symbolId);
        if (substitution) {
          usagesPerScope[i].substitutions.set(getNodeId(n).toString(), substitution);
        }
      }
    }
  }
  function recordUsagebySymbol(identifier, usage, isTypeName) {
    const symbol = getSymbolReferencedByIdentifier(identifier);
    if (!symbol) {
      return void 0;
    }
    const symbolId = getSymbolId(symbol).toString();
    const lastUsage = seenUsages.get(symbolId);
    if (lastUsage && lastUsage >= usage) {
      return symbolId;
    }
    seenUsages.set(symbolId, usage);
    if (lastUsage) {
      for (const perScope of usagesPerScope) {
        const prevEntry = perScope.usages.get(identifier.text);
        if (prevEntry) {
          perScope.usages.set(identifier.text, { usage, symbol, node: identifier });
        }
      }
      return symbolId;
    }
    const decls = symbol.getDeclarations();
    const declInFile = decls && find(decls, (d) => d.getSourceFile() === sourceFile);
    if (!declInFile) {
      return void 0;
    }
    if (rangeContainsStartEnd(enclosingTextRange, declInFile.getStart(), declInFile.end)) {
      return void 0;
    }
    if (targetRange.facts & 2 /* IsGenerator */ && usage === 2 /* Write */) {
      const diag2 = createDiagnosticForNode(identifier, Messages.cannotExtractRangeThatContainsWritesToReferencesLocatedOutsideOfTheTargetRangeInGenerators);
      for (const errors of functionErrorsPerScope) {
        errors.push(diag2);
      }
      for (const errors of constantErrorsPerScope) {
        errors.push(diag2);
      }
    }
    for (let i = 0; i < scopes.length; i++) {
      const scope = scopes[i];
      const resolvedSymbol = checker.resolveName(
        symbol.name,
        scope,
        symbol.flags,
        /*excludeGlobals*/
        false
      );
      if (resolvedSymbol === symbol) {
        continue;
      }
      if (!substitutionsPerScope[i].has(symbolId)) {
        const substitution = tryReplaceWithQualifiedNameOrPropertyAccess(symbol.exportSymbol || symbol, scope, isTypeName);
        if (substitution) {
          substitutionsPerScope[i].set(symbolId, substitution);
        } else if (isTypeName) {
          if (!(symbol.flags & 262144 /* TypeParameter */)) {
            const diag2 = createDiagnosticForNode(identifier, Messages.typeWillNotBeVisibleInTheNewScope);
            functionErrorsPerScope[i].push(diag2);
            constantErrorsPerScope[i].push(diag2);
          }
        } else {
          usagesPerScope[i].usages.set(identifier.text, { usage, symbol, node: identifier });
        }
      }
    }
    return symbolId;
  }
  function checkForUsedDeclarations(node) {
    if (node === targetRange.range || isReadonlyArray(targetRange.range) && targetRange.range.includes(node)) {
      return;
    }
    const sym = isIdentifier(node) ? getSymbolReferencedByIdentifier(node) : checker.getSymbolAtLocation(node);
    if (sym) {
      const decl = find(visibleDeclarationsInExtractedRange, (d) => d.symbol === sym);
      if (decl) {
        if (isVariableDeclaration(decl)) {
          const idString = decl.symbol.id.toString();
          if (!exposedVariableSymbolSet.has(idString)) {
            exposedVariableDeclarations.push(decl);
            exposedVariableSymbolSet.set(idString, true);
          }
        } else {
          firstExposedNonVariableDeclaration = firstExposedNonVariableDeclaration || decl;
        }
      }
    }
    forEachChild(node, checkForUsedDeclarations);
  }
  function getSymbolReferencedByIdentifier(identifier) {
    return identifier.parent && isShorthandPropertyAssignment(identifier.parent) && identifier.parent.name === identifier ? checker.getShorthandAssignmentValueSymbol(identifier.parent) : checker.getSymbolAtLocation(identifier);
  }
  function tryReplaceWithQualifiedNameOrPropertyAccess(symbol, scopeDecl, isTypeNode2) {
    if (!symbol) {
      return void 0;
    }
    const decls = symbol.getDeclarations();
    if (decls && decls.some((d) => d.parent === scopeDecl)) {
      return factory.createIdentifier(symbol.name);
    }
    const prefix = tryReplaceWithQualifiedNameOrPropertyAccess(symbol.parent, scopeDecl, isTypeNode2);
    if (prefix === void 0) {
      return void 0;
    }
    return isTypeNode2 ? factory.createQualifiedName(prefix, factory.createIdentifier(symbol.name)) : factory.createPropertyAccessExpression(prefix, symbol.name);
  }
}
function getExtractableParent(node) {
  return findAncestor(node, (node2) => node2.parent && isExtractableExpression(node2) && !isBinaryExpression(node2.parent));
}
function isExtractableExpression(node) {
  const { parent: parent2 } = node;
  switch (parent2.kind) {
    case 306 /* EnumMember */:
      return false;
  }
  switch (node.kind) {
    case 11 /* StringLiteral */:
      return parent2.kind !== 272 /* ImportDeclaration */ && parent2.kind !== 276 /* ImportSpecifier */;
    case 230 /* SpreadElement */:
    case 206 /* ObjectBindingPattern */:
    case 208 /* BindingElement */:
      return false;
    case 80 /* Identifier */:
      return parent2.kind !== 208 /* BindingElement */ && parent2.kind !== 276 /* ImportSpecifier */ && parent2.kind !== 281 /* ExportSpecifier */;
  }
  return true;
}
function isInJSXContent(node) {
  return isStringLiteralJsxAttribute(node) || (isJsxElement(node) || isJsxSelfClosingElement(node) || isJsxFragment(node)) && (isJsxElement(node.parent) || isJsxFragment(node.parent));
}
function isStringLiteralJsxAttribute(node) {
  return isStringLiteral(node) && node.parent && isJsxAttribute(node.parent);
}

// src/services/_namespaces/ts.refactor.generateGetAccessorAndSetAccessor.ts
var ts_refactor_generateGetAccessorAndSetAccessor_exports = {};

// src/services/refactors/generateGetAccessorAndSetAccessor.ts
var actionName = "Generate 'get' and 'set' accessors";
var actionDescription = getLocaleSpecificMessage(Diagnostics.Generate_get_and_set_accessors);
var generateGetSetAction = {
  name: actionName,
  description: actionDescription,
  kind: "refactor.rewrite.property.generateAccessors"
};
registerRefactor(actionName, {
  kinds: [generateGetSetAction.kind],
  getEditsForAction: function getRefactorActionsToGenerateGetAndSetAccessors(context, actionName2) {
    if (!context.endPosition) return void 0;
    const info = ts_codefix_exports.getAccessorConvertiblePropertyAtPosition(context.file, context.program, context.startPosition, context.endPosition);
    Debug.assert(info && !isRefactorErrorInfo(info), "Expected applicable refactor info");
    const edits = ts_codefix_exports.generateAccessorFromProperty(context.file, context.program, context.startPosition, context.endPosition, context, actionName2);
    if (!edits) return void 0;
    const renameFilename = context.file.fileName;
    const nameNeedRename = info.renameAccessor ? info.accessorName : info.fieldName;
    const renameLocationOffset = isIdentifier(nameNeedRename) ? 0 : -1;
    const renameLocation = renameLocationOffset + getRenameLocation(
      edits,
      renameFilename,
      nameNeedRename.text,
      /*preferLastLocation*/
      isParameter(info.declaration)
    );
    return { renameFilename, renameLocation, edits };
  },
  getAvailableActions(context) {
    if (!context.endPosition) return emptyArray;
    const info = ts_codefix_exports.getAccessorConvertiblePropertyAtPosition(context.file, context.program, context.startPosition, context.endPosition, context.triggerReason === "invoked");
    if (!info) return emptyArray;
    if (!isRefactorErrorInfo(info)) {
      return [{
        name: actionName,
        description: actionDescription,
        actions: [generateGetSetAction]
      }];
    }
    if (context.preferences.provideRefactorNotApplicableReason) {
      return [{
        name: actionName,
        description: actionDescription,
        actions: [{ ...generateGetSetAction, notApplicableReason: info.error }]
      }];
    }
    return emptyArray;
  }
});

// src/services/_namespaces/ts.refactor.inferFunctionReturnType.ts
var ts_refactor_inferFunctionReturnType_exports = {};

// src/services/refactors/inferFunctionReturnType.ts
var refactorName13 = "Infer function return type";
var refactorDescription7 = getLocaleSpecificMessage(Diagnostics.Infer_function_return_type);
var inferReturnTypeAction = {
  name: refactorName13,
  description: refactorDescription7,
  kind: "refactor.rewrite.function.returnType"
};
registerRefactor(refactorName13, {
  kinds: [inferReturnTypeAction.kind],
  getEditsForAction: getRefactorEditsToInferReturnType,
  getAvailableActions: getRefactorActionsToInferReturnType
});
function getRefactorEditsToInferReturnType(context) {
  const info = getInfo4(context);
  if (info && !isRefactorErrorInfo(info)) {
    const edits = ts_textChanges_exports.ChangeTracker.with(context, (t) => doChange7(context.file, t, info.declaration, info.returnTypeNode));
    return { renameFilename: void 0, renameLocation: void 0, edits };
  }
  return void 0;
}
function getRefactorActionsToInferReturnType(context) {
  const info = getInfo4(context);
  if (!info) return emptyArray;
  if (!isRefactorErrorInfo(info)) {
    return [{
      name: refactorName13,
      description: refactorDescription7,
      actions: [inferReturnTypeAction]
    }];
  }
  if (context.preferences.provideRefactorNotApplicableReason) {
    return [{
      name: refactorName13,
      description: refactorDescription7,
      actions: [{ ...inferReturnTypeAction, notApplicableReason: info.error }]
    }];
  }
  return emptyArray;
}
function doChange7(sourceFile, changes, declaration, typeNode) {
  const closeParen = findChildOfKind(declaration, 22 /* CloseParenToken */, sourceFile);
  const needParens = isArrowFunction(declaration) && closeParen === void 0;
  const endNode2 = needParens ? first(declaration.parameters) : closeParen;
  if (endNode2) {
    if (needParens) {
      changes.insertNodeBefore(sourceFile, endNode2, factory.createToken(21 /* OpenParenToken */));
      changes.insertNodeAfter(sourceFile, endNode2, factory.createToken(22 /* CloseParenToken */));
    }
    changes.insertNodeAt(sourceFile, endNode2.end, typeNode, { prefix: ": " });
  }
}
function getInfo4(context) {
  if (isInJSFile(context.file) || !refactorKindBeginsWith(inferReturnTypeAction.kind, context.kind)) return;
  const token = getTouchingPropertyName(context.file, context.startPosition);
  const declaration = findAncestor(token, (n) => isBlock(n) || n.parent && isArrowFunction(n.parent) && (n.kind === 39 /* EqualsGreaterThanToken */ || n.parent.body === n) ? "quit" : isConvertibleDeclaration(n));
  if (!declaration || !declaration.body || declaration.type) {
    return { error: getLocaleSpecificMessage(Diagnostics.Return_type_must_be_inferred_from_a_function) };
  }
  const typeChecker = context.program.getTypeChecker();
  const returnType = tryGetReturnType(typeChecker, declaration);
  if (!returnType) {
    return { error: getLocaleSpecificMessage(Diagnostics.Could_not_determine_function_return_type) };
  }
  const returnTypeNode = typeChecker.typeToTypeNode(returnType, declaration, 1 /* NoTruncation */);
  if (returnTypeNode) {
    return { declaration, returnTypeNode };
  }
}
function isConvertibleDeclaration(node) {
  switch (node.kind) {
    case 262 /* FunctionDeclaration */:
    case 218 /* FunctionExpression */:
    case 219 /* ArrowFunction */:
    case 174 /* MethodDeclaration */:
      return true;
    default:
      return false;
  }
}
function tryGetReturnType(typeChecker, node) {
  if (typeChecker.isImplementationOfOverload(node)) {
    const signatures = typeChecker.getTypeAtLocation(node).getCallSignatures();
    if (signatures.length > 1) {
      return typeChecker.getUnionType(mapDefined(signatures, (s) => s.getReturnType()));
    }
  }
  const signature = typeChecker.getSignatureFromDeclaration(node);
  if (signature) {
    return typeChecker.getReturnTypeOfSignature(signature);
  }
}

// src/services/classifier2020.ts
var TokenEncodingConsts = /* @__PURE__ */ ((TokenEncodingConsts2) => {
  TokenEncodingConsts2[TokenEncodingConsts2["typeOffset"] = 8] = "typeOffset";
  TokenEncodingConsts2[TokenEncodingConsts2["modifierMask"] = 255] = "modifierMask";
  return TokenEncodingConsts2;
})(TokenEncodingConsts || {});
var TokenType = /* @__PURE__ */ ((TokenType2) => {
  TokenType2[TokenType2["class"] = 0] = "class";
  TokenType2[TokenType2["enum"] = 1] = "enum";
  TokenType2[TokenType2["interface"] = 2] = "interface";
  TokenType2[TokenType2["namespace"] = 3] = "namespace";
  TokenType2[TokenType2["typeParameter"] = 4] = "typeParameter";
  TokenType2[TokenType2["type"] = 5] = "type";
  TokenType2[TokenType2["parameter"] = 6] = "parameter";
  TokenType2[TokenType2["variable"] = 7] = "variable";
  TokenType2[TokenType2["enumMember"] = 8] = "enumMember";
  TokenType2[TokenType2["property"] = 9] = "property";
  TokenType2[TokenType2["function"] = 10] = "function";
  TokenType2[TokenType2["member"] = 11] = "member";
  return TokenType2;
})(TokenType || {});
var TokenModifier = /* @__PURE__ */ ((TokenModifier2) => {
  TokenModifier2[TokenModifier2["declaration"] = 0] = "declaration";
  TokenModifier2[TokenModifier2["static"] = 1] = "static";
  TokenModifier2[TokenModifier2["async"] = 2] = "async";
  TokenModifier2[TokenModifier2["readonly"] = 3] = "readonly";
  TokenModifier2[TokenModifier2["defaultLibrary"] = 4] = "defaultLibrary";
  TokenModifier2[TokenModifier2["local"] = 5] = "local";
  return TokenModifier2;
})(TokenModifier || {});
function getSemanticClassifications2(program, cancellationToken, sourceFile, span) {
  const classifications = getEncodedSemanticClassifications2(program, cancellationToken, sourceFile, span);
  Debug.assert(classifications.spans.length % 3 === 0);
  const dense = classifications.spans;
  const result = [];
  for (let i = 0; i < dense.length; i += 3) {
    result.push({
      textSpan: createTextSpan(dense[i], dense[i + 1]),
      classificationType: dense[i + 2]
    });
  }
  return result;
}
function getEncodedSemanticClassifications2(program, cancellationToken, sourceFile, span) {
  return {
    spans: getSemanticTokens(program, sourceFile, span, cancellationToken),
    endOfLineState: 0 /* None */
  };
}
function getSemanticTokens(program, sourceFile, span, cancellationToken) {
  const resultTokens = [];
  const collector = (node, typeIdx, modifierSet) => {
    resultTokens.push(node.getStart(sourceFile), node.getWidth(sourceFile), (typeIdx + 1 << 8 /* typeOffset */) + modifierSet);
  };
  if (program && sourceFile) {
    collectTokens(program, sourceFile, span, collector, cancellationToken);
  }
  return resultTokens;
}
function collectTokens(program, sourceFile, span, collector, cancellationToken) {
  const typeChecker = program.getTypeChecker();
  let inJSXElement = false;
  function visit(node) {
    switch (node.kind) {
      case 267 /* ModuleDeclaration */:
      case 263 /* ClassDeclaration */:
      case 264 /* InterfaceDeclaration */:
      case 262 /* FunctionDeclaration */:
      case 231 /* ClassExpression */:
      case 218 /* FunctionExpression */:
      case 219 /* ArrowFunction */:
        cancellationToken.throwIfCancellationRequested();
    }
    if (!node || !textSpanIntersectsWith(span, node.pos, node.getFullWidth()) || node.getFullWidth() === 0) {
      return;
    }
    const prevInJSXElement = inJSXElement;
    if (isJsxElement(node) || isJsxSelfClosingElement(node)) {
      inJSXElement = true;
    }
    if (isJsxExpression(node)) {
      inJSXElement = false;
    }
    if (isIdentifier(node) && !inJSXElement && !inImportClause(node) && !isInfinityOrNaNString(node.escapedText)) {
      let symbol = typeChecker.getSymbolAtLocation(node);
      if (symbol) {
        if (symbol.flags & 2097152 /* Alias */) {
          symbol = typeChecker.getAliasedSymbol(symbol);
        }
        let typeIdx = classifySymbol2(symbol, getMeaningFromLocation(node));
        if (typeIdx !== void 0) {
          let modifierSet = 0;
          if (node.parent) {
            const parentIsDeclaration = isBindingElement(node.parent) || tokenFromDeclarationMapping.get(node.parent.kind) === typeIdx;
            if (parentIsDeclaration && node.parent.name === node) {
              modifierSet = 1 << 0 /* declaration */;
            }
          }
          if (typeIdx === 6 /* parameter */ && isRightSideOfQualifiedNameOrPropertyAccess2(node)) {
            typeIdx = 9 /* property */;
          }
          typeIdx = reclassifyByType(typeChecker, node, typeIdx);
          const decl = symbol.valueDeclaration;
          if (decl) {
            const modifiers = getCombinedModifierFlags(decl);
            const nodeFlags = getCombinedNodeFlags(decl);
            if (modifiers & 256 /* Static */) {
              modifierSet |= 1 << 1 /* static */;
            }
            if (modifiers & 1024 /* Async */) {
              modifierSet |= 1 << 2 /* async */;
            }
            if (typeIdx !== 0 /* class */ && typeIdx !== 2 /* interface */) {
              if (modifiers & 8 /* Readonly */ || nodeFlags & 2 /* Const */ || symbol.getFlags() & 8 /* EnumMember */) {
                modifierSet |= 1 << 3 /* readonly */;
              }
            }
            if ((typeIdx === 7 /* variable */ || typeIdx === 10 /* function */) && isLocalDeclaration(decl, sourceFile)) {
              modifierSet |= 1 << 5 /* local */;
            }
            if (program.isSourceFileDefaultLibrary(decl.getSourceFile())) {
              modifierSet |= 1 << 4 /* defaultLibrary */;
            }
          } else if (symbol.declarations && symbol.declarations.some((d) => program.isSourceFileDefaultLibrary(d.getSourceFile()))) {
            modifierSet |= 1 << 4 /* defaultLibrary */;
          }
          collector(node, typeIdx, modifierSet);
        }
      }
    }
    forEachChild(node, visit);
    inJSXElement = prevInJSXElement;
  }
  visit(sourceFile);
}
function classifySymbol2(symbol, meaning) {
  const flags = symbol.getFlags();
  if (flags & 32 /* Class */) {
    return 0 /* class */;
  } else if (flags & 384 /* Enum */) {
    return 1 /* enum */;
  } else if (flags & 524288 /* TypeAlias */) {
    return 5 /* type */;
  } else if (flags & 64 /* Interface */) {
    if (meaning & 2 /* Type */) {
      return 2 /* interface */;
    }
  } else if (flags & 262144 /* TypeParameter */) {
    return 4 /* typeParameter */;
  }
  let decl = symbol.valueDeclaration || symbol.declarations && symbol.declarations[0];
  if (decl && isBindingElement(decl)) {
    decl = getDeclarationForBindingElement(decl);
  }
  return decl && tokenFromDeclarationMapping.get(decl.kind);
}
function reclassifyByType(typeChecker, node, typeIdx) {
  if (typeIdx === 7 /* variable */ || typeIdx === 9 /* property */ || typeIdx === 6 /* parameter */) {
    const type = typeChecker.getTypeAtLocation(node);
    if (type) {
      const test = (condition) => {
        return condition(type) || type.isUnion() && type.types.some(condition);
      };
      if (typeIdx !== 6 /* parameter */ && test((t) => t.getConstructSignatures().length > 0)) {
        return 0 /* class */;
      }
      if (test((t) => t.getCallSignatures().length > 0) && !test((t) => t.getProperties().length > 0) || isExpressionInCallExpression(node)) {
        return typeIdx === 9 /* property */ ? 11 /* member */ : 10 /* function */;
      }
    }
  }
  return typeIdx;
}
function isLocalDeclaration(decl, sourceFile) {
  if (isBindingElement(decl)) {
    decl = getDeclarationForBindingElement(decl);
  }
  if (isVariableDeclaration(decl)) {
    return (!isSourceFile(decl.parent.parent.parent) || isCatchClause(decl.parent)) && decl.getSourceFile() === sourceFile;
  } else if (isFunctionDeclaration(decl)) {
    return !isSourceFile(decl.parent) && decl.getSourceFile() === sourceFile;
  }
  return false;
}
function getDeclarationForBindingElement(element) {
  while (true) {
    if (isBindingElement(element.parent.parent)) {
      element = element.parent.parent;
    } else {
      return element.parent.parent;
    }
  }
}
function inImportClause(node) {
  const parent2 = node.parent;
  return parent2 && (isImportClause(parent2) || isImportSpecifier(parent2) || isNamespaceImport(parent2));
}
function isExpressionInCallExpression(node) {
  while (isRightSideOfQualifiedNameOrPropertyAccess2(node)) {
    node = node.parent;
  }
  return isCallExpression(node.parent) && node.parent.expression === node;
}
function isRightSideOfQualifiedNameOrPropertyAccess2(node) {
  return isQualifiedName(node.parent) && node.parent.right === node || isPropertyAccessExpression(node.parent) && node.parent.name === node;
}
var tokenFromDeclarationMapping = /* @__PURE__ */ new Map([
  [260 /* VariableDeclaration */, 7 /* variable */],
  [169 /* Parameter */, 6 /* parameter */],
  [172 /* PropertyDeclaration */, 9 /* property */],
  [267 /* ModuleDeclaration */, 3 /* namespace */],
  [266 /* EnumDeclaration */, 1 /* enum */],
  [306 /* EnumMember */, 8 /* enumMember */],
  [263 /* ClassDeclaration */, 0 /* class */],
  [174 /* MethodDeclaration */, 11 /* member */],
  [262 /* FunctionDeclaration */, 10 /* function */],
  [218 /* FunctionExpression */, 10 /* function */],
  [173 /* MethodSignature */, 11 /* member */],
  [177 /* GetAccessor */, 9 /* property */],
  [178 /* SetAccessor */, 9 /* property */],
  [171 /* PropertySignature */, 9 /* property */],
  [264 /* InterfaceDeclaration */, 2 /* interface */],
  [265 /* TypeAliasDeclaration */, 5 /* type */],
  [168 /* TypeParameter */, 4 /* typeParameter */],
  [303 /* PropertyAssignment */, 9 /* property */],
  [304 /* ShorthandPropertyAssignment */, 9 /* property */]
]);

// src/services/services.ts
var servicesVersion = "0.8";
function createNode(kind, pos, end, parent2) {
  const node = isNodeKind(kind) ? new NodeObject(kind, pos, end) : kind === 80 /* Identifier */ ? new IdentifierObject(80 /* Identifier */, pos, end) : kind === 81 /* PrivateIdentifier */ ? new PrivateIdentifierObject(81 /* PrivateIdentifier */, pos, end) : new TokenObject(kind, pos, end);
  node.parent = parent2;
  node.flags = parent2.flags & 101441536 /* ContextFlags */;
  return node;
}
var NodeObject = class {
  constructor(kind, pos, end) {
    this.pos = pos;
    this.end = end;
    this.kind = kind;
    this.id = 0;
    this.flags = 0 /* None */;
    this.modifierFlagsCache = 0 /* None */;
    this.transformFlags = 0 /* None */;
    this.parent = void 0;
    this.original = void 0;
    this.emitNode = void 0;
  }
  assertHasRealPosition(message) {
    Debug.assert(!positionIsSynthesized(this.pos) && !positionIsSynthesized(this.end), message || "Node must have a real position for this operation");
  }
  getSourceFile() {
    return getSourceFileOfNode(this);
  }
  getStart(sourceFile, includeJsDocComment) {
    this.assertHasRealPosition();
    return getTokenPosOfNode(this, sourceFile, includeJsDocComment);
  }
  getFullStart() {
    this.assertHasRealPosition();
    return this.pos;
  }
  getEnd() {
    this.assertHasRealPosition();
    return this.end;
  }
  getWidth(sourceFile) {
    this.assertHasRealPosition();
    return this.getEnd() - this.getStart(sourceFile);
  }
  getFullWidth() {
    this.assertHasRealPosition();
    return this.end - this.pos;
  }
  getLeadingTriviaWidth(sourceFile) {
    this.assertHasRealPosition();
    return this.getStart(sourceFile) - this.pos;
  }
  getFullText(sourceFile) {
    this.assertHasRealPosition();
    return (sourceFile || this.getSourceFile()).text.substring(this.pos, this.end);
  }
  getText(sourceFile) {
    this.assertHasRealPosition();
    if (!sourceFile) {
      sourceFile = this.getSourceFile();
    }
    return sourceFile.text.substring(this.getStart(sourceFile), this.getEnd());
  }
  getChildCount(sourceFile) {
    return this.getChildren(sourceFile).length;
  }
  getChildAt(index, sourceFile) {
    return this.getChildren(sourceFile)[index];
  }
  getChildren(sourceFile) {
    this.assertHasRealPosition("Node without a real position cannot be scanned and thus has no token nodes - use forEachChild and collect the result if that's fine");
    return getNodeChildren(this) ?? setNodeChildren(this, createChildren(this, sourceFile));
  }
  getFirstToken(sourceFile) {
    this.assertHasRealPosition();
    const children = this.getChildren(sourceFile);
    if (!children.length) {
      return void 0;
    }
    const child = find(children, (kid) => kid.kind < 309 /* FirstJSDocNode */ || kid.kind > 351 /* LastJSDocNode */);
    return child.kind < 166 /* FirstNode */ ? child : child.getFirstToken(sourceFile);
  }
  getLastToken(sourceFile) {
    this.assertHasRealPosition();
    const children = this.getChildren(sourceFile);
    const child = lastOrUndefined(children);
    if (!child) {
      return void 0;
    }
    return child.kind < 166 /* FirstNode */ ? child : child.getLastToken(sourceFile);
  }
  forEachChild(cbNode, cbNodeArray) {
    return forEachChild(this, cbNode, cbNodeArray);
  }
};
function createChildren(node, sourceFile) {
  const children = [];
  if (isJSDocCommentContainingNode(node)) {
    node.forEachChild((child) => {
      children.push(child);
    });
    return children;
  }
  scanner.setText((sourceFile || node.getSourceFile()).text);
  let pos = node.pos;
  const processNode = (child) => {
    addSyntheticNodes(children, pos, child.pos, node);
    children.push(child);
    pos = child.end;
  };
  const processNodes = (nodes) => {
    addSyntheticNodes(children, pos, nodes.pos, node);
    children.push(createSyntaxList(nodes, node));
    pos = nodes.end;
  };
  forEach(node.jsDoc, processNode);
  pos = node.pos;
  node.forEachChild(processNode, processNodes);
  addSyntheticNodes(children, pos, node.end, node);
  scanner.setText(void 0);
  return children;
}
function addSyntheticNodes(nodes, pos, end, parent2) {
  scanner.resetTokenState(pos);
  while (pos < end) {
    const token = scanner.scan();
    const textPos = scanner.getTokenEnd();
    if (textPos <= end) {
      if (token === 80 /* Identifier */) {
        if (hasTabstop(parent2)) {
          continue;
        }
        Debug.fail(`Did not expect ${Debug.formatSyntaxKind(parent2.kind)} to have an Identifier in its trivia`);
      }
      nodes.push(createNode(token, pos, textPos, parent2));
    }
    pos = textPos;
    if (token === 1 /* EndOfFileToken */) {
      break;
    }
  }
}
function createSyntaxList(nodes, parent2) {
  const list = createNode(352 /* SyntaxList */, nodes.pos, nodes.end, parent2);
  const children = [];
  let pos = nodes.pos;
  for (const node of nodes) {
    addSyntheticNodes(children, pos, node.pos, parent2);
    children.push(node);
    pos = node.end;
  }
  addSyntheticNodes(children, pos, nodes.end, parent2);
  setNodeChildren(list, children);
  return list;
}
var TokenOrIdentifierObject = class {
  constructor(kind, pos, end) {
    this.pos = pos;
    this.end = end;
    this.kind = kind;
    this.id = 0;
    this.flags = 0 /* None */;
    this.transformFlags = 0 /* None */;
    this.parent = void 0;
    this.emitNode = void 0;
  }
  getSourceFile() {
    return getSourceFileOfNode(this);
  }
  getStart(sourceFile, includeJsDocComment) {
    return getTokenPosOfNode(this, sourceFile, includeJsDocComment);
  }
  getFullStart() {
    return this.pos;
  }
  getEnd() {
    return this.end;
  }
  getWidth(sourceFile) {
    return this.getEnd() - this.getStart(sourceFile);
  }
  getFullWidth() {
    return this.end - this.pos;
  }
  getLeadingTriviaWidth(sourceFile) {
    return this.getStart(sourceFile) - this.pos;
  }
  getFullText(sourceFile) {
    return (sourceFile || this.getSourceFile()).text.substring(this.pos, this.end);
  }
  getText(sourceFile) {
    if (!sourceFile) {
      sourceFile = this.getSourceFile();
    }
    return sourceFile.text.substring(this.getStart(sourceFile), this.getEnd());
  }
  getChildCount() {
    return this.getChildren().length;
  }
  getChildAt(index) {
    return this.getChildren()[index];
  }
  getChildren() {
    return this.kind === 1 /* EndOfFileToken */ ? this.jsDoc || emptyArray : emptyArray;
  }
  getFirstToken() {
    return void 0;
  }
  getLastToken() {
    return void 0;
  }
  forEachChild() {
    return void 0;
  }
};
var SymbolObject = class {
  constructor(flags, name) {
    this.flags = flags;
    this.escapedName = name;
    this.declarations = void 0;
    this.valueDeclaration = void 0;
    this.id = 0;
    this.mergeId = 0;
    this.parent = void 0;
    this.members = void 0;
    this.exports = void 0;
    this.exportSymbol = void 0;
    this.constEnumOnlyModule = void 0;
    this.isReferenced = void 0;
    this.lastAssignmentPos = void 0;
    this.links = void 0;
  }
  getFlags() {
    return this.flags;
  }
  get name() {
    return symbolName(this);
  }
  getEscapedName() {
    return this.escapedName;
  }
  getName() {
    return this.name;
  }
  getDeclarations() {
    return this.declarations;
  }
  getDocumentationComment(checker) {
    if (!this.documentationComment) {
      this.documentationComment = emptyArray;
      if (!this.declarations && isTransientSymbol(this) && this.links.target && isTransientSymbol(this.links.target) && this.links.target.links.tupleLabelDeclaration) {
        const labelDecl = this.links.target.links.tupleLabelDeclaration;
        this.documentationComment = getDocumentationComment([labelDecl], checker);
      } else {
        this.documentationComment = getDocumentationComment(this.declarations, checker);
      }
    }
    return this.documentationComment;
  }
  getContextualDocumentationComment(context, checker) {
    if (context) {
      if (isGetAccessor(context)) {
        if (!this.contextualGetAccessorDocumentationComment) {
          this.contextualGetAccessorDocumentationComment = getDocumentationComment(filter(this.declarations, isGetAccessor), checker);
        }
        if (length(this.contextualGetAccessorDocumentationComment)) {
          return this.contextualGetAccessorDocumentationComment;
        }
      }
      if (isSetAccessor(context)) {
        if (!this.contextualSetAccessorDocumentationComment) {
          this.contextualSetAccessorDocumentationComment = getDocumentationComment(filter(this.declarations, isSetAccessor), checker);
        }
        if (length(this.contextualSetAccessorDocumentationComment)) {
          return this.contextualSetAccessorDocumentationComment;
        }
      }
    }
    return this.getDocumentationComment(checker);
  }
  getJsDocTags(checker) {
    if (this.tags === void 0) {
      this.tags = emptyArray;
      this.tags = getJsDocTagsOfDeclarations(this.declarations, checker);
    }
    return this.tags;
  }
  getContextualJsDocTags(context, checker) {
    if (context) {
      if (isGetAccessor(context)) {
        if (!this.contextualGetAccessorTags) {
          this.contextualGetAccessorTags = getJsDocTagsOfDeclarations(filter(this.declarations, isGetAccessor), checker);
        }
        if (length(this.contextualGetAccessorTags)) {
          return this.contextualGetAccessorTags;
        }
      }
      if (isSetAccessor(context)) {
        if (!this.contextualSetAccessorTags) {
          this.contextualSetAccessorTags = getJsDocTagsOfDeclarations(filter(this.declarations, isSetAccessor), checker);
        }
        if (length(this.contextualSetAccessorTags)) {
          return this.contextualSetAccessorTags;
        }
      }
    }
    return this.getJsDocTags(checker);
  }
};
var TokenObject = class extends TokenOrIdentifierObject {
  constructor(kind, pos, end) {
    super(kind, pos, end);
  }
};
var IdentifierObject = class extends TokenOrIdentifierObject {
  constructor(kind, pos, end) {
    super(kind, pos, end);
  }
  get text() {
    return idText(this);
  }
};
var PrivateIdentifierObject = class extends TokenOrIdentifierObject {
  constructor(kind, pos, end) {
    super(kind, pos, end);
  }
  get text() {
    return idText(this);
  }
};
var TypeObject = class {
  constructor(checker, flags) {
    this.flags = flags;
    this.checker = checker;
  }
  getFlags() {
    return this.flags;
  }
  getSymbol() {
    return this.symbol;
  }
  getProperties() {
    return this.checker.getPropertiesOfType(this);
  }
  getProperty(propertyName) {
    return this.checker.getPropertyOfType(this, propertyName);
  }
  getApparentProperties() {
    return this.checker.getAugmentedPropertiesOfType(this);
  }
  getCallSignatures() {
    return this.checker.getSignaturesOfType(this, 0 /* Call */);
  }
  getConstructSignatures() {
    return this.checker.getSignaturesOfType(this, 1 /* Construct */);
  }
  getStringIndexType() {
    return this.checker.getIndexTypeOfType(this, 0 /* String */);
  }
  getNumberIndexType() {
    return this.checker.getIndexTypeOfType(this, 1 /* Number */);
  }
  getBaseTypes() {
    return this.isClassOrInterface() ? this.checker.getBaseTypes(this) : void 0;
  }
  isNullableType() {
    return this.checker.isNullableType(this);
  }
  getNonNullableType() {
    return this.checker.getNonNullableType(this);
  }
  getNonOptionalType() {
    return this.checker.getNonOptionalType(this);
  }
  getConstraint() {
    return this.checker.getBaseConstraintOfType(this);
  }
  getDefault() {
    return this.checker.getDefaultFromTypeParameter(this);
  }
  isUnion() {
    return !!(this.flags & 1048576 /* Union */);
  }
  isIntersection() {
    return !!(this.flags & 2097152 /* Intersection */);
  }
  isUnionOrIntersection() {
    return !!(this.flags & 3145728 /* UnionOrIntersection */);
  }
  isLiteral() {
    return !!(this.flags & (128 /* StringLiteral */ | 256 /* NumberLiteral */ | 2048 /* BigIntLiteral */));
  }
  isStringLiteral() {
    return !!(this.flags & 128 /* StringLiteral */);
  }
  isNumberLiteral() {
    return !!(this.flags & 256 /* NumberLiteral */);
  }
  isTypeParameter() {
    return !!(this.flags & 262144 /* TypeParameter */);
  }
  isClassOrInterface() {
    return !!(getObjectFlags(this) & 3 /* ClassOrInterface */);
  }
  isClass() {
    return !!(getObjectFlags(this) & 1 /* Class */);
  }
  isIndexType() {
    return !!(this.flags & 4194304 /* Index */);
  }
  /**
   * This polyfills `referenceType.typeArguments` for API consumers
   */
  get typeArguments() {
    if (getObjectFlags(this) & 4 /* Reference */) {
      return this.checker.getTypeArguments(this);
    }
    return void 0;
  }
};
var SignatureObject = class {
  // same
  constructor(checker, flags) {
    this.flags = flags;
    this.checker = checker;
  }
  getDeclaration() {
    return this.declaration;
  }
  getTypeParameters() {
    return this.typeParameters;
  }
  getParameters() {
    return this.parameters;
  }
  getReturnType() {
    return this.checker.getReturnTypeOfSignature(this);
  }
  getTypeParameterAtPosition(pos) {
    const type = this.checker.getParameterType(this, pos);
    if (type.isIndexType() && isThisTypeParameter(type.type)) {
      const constraint = type.type.getConstraint();
      if (constraint) {
        return this.checker.getIndexType(constraint);
      }
    }
    return type;
  }
  getDocumentationComment() {
    return this.documentationComment || (this.documentationComment = getDocumentationComment(singleElementArray(this.declaration), this.checker));
  }
  getJsDocTags() {
    return this.jsDocTags || (this.jsDocTags = getJsDocTagsOfDeclarations(singleElementArray(this.declaration), this.checker));
  }
};
function hasJSDocInheritDocTag(node) {
  return getJSDocTags(node).some((tag) => tag.tagName.text === "inheritDoc" || tag.tagName.text === "inheritdoc");
}
function getJsDocTagsOfDeclarations(declarations, checker) {
  if (!declarations) return emptyArray;
  let tags = ts_JsDoc_exports.getJsDocTagsFromDeclarations(declarations, checker);
  if (checker && (tags.length === 0 || declarations.some(hasJSDocInheritDocTag))) {
    const seenSymbols = /* @__PURE__ */ new Set();
    for (const declaration of declarations) {
      const inheritedTags = findBaseOfDeclaration(checker, declaration, (symbol) => {
        var _a;
        if (!seenSymbols.has(symbol)) {
          seenSymbols.add(symbol);
          if (declaration.kind === 177 /* GetAccessor */ || declaration.kind === 178 /* SetAccessor */) {
            return symbol.getContextualJsDocTags(declaration, checker);
          }
          return ((_a = symbol.declarations) == null ? void 0 : _a.length) === 1 ? symbol.getJsDocTags(checker) : void 0;
        }
      });
      if (inheritedTags) {
        tags = [...inheritedTags, ...tags];
      }
    }
  }
  return tags;
}
function getDocumentationComment(declarations, checker) {
  if (!declarations) return emptyArray;
  let doc = ts_JsDoc_exports.getJsDocCommentsFromDeclarations(declarations, checker);
  if (checker && (doc.length === 0 || declarations.some(hasJSDocInheritDocTag))) {
    const seenSymbols = /* @__PURE__ */ new Set();
    for (const declaration of declarations) {
      const inheritedDocs = findBaseOfDeclaration(checker, declaration, (symbol) => {
        if (!seenSymbols.has(symbol)) {
          seenSymbols.add(symbol);
          if (declaration.kind === 177 /* GetAccessor */ || declaration.kind === 178 /* SetAccessor */) {
            return symbol.getContextualDocumentationComment(declaration, checker);
          }
          return symbol.getDocumentationComment(checker);
        }
      });
      if (inheritedDocs) doc = doc.length === 0 ? inheritedDocs.slice() : inheritedDocs.concat(lineBreakPart(), doc);
    }
  }
  return doc;
}
function findBaseOfDeclaration(checker, declaration, cb) {
  var _a;
  const classOrInterfaceDeclaration = ((_a = declaration.parent) == null ? void 0 : _a.kind) === 176 /* Constructor */ ? declaration.parent.parent : declaration.parent;
  if (!classOrInterfaceDeclaration) return;
  const isStaticMember = hasStaticModifier(declaration);
  return firstDefined(getAllSuperTypeNodes(classOrInterfaceDeclaration), (superTypeNode) => {
    const baseType = checker.getTypeAtLocation(superTypeNode);
    const type = isStaticMember && baseType.symbol ? checker.getTypeOfSymbol(baseType.symbol) : baseType;
    const symbol = checker.getPropertyOfType(type, declaration.symbol.name);
    return symbol ? cb(symbol) : void 0;
  });
}
var SourceFileObject = class extends NodeObject {
  constructor(kind, pos, end) {
    super(kind, pos, end);
  }
  update(newText, textChangeRange) {
    return updateSourceFile(this, newText, textChangeRange);
  }
  getLineAndCharacterOfPosition(position) {
    return getLineAndCharacterOfPosition(this, position);
  }
  getLineStarts() {
    return getLineStarts(this);
  }
  getPositionOfLineAndCharacter(line, character, allowEdits) {
    return computePositionOfLineAndCharacter(getLineStarts(this), line, character, this.text, allowEdits);
  }
  getLineEndOfPosition(pos) {
    const { line } = this.getLineAndCharacterOfPosition(pos);
    const lineStarts = this.getLineStarts();
    let lastCharPos;
    if (line + 1 >= lineStarts.length) {
      lastCharPos = this.getEnd();
    }
    if (!lastCharPos) {
      lastCharPos = lineStarts[line + 1] - 1;
    }
    const fullText = this.getFullText();
    return fullText[lastCharPos] === "\n" && fullText[lastCharPos - 1] === "\r" ? lastCharPos - 1 : lastCharPos;
  }
  getNamedDeclarations() {
    if (!this.namedDeclarations) {
      this.namedDeclarations = this.computeNamedDeclarations();
    }
    return this.namedDeclarations;
  }
  computeNamedDeclarations() {
    const result = createMultiMap();
    this.forEachChild(visit);
    return result;
    function addDeclaration(declaration) {
      const name = getDeclarationName(declaration);
      if (name) {
        result.add(name, declaration);
      }
    }
    function getDeclarations(name) {
      let declarations = result.get(name);
      if (!declarations) {
        result.set(name, declarations = []);
      }
      return declarations;
    }
    function getDeclarationName(declaration) {
      const name = getNonAssignedNameOfDeclaration(declaration);
      return name && (isComputedPropertyName(name) && isPropertyAccessExpression(name.expression) ? name.expression.name.text : isPropertyName(name) ? getNameFromPropertyName(name) : void 0);
    }
    function visit(node) {
      switch (node.kind) {
        case 262 /* FunctionDeclaration */:
        case 218 /* FunctionExpression */:
        case 174 /* MethodDeclaration */:
        case 173 /* MethodSignature */:
          const functionDeclaration = node;
          const declarationName = getDeclarationName(functionDeclaration);
          if (declarationName) {
            const declarations = getDeclarations(declarationName);
            const lastDeclaration = lastOrUndefined(declarations);
            if (lastDeclaration && functionDeclaration.parent === lastDeclaration.parent && functionDeclaration.symbol === lastDeclaration.symbol) {
              if (functionDeclaration.body && !lastDeclaration.body) {
                declarations[declarations.length - 1] = functionDeclaration;
              }
            } else {
              declarations.push(functionDeclaration);
            }
          }
          forEachChild(node, visit);
          break;
        case 263 /* ClassDeclaration */:
        case 231 /* ClassExpression */:
        case 264 /* InterfaceDeclaration */:
        case 265 /* TypeAliasDeclaration */:
        case 266 /* EnumDeclaration */:
        case 267 /* ModuleDeclaration */:
        case 271 /* ImportEqualsDeclaration */:
        case 281 /* ExportSpecifier */:
        case 276 /* ImportSpecifier */:
        case 273 /* ImportClause */:
        case 274 /* NamespaceImport */:
        case 177 /* GetAccessor */:
        case 178 /* SetAccessor */:
        case 187 /* TypeLiteral */:
          addDeclaration(node);
          forEachChild(node, visit);
          break;
        case 169 /* Parameter */:
          if (!hasSyntacticModifier(node, 31 /* ParameterPropertyModifier */)) {
            break;
          }
        case 260 /* VariableDeclaration */:
        case 208 /* BindingElement */: {
          const decl = node;
          if (isBindingPattern(decl.name)) {
            forEachChild(decl.name, visit);
            break;
          }
          if (decl.initializer) {
            visit(decl.initializer);
          }
        }
        case 306 /* EnumMember */:
        case 172 /* PropertyDeclaration */:
        case 171 /* PropertySignature */:
          addDeclaration(node);
          break;
        case 278 /* ExportDeclaration */:
          const exportDeclaration = node;
          if (exportDeclaration.exportClause) {
            if (isNamedExports(exportDeclaration.exportClause)) {
              forEach(exportDeclaration.exportClause.elements, visit);
            } else {
              visit(exportDeclaration.exportClause.name);
            }
          }
          break;
        case 272 /* ImportDeclaration */:
          const importClause = node.importClause;
          if (importClause) {
            if (importClause.name) {
              addDeclaration(importClause.name);
            }
            if (importClause.namedBindings) {
              if (importClause.namedBindings.kind === 274 /* NamespaceImport */) {
                addDeclaration(importClause.namedBindings);
              } else {
                forEach(importClause.namedBindings.elements, visit);
              }
            }
          }
          break;
        case 226 /* BinaryExpression */:
          if (getAssignmentDeclarationKind(node) !== 0 /* None */) {
            addDeclaration(node);
          }
        default:
          forEachChild(node, visit);
      }
    }
  }
};
var SourceMapSourceObject = class {
  constructor(fileName, text, skipTrivia2) {
    this.fileName = fileName;
    this.text = text;
    this.skipTrivia = skipTrivia2 || ((pos) => pos);
  }
  getLineAndCharacterOfPosition(pos) {
    return getLineAndCharacterOfPosition(this, pos);
  }
};
function getServicesObjectAllocator() {
  return {
    getNodeConstructor: () => NodeObject,
    getTokenConstructor: () => TokenObject,
    getIdentifierConstructor: () => IdentifierObject,
    getPrivateIdentifierConstructor: () => PrivateIdentifierObject,
    getSourceFileConstructor: () => SourceFileObject,
    getSymbolConstructor: () => SymbolObject,
    getTypeConstructor: () => TypeObject,
    getSignatureConstructor: () => SignatureObject,
    getSourceMapSourceConstructor: () => SourceMapSourceObject
  };
}
function toEditorSettings(optionsAsMap) {
  let allPropertiesAreCamelCased = true;
  for (const key in optionsAsMap) {
    if (hasProperty(optionsAsMap, key) && !isCamelCase(key)) {
      allPropertiesAreCamelCased = false;
      break;
    }
  }
  if (allPropertiesAreCamelCased) {
    return optionsAsMap;
  }
  const settings = {};
  for (const key in optionsAsMap) {
    if (hasProperty(optionsAsMap, key)) {
      const newKey = isCamelCase(key) ? key : key.charAt(0).toLowerCase() + key.substr(1);
      settings[newKey] = optionsAsMap[key];
    }
  }
  return settings;
}
function isCamelCase(s) {
  return !s.length || s.charAt(0) === s.charAt(0).toLowerCase();
}
function displayPartsToString(displayParts) {
  if (displayParts) {
    return map(displayParts, (displayPart2) => displayPart2.text).join("");
  }
  return "";
}
function getDefaultCompilerOptions2() {
  return {
    target: 1 /* ES5 */,
    jsx: 1 /* Preserve */
  };
}
function getSupportedCodeFixes() {
  return ts_codefix_exports.getSupportedErrorCodes();
}
var SyntaxTreeCache = class {
  constructor(host) {
    this.host = host;
  }
  getCurrentSourceFile(fileName) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const scriptSnapshot = this.host.getScriptSnapshot(fileName);
    if (!scriptSnapshot) {
      throw new Error("Could not find file: '" + fileName + "'.");
    }
    const scriptKind = getScriptKind(fileName, this.host);
    const version2 = this.host.getScriptVersion(fileName);
    let sourceFile;
    if (this.currentFileName !== fileName) {
      const options = {
        languageVersion: 99 /* Latest */,
        impliedNodeFormat: getImpliedNodeFormatForFile(
          toPath(fileName, this.host.getCurrentDirectory(), ((_c = (_b = (_a = this.host).getCompilerHost) == null ? void 0 : _b.call(_a)) == null ? void 0 : _c.getCanonicalFileName) || hostGetCanonicalFileName(this.host)),
          (_h = (_g = (_f = (_e = (_d = this.host).getCompilerHost) == null ? void 0 : _e.call(_d)) == null ? void 0 : _f.getModuleResolutionCache) == null ? void 0 : _g.call(_f)) == null ? void 0 : _h.getPackageJsonInfoCache(),
          this.host,
          this.host.getCompilationSettings()
        ),
        setExternalModuleIndicator: getSetExternalModuleIndicator(this.host.getCompilationSettings()),
        // These files are used to produce syntax-based highlighting, which reads JSDoc, so we must use ParseAll.
        jsDocParsingMode: 0 /* ParseAll */
      };
      sourceFile = createLanguageServiceSourceFile(
        fileName,
        scriptSnapshot,
        options,
        version2,
        /*setNodeParents*/
        true,
        scriptKind
      );
    } else if (this.currentFileVersion !== version2) {
      const editRange = scriptSnapshot.getChangeRange(this.currentFileScriptSnapshot);
      sourceFile = updateLanguageServiceSourceFile(this.currentSourceFile, scriptSnapshot, version2, editRange);
    }
    if (sourceFile) {
      this.currentFileVersion = version2;
      this.currentFileName = fileName;
      this.currentFileScriptSnapshot = scriptSnapshot;
      this.currentSourceFile = sourceFile;
    }
    return this.currentSourceFile;
  }
};
function setSourceFileFields(sourceFile, scriptSnapshot, version2) {
  sourceFile.version = version2;
  sourceFile.scriptSnapshot = scriptSnapshot;
}
function createLanguageServiceSourceFile(fileName, scriptSnapshot, scriptTargetOrOptions, version2, setNodeParents, scriptKind) {
  const sourceFile = createSourceFile(fileName, getSnapshotText(scriptSnapshot), scriptTargetOrOptions, setNodeParents, scriptKind);
  setSourceFileFields(sourceFile, scriptSnapshot, version2);
  return sourceFile;
}
function updateLanguageServiceSourceFile(sourceFile, scriptSnapshot, version2, textChangeRange, aggressiveChecks) {
  if (textChangeRange) {
    if (version2 !== sourceFile.version) {
      let newText;
      const prefix = textChangeRange.span.start !== 0 ? sourceFile.text.substr(0, textChangeRange.span.start) : "";
      const suffix = textSpanEnd(textChangeRange.span) !== sourceFile.text.length ? sourceFile.text.substr(textSpanEnd(textChangeRange.span)) : "";
      if (textChangeRange.newLength === 0) {
        newText = prefix && suffix ? prefix + suffix : prefix || suffix;
      } else {
        const changedText = scriptSnapshot.getText(textChangeRange.span.start, textChangeRange.span.start + textChangeRange.newLength);
        newText = prefix && suffix ? prefix + changedText + suffix : prefix ? prefix + changedText : changedText + suffix;
      }
      const newSourceFile = updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks);
      setSourceFileFields(newSourceFile, scriptSnapshot, version2);
      newSourceFile.nameTable = void 0;
      if (sourceFile !== newSourceFile && sourceFile.scriptSnapshot) {
        if (sourceFile.scriptSnapshot.dispose) {
          sourceFile.scriptSnapshot.dispose();
        }
        sourceFile.scriptSnapshot = void 0;
      }
      return newSourceFile;
    }
  }
  const options = {
    languageVersion: sourceFile.languageVersion,
    impliedNodeFormat: sourceFile.impliedNodeFormat,
    setExternalModuleIndicator: sourceFile.setExternalModuleIndicator,
    jsDocParsingMode: sourceFile.jsDocParsingMode
  };
  return createLanguageServiceSourceFile(
    sourceFile.fileName,
    scriptSnapshot,
    options,
    version2,
    /*setNodeParents*/
    true,
    sourceFile.scriptKind
  );
}
var NoopCancellationToken = {
  isCancellationRequested: returnFalse,
  throwIfCancellationRequested: noop
};
var CancellationTokenObject = class {
  constructor(cancellationToken) {
    this.cancellationToken = cancellationToken;
  }
  isCancellationRequested() {
    return this.cancellationToken.isCancellationRequested();
  }
  throwIfCancellationRequested() {
    var _a;
    if (this.isCancellationRequested()) {
      (_a = tracing) == null ? void 0 : _a.instant(tracing.Phase.Session, "cancellationThrown", { kind: "CancellationTokenObject" });
      throw new OperationCanceledException();
    }
  }
};
var ThrottledCancellationToken = class {
  constructor(hostCancellationToken, throttleWaitMilliseconds = 20) {
    this.hostCancellationToken = hostCancellationToken;
    this.throttleWaitMilliseconds = throttleWaitMilliseconds;
    // Store when we last tried to cancel.  Checking cancellation can be expensive (as we have
    // to marshall over to the host layer).  So we only bother actually checking once enough
    // time has passed.
    this.lastCancellationCheckTime = 0;
  }
  isCancellationRequested() {
    const time = timestamp();
    const duration = Math.abs(time - this.lastCancellationCheckTime);
    if (duration >= this.throttleWaitMilliseconds) {
      this.lastCancellationCheckTime = time;
      return this.hostCancellationToken.isCancellationRequested();
    }
    return false;
  }
  throwIfCancellationRequested() {
    var _a;
    if (this.isCancellationRequested()) {
      (_a = tracing) == null ? void 0 : _a.instant(tracing.Phase.Session, "cancellationThrown", { kind: "ThrottledCancellationToken" });
      throw new OperationCanceledException();
    }
  }
};
var invalidOperationsInPartialSemanticMode = [
  "getSemanticDiagnostics",
  "getSuggestionDiagnostics",
  "getCompilerOptionsDiagnostics",
  "getSemanticClassifications",
  "getEncodedSemanticClassifications",
  "getCodeFixesAtPosition",
  "getCombinedCodeFix",
  "applyCodeActionCommand",
  "organizeImports",
  "getEditsForFileRename",
  "getEmitOutput",
  "getApplicableRefactors",
  "getEditsForRefactor",
  "prepareCallHierarchy",
  "provideCallHierarchyIncomingCalls",
  "provideCallHierarchyOutgoingCalls",
  "provideInlayHints",
  "getSupportedCodeFixes",
  "getPasteEdits"
];
var invalidOperationsInSyntacticMode = [
  ...invalidOperationsInPartialSemanticMode,
  "getCompletionsAtPosition",
  "getCompletionEntryDetails",
  "getCompletionEntrySymbol",
  "getSignatureHelpItems",
  "getQuickInfoAtPosition",
  "getDefinitionAtPosition",
  "getDefinitionAndBoundSpan",
  "getImplementationAtPosition",
  "getTypeDefinitionAtPosition",
  "getReferencesAtPosition",
  "findReferences",
  "getDocumentHighlights",
  "getNavigateToItems",
  "getRenameInfo",
  "findRenameLocations",
  "getApplicableRefactors"
];
function createLanguageService(host, documentRegistry = createDocumentRegistry(host.useCaseSensitiveFileNames && host.useCaseSensitiveFileNames(), host.getCurrentDirectory(), host.jsDocParsingMode), syntaxOnlyOrLanguageServiceMode) {
  var _a;
  let languageServiceMode;
  if (syntaxOnlyOrLanguageServiceMode === void 0) {
    languageServiceMode = 0 /* Semantic */;
  } else if (typeof syntaxOnlyOrLanguageServiceMode === "boolean") {
    languageServiceMode = syntaxOnlyOrLanguageServiceMode ? 2 /* Syntactic */ : 0 /* Semantic */;
  } else {
    languageServiceMode = syntaxOnlyOrLanguageServiceMode;
  }
  const syntaxTreeCache = new SyntaxTreeCache(host);
  let program;
  let lastProjectVersion;
  let lastTypesRootVersion = 0;
  const cancellationToken = host.getCancellationToken ? new CancellationTokenObject(host.getCancellationToken()) : NoopCancellationToken;
  const currentDirectory = host.getCurrentDirectory();
  maybeSetLocalizedDiagnosticMessages((_a = host.getLocalizedDiagnosticMessages) == null ? void 0 : _a.bind(host));
  function log(message) {
    if (host.log) {
      host.log(message);
    }
  }
  const useCaseSensitiveFileNames2 = hostUsesCaseSensitiveFileNames(host);
  const getCanonicalFileName = createGetCanonicalFileName(useCaseSensitiveFileNames2);
  const sourceMapper = getSourceMapper({
    useCaseSensitiveFileNames: () => useCaseSensitiveFileNames2,
    getCurrentDirectory: () => currentDirectory,
    getProgram,
    fileExists: maybeBind(host, host.fileExists),
    readFile: maybeBind(host, host.readFile),
    getDocumentPositionMapper: maybeBind(host, host.getDocumentPositionMapper),
    getSourceFileLike: maybeBind(host, host.getSourceFileLike),
    log
  });
  function getValidSourceFile(fileName) {
    const sourceFile = program.getSourceFile(fileName);
    if (!sourceFile) {
      const error2 = new Error(`Could not find source file: '${fileName}'.`);
      error2.ProgramFiles = program.getSourceFiles().map((f) => f.fileName);
      throw error2;
    }
    return sourceFile;
  }
  function synchronizeHostData() {
    if (host.updateFromProject && !host.updateFromProjectInProgress) {
      host.updateFromProject();
    } else {
      synchronizeHostDataWorker();
    }
  }
  function synchronizeHostDataWorker() {
    var _a2, _b, _c;
    Debug.assert(languageServiceMode !== 2 /* Syntactic */);
    if (host.getProjectVersion) {
      const hostProjectVersion = host.getProjectVersion();
      if (hostProjectVersion) {
        if (lastProjectVersion === hostProjectVersion && !((_a2 = host.hasChangedAutomaticTypeDirectiveNames) == null ? void 0 : _a2.call(host))) {
          return;
        }
        lastProjectVersion = hostProjectVersion;
      }
    }
    const typeRootsVersion = host.getTypeRootsVersion ? host.getTypeRootsVersion() : 0;
    if (lastTypesRootVersion !== typeRootsVersion) {
      log("TypeRoots version has changed; provide new program");
      program = void 0;
      lastTypesRootVersion = typeRootsVersion;
    }
    const rootFileNames = host.getScriptFileNames().slice();
    const newSettings = host.getCompilationSettings() || getDefaultCompilerOptions2();
    const hasInvalidatedResolutions = host.hasInvalidatedResolutions || returnFalse;
    const hasInvalidatedLibResolutions = maybeBind(host, host.hasInvalidatedLibResolutions) || returnFalse;
    const hasChangedAutomaticTypeDirectiveNames = maybeBind(host, host.hasChangedAutomaticTypeDirectiveNames);
    const projectReferences = (_b = host.getProjectReferences) == null ? void 0 : _b.call(host);
    let parsedCommandLines;
    let compilerHost = {
      getSourceFile: getOrCreateSourceFile,
      getSourceFileByPath: getOrCreateSourceFileByPath,
      getCancellationToken: () => cancellationToken,
      getCanonicalFileName,
      useCaseSensitiveFileNames: () => useCaseSensitiveFileNames2,
      getNewLine: () => getNewLineCharacter(newSettings),
      getDefaultLibFileName: (options2) => host.getDefaultLibFileName(options2),
      writeFile: noop,
      getCurrentDirectory: () => currentDirectory,
      fileExists: (fileName) => host.fileExists(fileName),
      readFile: (fileName) => host.readFile && host.readFile(fileName),
      getSymlinkCache: maybeBind(host, host.getSymlinkCache),
      realpath: maybeBind(host, host.realpath),
      directoryExists: (directoryName) => {
        return directoryProbablyExists(directoryName, host);
      },
      getDirectories: (path) => {
        return host.getDirectories ? host.getDirectories(path) : [];
      },
      readDirectory: (path, extensions, exclude, include, depth) => {
        Debug.checkDefined(host.readDirectory, "'LanguageServiceHost.readDirectory' must be implemented to correctly process 'projectReferences'");
        return host.readDirectory(path, extensions, exclude, include, depth);
      },
      onReleaseOldSourceFile,
      onReleaseParsedCommandLine,
      hasInvalidatedResolutions,
      hasInvalidatedLibResolutions,
      hasChangedAutomaticTypeDirectiveNames,
      trace: maybeBind(host, host.trace),
      resolveModuleNames: maybeBind(host, host.resolveModuleNames),
      getModuleResolutionCache: maybeBind(host, host.getModuleResolutionCache),
      createHash: maybeBind(host, host.createHash),
      resolveTypeReferenceDirectives: maybeBind(host, host.resolveTypeReferenceDirectives),
      resolveModuleNameLiterals: maybeBind(host, host.resolveModuleNameLiterals),
      resolveTypeReferenceDirectiveReferences: maybeBind(host, host.resolveTypeReferenceDirectiveReferences),
      resolveLibrary: maybeBind(host, host.resolveLibrary),
      useSourceOfProjectReferenceRedirect: maybeBind(host, host.useSourceOfProjectReferenceRedirect),
      getParsedCommandLine,
      jsDocParsingMode: host.jsDocParsingMode
    };
    const originalGetSourceFile = compilerHost.getSourceFile;
    const { getSourceFileWithCache } = changeCompilerHostLikeToUseCache(
      compilerHost,
      (fileName) => toPath(fileName, currentDirectory, getCanonicalFileName),
      (...args) => originalGetSourceFile.call(compilerHost, ...args)
    );
    compilerHost.getSourceFile = getSourceFileWithCache;
    (_c = host.setCompilerHost) == null ? void 0 : _c.call(host, compilerHost);
    const parseConfigHost = {
      useCaseSensitiveFileNames: useCaseSensitiveFileNames2,
      fileExists: (fileName) => compilerHost.fileExists(fileName),
      readFile: (fileName) => compilerHost.readFile(fileName),
      directoryExists: (f) => compilerHost.directoryExists(f),
      getDirectories: (f) => compilerHost.getDirectories(f),
      realpath: compilerHost.realpath,
      readDirectory: (...args) => compilerHost.readDirectory(...args),
      trace: compilerHost.trace,
      getCurrentDirectory: compilerHost.getCurrentDirectory,
      onUnRecoverableConfigFileDiagnostic: noop
    };
    const documentRegistryBucketKey = documentRegistry.getKeyForCompilationSettings(newSettings);
    let releasedScriptKinds = /* @__PURE__ */ new Set();
    if (isProgramUptoDate(program, rootFileNames, newSettings, (_path, fileName) => host.getScriptVersion(fileName), (fileName) => compilerHost.fileExists(fileName), hasInvalidatedResolutions, hasInvalidatedLibResolutions, hasChangedAutomaticTypeDirectiveNames, getParsedCommandLine, projectReferences)) {
      compilerHost = void 0;
      parsedCommandLines = void 0;
      releasedScriptKinds = void 0;
      return;
    }
    const options = {
      rootNames: rootFileNames,
      options: newSettings,
      host: compilerHost,
      oldProgram: program,
      projectReferences
    };
    program = createProgram(options);
    compilerHost = void 0;
    parsedCommandLines = void 0;
    releasedScriptKinds = void 0;
    sourceMapper.clearCache();
    program.getTypeChecker();
    return;
    function getParsedCommandLine(fileName) {
      const path = toPath(fileName, currentDirectory, getCanonicalFileName);
      const existing = parsedCommandLines == null ? void 0 : parsedCommandLines.get(path);
      if (existing !== void 0) return existing || void 0;
      const result = host.getParsedCommandLine ? host.getParsedCommandLine(fileName) : getParsedCommandLineOfConfigFileUsingSourceFile(fileName);
      (parsedCommandLines || (parsedCommandLines = /* @__PURE__ */ new Map())).set(path, result || false);
      return result;
    }
    function getParsedCommandLineOfConfigFileUsingSourceFile(configFileName) {
      const result = getOrCreateSourceFile(configFileName, 100 /* JSON */);
      if (!result) return void 0;
      result.path = toPath(configFileName, currentDirectory, getCanonicalFileName);
      result.resolvedPath = result.path;
      result.originalFileName = result.fileName;
      return parseJsonSourceFileConfigFileContent(
        result,
        parseConfigHost,
        getNormalizedAbsolutePath(getDirectoryPath(configFileName), currentDirectory),
        /*existingOptions*/
        void 0,
        getNormalizedAbsolutePath(configFileName, currentDirectory)
      );
    }
    function onReleaseParsedCommandLine(configFileName, oldResolvedRef, oldOptions) {
      var _a3;
      if (host.getParsedCommandLine) {
        (_a3 = host.onReleaseParsedCommandLine) == null ? void 0 : _a3.call(host, configFileName, oldResolvedRef, oldOptions);
      } else if (oldResolvedRef) {
        onReleaseOldSourceFile(oldResolvedRef.sourceFile, oldOptions);
      }
    }
    function onReleaseOldSourceFile(oldSourceFile, oldOptions) {
      const oldSettingsKey = documentRegistry.getKeyForCompilationSettings(oldOptions);
      documentRegistry.releaseDocumentWithKey(oldSourceFile.resolvedPath, oldSettingsKey, oldSourceFile.scriptKind, oldSourceFile.impliedNodeFormat);
    }
    function getOrCreateSourceFile(fileName, languageVersionOrOptions, onError, shouldCreateNewSourceFile) {
      return getOrCreateSourceFileByPath(fileName, toPath(fileName, currentDirectory, getCanonicalFileName), languageVersionOrOptions, onError, shouldCreateNewSourceFile);
    }
    function getOrCreateSourceFileByPath(fileName, path, languageVersionOrOptions, _onError, shouldCreateNewSourceFile) {
      Debug.assert(compilerHost, "getOrCreateSourceFileByPath called after typical CompilerHost lifetime, check the callstack something with a reference to an old host.");
      const scriptSnapshot = host.getScriptSnapshot(fileName);
      if (!scriptSnapshot) {
        return void 0;
      }
      const scriptKind = getScriptKind(fileName, host);
      const scriptVersion = host.getScriptVersion(fileName);
      if (!shouldCreateNewSourceFile) {
        const oldSourceFile = program && program.getSourceFileByPath(path);
        if (oldSourceFile) {
          if (scriptKind === oldSourceFile.scriptKind || releasedScriptKinds.has(oldSourceFile.resolvedPath)) {
            return documentRegistry.updateDocumentWithKey(fileName, path, host, documentRegistryBucketKey, scriptSnapshot, scriptVersion, scriptKind, languageVersionOrOptions);
          } else {
            documentRegistry.releaseDocumentWithKey(oldSourceFile.resolvedPath, documentRegistry.getKeyForCompilationSettings(program.getCompilerOptions()), oldSourceFile.scriptKind, oldSourceFile.impliedNodeFormat);
            releasedScriptKinds.add(oldSourceFile.resolvedPath);
          }
        }
      }
      return documentRegistry.acquireDocumentWithKey(fileName, path, host, documentRegistryBucketKey, scriptSnapshot, scriptVersion, scriptKind, languageVersionOrOptions);
    }
  }
  function getProgram() {
    if (languageServiceMode === 2 /* Syntactic */) {
      Debug.assert(program === void 0);
      return void 0;
    }
    synchronizeHostData();
    return program;
  }
  function getAutoImportProvider() {
    var _a2;
    return (_a2 = host.getPackageJsonAutoImportProvider) == null ? void 0 : _a2.call(host);
  }
  function updateIsDefinitionOfReferencedSymbols(referencedSymbols, knownSymbolSpans) {
    const checker = program.getTypeChecker();
    const symbol = getSymbolForProgram();
    if (!symbol) return false;
    for (const referencedSymbol of referencedSymbols) {
      for (const ref of referencedSymbol.references) {
        const refNode = getNodeForSpan(ref);
        Debug.assertIsDefined(refNode);
        if (knownSymbolSpans.has(ref) || ts_FindAllReferences_exports.isDeclarationOfSymbol(refNode, symbol)) {
          knownSymbolSpans.add(ref);
          ref.isDefinition = true;
          const mappedSpan = getMappedDocumentSpan(ref, sourceMapper, maybeBind(host, host.fileExists));
          if (mappedSpan) {
            knownSymbolSpans.add(mappedSpan);
          }
        } else {
          ref.isDefinition = false;
        }
      }
    }
    return true;
    function getSymbolForProgram() {
      for (const referencedSymbol of referencedSymbols) {
        for (const ref of referencedSymbol.references) {
          if (knownSymbolSpans.has(ref)) {
            const refNode = getNodeForSpan(ref);
            Debug.assertIsDefined(refNode);
            return checker.getSymbolAtLocation(refNode);
          }
          const mappedSpan = getMappedDocumentSpan(ref, sourceMapper, maybeBind(host, host.fileExists));
          if (mappedSpan && knownSymbolSpans.has(mappedSpan)) {
            const refNode = getNodeForSpan(mappedSpan);
            if (refNode) {
              return checker.getSymbolAtLocation(refNode);
            }
          }
        }
      }
      return void 0;
    }
    function getNodeForSpan(docSpan) {
      const sourceFile = program.getSourceFile(docSpan.fileName);
      if (!sourceFile) return void 0;
      const rawNode = getTouchingPropertyName(sourceFile, docSpan.textSpan.start);
      const adjustedNode = ts_FindAllReferences_exports.Core.getAdjustedNode(rawNode, { use: ts_FindAllReferences_exports.FindReferencesUse.References });
      return adjustedNode;
    }
  }
  function cleanupSemanticCache() {
    if (program) {
      const key = documentRegistry.getKeyForCompilationSettings(program.getCompilerOptions());
      forEach(program.getSourceFiles(), (f) => documentRegistry.releaseDocumentWithKey(f.resolvedPath, key, f.scriptKind, f.impliedNodeFormat));
      program = void 0;
    }
  }
  function dispose() {
    cleanupSemanticCache();
    host = void 0;
  }
  function getSyntacticDiagnostics(fileName) {
    synchronizeHostData();
    return program.getSyntacticDiagnostics(getValidSourceFile(fileName), cancellationToken).slice();
  }
  function getSemanticDiagnostics(fileName) {
    synchronizeHostData();
    const targetSourceFile = getValidSourceFile(fileName);
    const semanticDiagnostics = program.getSemanticDiagnostics(targetSourceFile, cancellationToken);
    if (!getEmitDeclarations(program.getCompilerOptions())) {
      return semanticDiagnostics.slice();
    }
    const declarationDiagnostics = program.getDeclarationDiagnostics(targetSourceFile, cancellationToken);
    return [...semanticDiagnostics, ...declarationDiagnostics];
  }
  function getSuggestionDiagnostics(fileName) {
    synchronizeHostData();
    return computeSuggestionDiagnostics(getValidSourceFile(fileName), program, cancellationToken);
  }
  function getCompilerOptionsDiagnostics() {
    synchronizeHostData();
    return [...program.getOptionsDiagnostics(cancellationToken), ...program.getGlobalDiagnostics(cancellationToken)];
  }
  function getCompletionsAtPosition2(fileName, position, options = emptyOptions, formattingSettings) {
    const fullPreferences = {
      ...identity(options),
      // avoid excess property check
      includeCompletionsForModuleExports: options.includeCompletionsForModuleExports || options.includeExternalModuleExports,
      includeCompletionsWithInsertText: options.includeCompletionsWithInsertText || options.includeInsertTextCompletions
    };
    synchronizeHostData();
    return ts_Completions_exports.getCompletionsAtPosition(
      host,
      program,
      log,
      getValidSourceFile(fileName),
      position,
      fullPreferences,
      options.triggerCharacter,
      options.triggerKind,
      cancellationToken,
      formattingSettings && ts_formatting_exports.getFormatContext(formattingSettings, host),
      options.includeSymbol
    );
  }
  function getCompletionEntryDetails2(fileName, position, name, formattingOptions, source, preferences = emptyOptions, data) {
    synchronizeHostData();
    return ts_Completions_exports.getCompletionEntryDetails(
      program,
      log,
      getValidSourceFile(fileName),
      position,
      { name, source, data },
      host,
      formattingOptions && ts_formatting_exports.getFormatContext(formattingOptions, host),
      // TODO: GH#18217
      preferences,
      cancellationToken
    );
  }
  function getCompletionEntrySymbol2(fileName, position, name, source, preferences = emptyOptions) {
    synchronizeHostData();
    return ts_Completions_exports.getCompletionEntrySymbol(program, log, getValidSourceFile(fileName), position, { name, source }, host, preferences);
  }
  function getQuickInfoAtPosition(fileName, position) {
    synchronizeHostData();
    const sourceFile = getValidSourceFile(fileName);
    const node = getTouchingPropertyName(sourceFile, position);
    if (node === sourceFile) {
      return void 0;
    }
    const typeChecker = program.getTypeChecker();
    const nodeForQuickInfo = getNodeForQuickInfo(node);
    const symbol = getSymbolAtLocationForQuickInfo(nodeForQuickInfo, typeChecker);
    if (!symbol || typeChecker.isUnknownSymbol(symbol)) {
      const type = shouldGetType(sourceFile, nodeForQuickInfo, position) ? typeChecker.getTypeAtLocation(nodeForQuickInfo) : void 0;
      return type && {
        kind: "" /* unknown */,
        kindModifiers: "" /* none */,
        textSpan: createTextSpanFromNode(nodeForQuickInfo, sourceFile),
        displayParts: typeChecker.runWithCancellationToken(cancellationToken, (typeChecker2) => typeToDisplayParts(typeChecker2, type, getContainerNode(nodeForQuickInfo))),
        documentation: type.symbol ? type.symbol.getDocumentationComment(typeChecker) : void 0,
        tags: type.symbol ? type.symbol.getJsDocTags(typeChecker) : void 0
      };
    }
    const { symbolKind, displayParts, documentation, tags } = typeChecker.runWithCancellationToken(cancellationToken, (typeChecker2) => ts_SymbolDisplay_exports.getSymbolDisplayPartsDocumentationAndSymbolKind(typeChecker2, symbol, sourceFile, getContainerNode(nodeForQuickInfo), nodeForQuickInfo));
    return {
      kind: symbolKind,
      kindModifiers: ts_SymbolDisplay_exports.getSymbolModifiers(typeChecker, symbol),
      textSpan: createTextSpanFromNode(nodeForQuickInfo, sourceFile),
      displayParts,
      documentation,
      tags
    };
  }
  function getPasteEdits(args, formatOptions) {
    synchronizeHostData();
    return ts_PasteEdits_exports.pasteEditsProvider(
      getValidSourceFile(args.targetFile),
      args.pastedText,
      args.pasteLocations,
      args.copiedFrom ? { file: getValidSourceFile(args.copiedFrom.file), range: args.copiedFrom.range } : void 0,
      host,
      args.preferences,
      ts_formatting_exports.getFormatContext(formatOptions, host),
      cancellationToken
    );
  }
  function getNodeForQuickInfo(node) {
    if (isNewExpression(node.parent) && node.pos === node.parent.pos) {
      return node.parent.expression;
    }
    if (isNamedTupleMember(node.parent) && node.pos === node.parent.pos) {
      return node.parent;
    }
    if (isImportMeta(node.parent) && node.parent.name === node) {
      return node.parent;
    }
    if (isJsxNamespacedName(node.parent)) {
      return node.parent;
    }
    return node;
  }
  function shouldGetType(sourceFile, node, position) {
    switch (node.kind) {
      case 80 /* Identifier */:
        if (node.flags & 16777216 /* JSDoc */ && !isInJSFile(node) && (node.parent.kind === 171 /* PropertySignature */ && node.parent.name === node || findAncestor(node, (n) => n.kind === 169 /* Parameter */))) {
          return false;
        }
        return !isLabelName(node) && !isTagName(node) && !isConstTypeReference(node.parent);
      case 211 /* PropertyAccessExpression */:
      case 166 /* QualifiedName */:
        return !isInComment(sourceFile, position);
      case 110 /* ThisKeyword */:
      case 197 /* ThisType */:
      case 108 /* SuperKeyword */:
      case 202 /* NamedTupleMember */:
        return true;
      case 236 /* MetaProperty */:
        return isImportMeta(node);
      default:
        return false;
    }
  }
  function getDefinitionAtPosition2(fileName, position, searchOtherFilesOnly, stopAtAlias) {
    synchronizeHostData();
    return ts_GoToDefinition_exports.getDefinitionAtPosition(program, getValidSourceFile(fileName), position, searchOtherFilesOnly, stopAtAlias);
  }
  function getDefinitionAndBoundSpan2(fileName, position) {
    synchronizeHostData();
    return ts_GoToDefinition_exports.getDefinitionAndBoundSpan(program, getValidSourceFile(fileName), position);
  }
  function getTypeDefinitionAtPosition2(fileName, position) {
    synchronizeHostData();
    return ts_GoToDefinition_exports.getTypeDefinitionAtPosition(program.getTypeChecker(), getValidSourceFile(fileName), position);
  }
  function getImplementationAtPosition(fileName, position) {
    synchronizeHostData();
    return ts_FindAllReferences_exports.getImplementationsAtPosition(program, cancellationToken, program.getSourceFiles(), getValidSourceFile(fileName), position);
  }
  function getDocumentHighlights(fileName, position, filesToSearch) {
    const normalizedFileName = normalizePath(fileName);
    Debug.assert(filesToSearch.some((f) => normalizePath(f) === normalizedFileName));
    synchronizeHostData();
    const sourceFilesToSearch = mapDefined(filesToSearch, (fileName2) => program.getSourceFile(fileName2));
    const sourceFile = getValidSourceFile(fileName);
    return DocumentHighlights.getDocumentHighlights(program, cancellationToken, sourceFile, position, sourceFilesToSearch);
  }
  function findRenameLocations(fileName, position, findInStrings, findInComments, preferences) {
    synchronizeHostData();
    const sourceFile = getValidSourceFile(fileName);
    const node = getAdjustedRenameLocation(getTouchingPropertyName(sourceFile, position));
    if (!ts_Rename_exports.nodeIsEligibleForRename(node)) return void 0;
    if (isIdentifier(node) && (isJsxOpeningElement(node.parent) || isJsxClosingElement(node.parent)) && isIntrinsicJsxName(node.escapedText)) {
      const { openingElement, closingElement } = node.parent.parent;
      return [openingElement, closingElement].map((node2) => {
        const textSpan = createTextSpanFromNode(node2.tagName, sourceFile);
        return {
          fileName: sourceFile.fileName,
          textSpan,
          ...ts_FindAllReferences_exports.toContextSpan(textSpan, sourceFile, node2.parent)
        };
      });
    } else {
      const quotePreference = getQuotePreference(sourceFile, preferences ?? emptyOptions);
      const providePrefixAndSuffixTextForRename = typeof preferences === "boolean" ? preferences : preferences == null ? void 0 : preferences.providePrefixAndSuffixTextForRename;
      return getReferencesWorker2(node, position, { findInStrings, findInComments, providePrefixAndSuffixTextForRename, use: ts_FindAllReferences_exports.FindReferencesUse.Rename }, (entry, originalNode, checker) => ts_FindAllReferences_exports.toRenameLocation(entry, originalNode, checker, providePrefixAndSuffixTextForRename || false, quotePreference));
    }
  }
  function getReferencesAtPosition(fileName, position) {
    synchronizeHostData();
    return getReferencesWorker2(getTouchingPropertyName(getValidSourceFile(fileName), position), position, { use: ts_FindAllReferences_exports.FindReferencesUse.References }, ts_FindAllReferences_exports.toReferenceEntry);
  }
  function getReferencesWorker2(node, position, options, cb) {
    synchronizeHostData();
    const sourceFiles = options && options.use === ts_FindAllReferences_exports.FindReferencesUse.Rename ? program.getSourceFiles().filter((sourceFile) => !program.isSourceFileDefaultLibrary(sourceFile)) : program.getSourceFiles();
    return ts_FindAllReferences_exports.findReferenceOrRenameEntries(program, cancellationToken, sourceFiles, node, position, options, cb);
  }
  function findReferences(fileName, position) {
    synchronizeHostData();
    return ts_FindAllReferences_exports.findReferencedSymbols(program, cancellationToken, program.getSourceFiles(), getValidSourceFile(fileName), position);
  }
  function getFileReferences(fileName) {
    synchronizeHostData();
    return ts_FindAllReferences_exports.Core.getReferencesForFileName(fileName, program, program.getSourceFiles()).map(ts_FindAllReferences_exports.toReferenceEntry);
  }
  function getNavigateToItems2(searchValue, maxResultCount, fileName, excludeDtsFiles = false, excludeLibFiles = false) {
    synchronizeHostData();
    const sourceFiles = fileName ? [getValidSourceFile(fileName)] : program.getSourceFiles();
    return getNavigateToItems(sourceFiles, program.getTypeChecker(), cancellationToken, searchValue, maxResultCount, excludeDtsFiles, excludeLibFiles);
  }
  function getEmitOutput(fileName, emitOnlyDtsFiles, forceDtsEmit) {
    synchronizeHostData();
    const sourceFile = getValidSourceFile(fileName);
    const customTransformers = host.getCustomTransformers && host.getCustomTransformers();
    return getFileEmitOutput(program, sourceFile, !!emitOnlyDtsFiles, cancellationToken, customTransformers, forceDtsEmit);
  }
  function getSignatureHelpItems2(fileName, position, { triggerReason } = emptyOptions) {
    synchronizeHostData();
    const sourceFile = getValidSourceFile(fileName);
    return ts_SignatureHelp_exports.getSignatureHelpItems(program, sourceFile, position, triggerReason, cancellationToken);
  }
  function getNonBoundSourceFile(fileName) {
    return syntaxTreeCache.getCurrentSourceFile(fileName);
  }
  function getNameOrDottedNameSpan(fileName, startPos, _endPos) {
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    const node = getTouchingPropertyName(sourceFile, startPos);
    if (node === sourceFile) {
      return void 0;
    }
    switch (node.kind) {
      case 211 /* PropertyAccessExpression */:
      case 166 /* QualifiedName */:
      case 11 /* StringLiteral */:
      case 97 /* FalseKeyword */:
      case 112 /* TrueKeyword */:
      case 106 /* NullKeyword */:
      case 108 /* SuperKeyword */:
      case 110 /* ThisKeyword */:
      case 197 /* ThisType */:
      case 80 /* Identifier */:
        break;
      default:
        return void 0;
    }
    let nodeForStartPos = node;
    while (true) {
      if (isRightSideOfPropertyAccess(nodeForStartPos) || isRightSideOfQualifiedName(nodeForStartPos)) {
        nodeForStartPos = nodeForStartPos.parent;
      } else if (isNameOfModuleDeclaration(nodeForStartPos)) {
        if (nodeForStartPos.parent.parent.kind === 267 /* ModuleDeclaration */ && nodeForStartPos.parent.parent.body === nodeForStartPos.parent) {
          nodeForStartPos = nodeForStartPos.parent.parent.name;
        } else {
          break;
        }
      } else {
        break;
      }
    }
    return createTextSpanFromBounds(nodeForStartPos.getStart(), node.getEnd());
  }
  function getBreakpointStatementAtPosition(fileName, position) {
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    return ts_BreakpointResolver_exports.spanInSourceFileAtLocation(sourceFile, position);
  }
  function getNavigationBarItems2(fileName) {
    return getNavigationBarItems(syntaxTreeCache.getCurrentSourceFile(fileName), cancellationToken);
  }
  function getNavigationTree2(fileName) {
    return getNavigationTree(syntaxTreeCache.getCurrentSourceFile(fileName), cancellationToken);
  }
  function getSemanticClassifications3(fileName, span, format) {
    synchronizeHostData();
    const responseFormat = format || "original" /* Original */;
    if (responseFormat === "2020" /* TwentyTwenty */) {
      return getSemanticClassifications2(program, cancellationToken, getValidSourceFile(fileName), span);
    } else {
      return getSemanticClassifications(program.getTypeChecker(), cancellationToken, getValidSourceFile(fileName), program.getClassifiableNames(), span);
    }
  }
  function getEncodedSemanticClassifications3(fileName, span, format) {
    synchronizeHostData();
    const responseFormat = format || "original" /* Original */;
    if (responseFormat === "original" /* Original */) {
      return getEncodedSemanticClassifications(program.getTypeChecker(), cancellationToken, getValidSourceFile(fileName), program.getClassifiableNames(), span);
    } else {
      return getEncodedSemanticClassifications2(program, cancellationToken, getValidSourceFile(fileName), span);
    }
  }
  function getSyntacticClassifications2(fileName, span) {
    return getSyntacticClassifications(cancellationToken, syntaxTreeCache.getCurrentSourceFile(fileName), span);
  }
  function getEncodedSyntacticClassifications2(fileName, span) {
    return getEncodedSyntacticClassifications(cancellationToken, syntaxTreeCache.getCurrentSourceFile(fileName), span);
  }
  function getOutliningSpans(fileName) {
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    return ts_OutliningElementsCollector_exports.collectElements(sourceFile, cancellationToken);
  }
  const braceMatching = new Map(Object.entries({
    [19 /* OpenBraceToken */]: 20 /* CloseBraceToken */,
    [21 /* OpenParenToken */]: 22 /* CloseParenToken */,
    [23 /* OpenBracketToken */]: 24 /* CloseBracketToken */,
    [32 /* GreaterThanToken */]: 30 /* LessThanToken */
  }));
  braceMatching.forEach((value, key) => braceMatching.set(value.toString(), Number(key)));
  function getBraceMatchingAtPosition(fileName, position) {
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    const token = getTouchingToken(sourceFile, position);
    const matchKind = token.getStart(sourceFile) === position ? braceMatching.get(token.kind.toString()) : void 0;
    const match = matchKind && findChildOfKind(token.parent, matchKind, sourceFile);
    return match ? [createTextSpanFromNode(token, sourceFile), createTextSpanFromNode(match, sourceFile)].sort((a, b) => a.start - b.start) : emptyArray;
  }
  function getIndentationAtPosition(fileName, position, editorOptions) {
    let start = timestamp();
    const settings = toEditorSettings(editorOptions);
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    log("getIndentationAtPosition: getCurrentSourceFile: " + (timestamp() - start));
    start = timestamp();
    const result = ts_formatting_exports.SmartIndenter.getIndentation(position, sourceFile, settings);
    log("getIndentationAtPosition: computeIndentation  : " + (timestamp() - start));
    return result;
  }
  function getFormattingEditsForRange(fileName, start, end, options) {
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    return ts_formatting_exports.formatSelection(start, end, sourceFile, ts_formatting_exports.getFormatContext(toEditorSettings(options), host));
  }
  function getFormattingEditsForDocument(fileName, options) {
    return ts_formatting_exports.formatDocument(syntaxTreeCache.getCurrentSourceFile(fileName), ts_formatting_exports.getFormatContext(toEditorSettings(options), host));
  }
  function getFormattingEditsAfterKeystroke(fileName, position, key, options) {
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    const formatContext = ts_formatting_exports.getFormatContext(toEditorSettings(options), host);
    if (!isInComment(sourceFile, position)) {
      switch (key) {
        case "{":
          return ts_formatting_exports.formatOnOpeningCurly(position, sourceFile, formatContext);
        case "}":
          return ts_formatting_exports.formatOnClosingCurly(position, sourceFile, formatContext);
        case ";":
          return ts_formatting_exports.formatOnSemicolon(position, sourceFile, formatContext);
        case "\n":
          return ts_formatting_exports.formatOnEnter(position, sourceFile, formatContext);
      }
    }
    return [];
  }
  function getCodeFixesAtPosition(fileName, start, end, errorCodes67, formatOptions, preferences = emptyOptions) {
    synchronizeHostData();
    const sourceFile = getValidSourceFile(fileName);
    const span = createTextSpanFromBounds(start, end);
    const formatContext = ts_formatting_exports.getFormatContext(formatOptions, host);
    return flatMap(deduplicate(errorCodes67, equateValues, compareValues), (errorCode) => {
      cancellationToken.throwIfCancellationRequested();
      return ts_codefix_exports.getFixes({ errorCode, sourceFile, span, program, host, cancellationToken, formatContext, preferences });
    });
  }
  function getCombinedCodeFix(scope, fixId55, formatOptions, preferences = emptyOptions) {
    synchronizeHostData();
    Debug.assert(scope.type === "file");
    const sourceFile = getValidSourceFile(scope.fileName);
    const formatContext = ts_formatting_exports.getFormatContext(formatOptions, host);
    return ts_codefix_exports.getAllFixes({ fixId: fixId55, sourceFile, program, host, cancellationToken, formatContext, preferences });
  }
  function organizeImports2(args, formatOptions, preferences = emptyOptions) {
    synchronizeHostData();
    Debug.assert(args.type === "file");
    const sourceFile = getValidSourceFile(args.fileName);
    const formatContext = ts_formatting_exports.getFormatContext(formatOptions, host);
    const mode = args.mode ?? (args.skipDestructiveCodeActions ? "SortAndCombine" /* SortAndCombine */ : "All" /* All */);
    return ts_OrganizeImports_exports.organizeImports(sourceFile, formatContext, host, program, preferences, mode);
  }
  function getEditsForFileRename2(oldFilePath, newFilePath, formatOptions, preferences = emptyOptions) {
    return getEditsForFileRename(getProgram(), oldFilePath, newFilePath, host, ts_formatting_exports.getFormatContext(formatOptions, host), preferences, sourceMapper);
  }
  function applyCodeActionCommand(fileName, actionOrFormatSettingsOrUndefined) {
    const action = typeof fileName === "string" ? actionOrFormatSettingsOrUndefined : fileName;
    return isArray(action) ? Promise.all(action.map((a) => applySingleCodeActionCommand(a))) : applySingleCodeActionCommand(action);
  }
  function applySingleCodeActionCommand(action) {
    const getPath = (path) => toPath(path, currentDirectory, getCanonicalFileName);
    Debug.assertEqual(action.type, "install package");
    return host.installPackage ? host.installPackage({ fileName: getPath(action.file), packageName: action.packageName }) : Promise.reject("Host does not implement `installPackage`");
  }
  function getDocCommentTemplateAtPosition2(fileName, position, options, formatOptions) {
    const formatSettings = formatOptions ? ts_formatting_exports.getFormatContext(formatOptions, host).options : void 0;
    return ts_JsDoc_exports.getDocCommentTemplateAtPosition(getNewLineOrDefaultFromHost(host, formatSettings), syntaxTreeCache.getCurrentSourceFile(fileName), position, options);
  }
  function isValidBraceCompletionAtPosition(fileName, position, openingBrace) {
    if (openingBrace === 60 /* lessThan */) {
      return false;
    }
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    if (isInString(sourceFile, position)) {
      return false;
    }
    if (isInsideJsxElementOrAttribute(sourceFile, position)) {
      return openingBrace === 123 /* openBrace */;
    }
    if (isInTemplateString(sourceFile, position)) {
      return false;
    }
    switch (openingBrace) {
      case 39 /* singleQuote */:
      case 34 /* doubleQuote */:
      case 96 /* backtick */:
        return !isInComment(sourceFile, position);
    }
    return true;
  }
  function getJsxClosingTagAtPosition(fileName, position) {
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    const token = findPrecedingToken(position, sourceFile);
    if (!token) return void 0;
    const element = token.kind === 32 /* GreaterThanToken */ && isJsxOpeningElement(token.parent) ? token.parent.parent : isJsxText(token) && isJsxElement(token.parent) ? token.parent : void 0;
    if (element && isUnclosedTag(element)) {
      return { newText: `</${element.openingElement.tagName.getText(sourceFile)}>` };
    }
    const fragment = token.kind === 32 /* GreaterThanToken */ && isJsxOpeningFragment(token.parent) ? token.parent.parent : isJsxText(token) && isJsxFragment(token.parent) ? token.parent : void 0;
    if (fragment && isUnclosedFragment(fragment)) {
      return { newText: "</>" };
    }
  }
  function getLinkedEditingRangeAtPosition(fileName, position) {
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    const token = findPrecedingToken(position, sourceFile);
    if (!token || token.parent.kind === 307 /* SourceFile */) return void 0;
    const jsxTagWordPattern = "[a-zA-Z0-9:\\-\\._$]*";
    if (isJsxFragment(token.parent.parent)) {
      const openFragment = token.parent.parent.openingFragment;
      const closeFragment = token.parent.parent.closingFragment;
      if (containsParseError(openFragment) || containsParseError(closeFragment)) return void 0;
      const openPos = openFragment.getStart(sourceFile) + 1;
      const closePos = closeFragment.getStart(sourceFile) + 2;
      if (position !== openPos && position !== closePos) return void 0;
      return {
        ranges: [{ start: openPos, length: 0 }, { start: closePos, length: 0 }],
        wordPattern: jsxTagWordPattern
      };
    } else {
      const tag = findAncestor(token.parent, (n) => {
        if (isJsxOpeningElement(n) || isJsxClosingElement(n)) {
          return true;
        }
        return false;
      });
      if (!tag) return void 0;
      Debug.assert(isJsxOpeningElement(tag) || isJsxClosingElement(tag), "tag should be opening or closing element");
      const openTag = tag.parent.openingElement;
      const closeTag = tag.parent.closingElement;
      const openTagNameStart = openTag.tagName.getStart(sourceFile);
      const openTagNameEnd = openTag.tagName.end;
      const closeTagNameStart = closeTag.tagName.getStart(sourceFile);
      const closeTagNameEnd = closeTag.tagName.end;
      if (openTagNameStart === openTag.getStart(sourceFile) || closeTagNameStart === closeTag.getStart(sourceFile) || openTagNameEnd === openTag.getEnd() || closeTagNameEnd === closeTag.getEnd()) return void 0;
      if (!(openTagNameStart <= position && position <= openTagNameEnd || closeTagNameStart <= position && position <= closeTagNameEnd)) return void 0;
      const openingTagText = openTag.tagName.getText(sourceFile);
      if (openingTagText !== closeTag.tagName.getText(sourceFile)) return void 0;
      return {
        ranges: [{ start: openTagNameStart, length: openTagNameEnd - openTagNameStart }, { start: closeTagNameStart, length: closeTagNameEnd - closeTagNameStart }],
        wordPattern: jsxTagWordPattern
      };
    }
  }
  function getLinesForRange(sourceFile, textRange) {
    return {
      lineStarts: sourceFile.getLineStarts(),
      firstLine: sourceFile.getLineAndCharacterOfPosition(textRange.pos).line,
      lastLine: sourceFile.getLineAndCharacterOfPosition(textRange.end).line
    };
  }
  function toggleLineComment(fileName, textRange, insertComment) {
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    const textChanges2 = [];
    const { lineStarts, firstLine, lastLine } = getLinesForRange(sourceFile, textRange);
    let isCommenting = insertComment || false;
    let leftMostPosition = Number.MAX_VALUE;
    const lineTextStarts = /* @__PURE__ */ new Map();
    const firstNonWhitespaceCharacterRegex = new RegExp(/\S/);
    const isJsx = isInsideJsxElement(sourceFile, lineStarts[firstLine]);
    const openComment = isJsx ? "{/*" : "//";
    for (let i = firstLine; i <= lastLine; i++) {
      const lineText = sourceFile.text.substring(lineStarts[i], sourceFile.getLineEndOfPosition(lineStarts[i]));
      const regExec = firstNonWhitespaceCharacterRegex.exec(lineText);
      if (regExec) {
        leftMostPosition = Math.min(leftMostPosition, regExec.index);
        lineTextStarts.set(i.toString(), regExec.index);
        if (lineText.substr(regExec.index, openComment.length) !== openComment) {
          isCommenting = insertComment === void 0 || insertComment;
        }
      }
    }
    for (let i = firstLine; i <= lastLine; i++) {
      if (firstLine !== lastLine && lineStarts[i] === textRange.end) {
        continue;
      }
      const lineTextStart = lineTextStarts.get(i.toString());
      if (lineTextStart !== void 0) {
        if (isJsx) {
          textChanges2.push(...toggleMultilineComment(fileName, { pos: lineStarts[i] + leftMostPosition, end: sourceFile.getLineEndOfPosition(lineStarts[i]) }, isCommenting, isJsx));
        } else if (isCommenting) {
          textChanges2.push({
            newText: openComment,
            span: {
              length: 0,
              start: lineStarts[i] + leftMostPosition
            }
          });
        } else if (sourceFile.text.substr(lineStarts[i] + lineTextStart, openComment.length) === openComment) {
          textChanges2.push({
            newText: "",
            span: {
              length: openComment.length,
              start: lineStarts[i] + lineTextStart
            }
          });
        }
      }
    }
    return textChanges2;
  }
  function toggleMultilineComment(fileName, textRange, insertComment, isInsideJsx) {
    var _a2;
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    const textChanges2 = [];
    const { text } = sourceFile;
    let hasComment = false;
    let isCommenting = insertComment || false;
    const positions = [];
    let { pos } = textRange;
    const isJsx = isInsideJsx !== void 0 ? isInsideJsx : isInsideJsxElement(sourceFile, pos);
    const openMultiline = isJsx ? "{/*" : "/*";
    const closeMultiline = isJsx ? "*/}" : "*/";
    const openMultilineRegex = isJsx ? "\\{\\/\\*" : "\\/\\*";
    const closeMultilineRegex = isJsx ? "\\*\\/\\}" : "\\*\\/";
    while (pos <= textRange.end) {
      const offset = text.substr(pos, openMultiline.length) === openMultiline ? openMultiline.length : 0;
      const commentRange = isInComment(sourceFile, pos + offset);
      if (commentRange) {
        if (isJsx) {
          commentRange.pos--;
          commentRange.end++;
        }
        positions.push(commentRange.pos);
        if (commentRange.kind === 3 /* MultiLineCommentTrivia */) {
          positions.push(commentRange.end);
        }
        hasComment = true;
        pos = commentRange.end + 1;
      } else {
        const newPos = text.substring(pos, textRange.end).search(`(${openMultilineRegex})|(${closeMultilineRegex})`);
        isCommenting = insertComment !== void 0 ? insertComment : isCommenting || !isTextWhiteSpaceLike(text, pos, newPos === -1 ? textRange.end : pos + newPos);
        pos = newPos === -1 ? textRange.end + 1 : pos + newPos + closeMultiline.length;
      }
    }
    if (isCommenting || !hasComment) {
      if (((_a2 = isInComment(sourceFile, textRange.pos)) == null ? void 0 : _a2.kind) !== 2 /* SingleLineCommentTrivia */) {
        insertSorted(positions, textRange.pos, compareValues);
      }
      insertSorted(positions, textRange.end, compareValues);
      const firstPos = positions[0];
      if (text.substr(firstPos, openMultiline.length) !== openMultiline) {
        textChanges2.push({
          newText: openMultiline,
          span: {
            length: 0,
            start: firstPos
          }
        });
      }
      for (let i = 1; i < positions.length - 1; i++) {
        if (text.substr(positions[i] - closeMultiline.length, closeMultiline.length) !== closeMultiline) {
          textChanges2.push({
            newText: closeMultiline,
            span: {
              length: 0,
              start: positions[i]
            }
          });
        }
        if (text.substr(positions[i], openMultiline.length) !== openMultiline) {
          textChanges2.push({
            newText: openMultiline,
            span: {
              length: 0,
              start: positions[i]
            }
          });
        }
      }
      if (textChanges2.length % 2 !== 0) {
        textChanges2.push({
          newText: closeMultiline,
          span: {
            length: 0,
            start: positions[positions.length - 1]
          }
        });
      }
    } else {
      for (const pos2 of positions) {
        const from = pos2 - closeMultiline.length > 0 ? pos2 - closeMultiline.length : 0;
        const offset = text.substr(from, closeMultiline.length) === closeMultiline ? closeMultiline.length : 0;
        textChanges2.push({
          newText: "",
          span: {
            length: openMultiline.length,
            start: pos2 - offset
          }
        });
      }
    }
    return textChanges2;
  }
  function commentSelection(fileName, textRange) {
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    const { firstLine, lastLine } = getLinesForRange(sourceFile, textRange);
    return firstLine === lastLine && textRange.pos !== textRange.end ? toggleMultilineComment(
      fileName,
      textRange,
      /*insertComment*/
      true
    ) : toggleLineComment(
      fileName,
      textRange,
      /*insertComment*/
      true
    );
  }
  function uncommentSelection(fileName, textRange) {
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    const textChanges2 = [];
    const { pos } = textRange;
    let { end } = textRange;
    if (pos === end) {
      end += isInsideJsxElement(sourceFile, pos) ? 2 : 1;
    }
    for (let i = pos; i <= end; i++) {
      const commentRange = isInComment(sourceFile, i);
      if (commentRange) {
        switch (commentRange.kind) {
          case 2 /* SingleLineCommentTrivia */:
            textChanges2.push(...toggleLineComment(
              fileName,
              { end: commentRange.end, pos: commentRange.pos + 1 },
              /*insertComment*/
              false
            ));
            break;
          case 3 /* MultiLineCommentTrivia */:
            textChanges2.push(...toggleMultilineComment(
              fileName,
              { end: commentRange.end, pos: commentRange.pos + 1 },
              /*insertComment*/
              false
            ));
        }
        i = commentRange.end + 1;
      }
    }
    return textChanges2;
  }
  function isUnclosedTag({ openingElement, closingElement, parent: parent2 }) {
    return !tagNamesAreEquivalent(openingElement.tagName, closingElement.tagName) || isJsxElement(parent2) && tagNamesAreEquivalent(openingElement.tagName, parent2.openingElement.tagName) && isUnclosedTag(parent2);
  }
  function isUnclosedFragment({ closingFragment, parent: parent2 }) {
    return !!(closingFragment.flags & 262144 /* ThisNodeHasError */) || isJsxFragment(parent2) && isUnclosedFragment(parent2);
  }
  function getSpanOfEnclosingComment(fileName, position, onlyMultiLine) {
    const sourceFile = syntaxTreeCache.getCurrentSourceFile(fileName);
    const range = ts_formatting_exports.getRangeOfEnclosingComment(sourceFile, position);
    return range && (!onlyMultiLine || range.kind === 3 /* MultiLineCommentTrivia */) ? createTextSpanFromRange(range) : void 0;
  }
  function getTodoComments(fileName, descriptors) {
    synchronizeHostData();
    const sourceFile = getValidSourceFile(fileName);
    cancellationToken.throwIfCancellationRequested();
    const fileContents = sourceFile.text;
    const result = [];
    if (descriptors.length > 0 && !isNodeModulesFile(sourceFile.fileName)) {
      const regExp = getTodoCommentsRegExp();
      let matchArray;
      while (matchArray = regExp.exec(fileContents)) {
        cancellationToken.throwIfCancellationRequested();
        const firstDescriptorCaptureIndex = 3;
        Debug.assert(matchArray.length === descriptors.length + firstDescriptorCaptureIndex);
        const preamble = matchArray[1];
        const matchPosition = matchArray.index + preamble.length;
        if (!isInComment(sourceFile, matchPosition)) {
          continue;
        }
        let descriptor;
        for (let i = 0; i < descriptors.length; i++) {
          if (matchArray[i + firstDescriptorCaptureIndex]) {
            descriptor = descriptors[i];
          }
        }
        if (descriptor === void 0) return Debug.fail();
        if (isLetterOrDigit(fileContents.charCodeAt(matchPosition + descriptor.text.length))) {
          continue;
        }
        const message = matchArray[2];
        result.push({ descriptor, message, position: matchPosition });
      }
    }
    return result;
    function escapeRegExp(str) {
      return str.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
    }
    function getTodoCommentsRegExp() {
      const singleLineCommentStart = /(?:\/\/+\s*)/.source;
      const multiLineCommentStart = /(?:\/\*+\s*)/.source;
      const anyNumberOfSpacesAndAsterisksAtStartOfLine = /(?:^(?:\s|\*)*)/.source;
      const preamble = "(" + anyNumberOfSpacesAndAsterisksAtStartOfLine + "|" + singleLineCommentStart + "|" + multiLineCommentStart + ")";
      const literals = "(?:" + map(descriptors, (d) => "(" + escapeRegExp(d.text) + ")").join("|") + ")";
      const endOfLineOrEndOfComment = /(?:$|\*\/)/.source;
      const messageRemainder = /(?:.*?)/.source;
      const messagePortion = "(" + literals + messageRemainder + ")";
      const regExpString = preamble + messagePortion + endOfLineOrEndOfComment;
      return new RegExp(regExpString, "gim");
    }
    function isLetterOrDigit(char) {
      return char >= 97 /* a */ && char <= 122 /* z */ || char >= 65 /* A */ && char <= 90 /* Z */ || char >= 48 /* _0 */ && char <= 57 /* _9 */;
    }
    function isNodeModulesFile(path) {
      return path.includes("/node_modules/");
    }
  }
  function getRenameInfo2(fileName, position, preferences) {
    synchronizeHostData();
    return ts_Rename_exports.getRenameInfo(program, getValidSourceFile(fileName), position, preferences || {});
  }
  function getRefactorContext(file, positionOrRange, preferences, formatOptions, triggerReason, kind) {
    const [startPosition, endPosition] = typeof positionOrRange === "number" ? [positionOrRange, void 0] : [positionOrRange.pos, positionOrRange.end];
    return {
      file,
      startPosition,
      endPosition,
      program: getProgram(),
      host,
      formatContext: ts_formatting_exports.getFormatContext(formatOptions, host),
      // TODO: GH#18217
      cancellationToken,
      preferences,
      triggerReason,
      kind
    };
  }
  function getInlayHintsContext(file, span, preferences) {
    return {
      file,
      program: getProgram(),
      host,
      span,
      preferences,
      cancellationToken
    };
  }
  function getSmartSelectionRange2(fileName, position) {
    return ts_SmartSelectionRange_exports.getSmartSelectionRange(position, syntaxTreeCache.getCurrentSourceFile(fileName));
  }
  function getApplicableRefactors2(fileName, positionOrRange, preferences = emptyOptions, triggerReason, kind, includeInteractiveActions) {
    synchronizeHostData();
    const file = getValidSourceFile(fileName);
    return ts_refactor_exports.getApplicableRefactors(getRefactorContext(file, positionOrRange, preferences, emptyOptions, triggerReason, kind), includeInteractiveActions);
  }
  function getMoveToRefactoringFileSuggestions(fileName, positionOrRange, preferences = emptyOptions) {
    synchronizeHostData();
    const sourceFile = getValidSourceFile(fileName);
    const allFiles = Debug.checkDefined(program.getSourceFiles());
    const extension = extensionFromPath(fileName);
    const toMove = getStatementsToMove(getRefactorContext(sourceFile, positionOrRange, preferences, emptyOptions));
    const toMoveContainsJsx = containsJsx(toMove == null ? void 0 : toMove.all);
    const files = mapDefined(allFiles, (file) => {
      const fileNameExtension = extensionFromPath(file.fileName);
      const isValidSourceFile = !(program == null ? void 0 : program.isSourceFileFromExternalLibrary(sourceFile)) && !(sourceFile === getValidSourceFile(file.fileName) || extension === ".ts" /* Ts */ && fileNameExtension === ".d.ts" /* Dts */ || extension === ".d.ts" /* Dts */ && startsWith(getBaseFileName(file.fileName), "lib.") && fileNameExtension === ".d.ts" /* Dts */);
      return isValidSourceFile && (extension === fileNameExtension || (extension === ".tsx" /* Tsx */ && fileNameExtension === ".ts" /* Ts */ || extension === ".jsx" /* Jsx */ && fileNameExtension === ".js" /* Js */) && !toMoveContainsJsx) ? file.fileName : void 0;
    });
    return { newFileName: createNewFileName(sourceFile, program, host, toMove), files };
  }
  function getEditsForRefactor2(fileName, formatOptions, positionOrRange, refactorName14, actionName2, preferences = emptyOptions, interactiveRefactorArguments) {
    synchronizeHostData();
    const file = getValidSourceFile(fileName);
    return ts_refactor_exports.getEditsForRefactor(getRefactorContext(file, positionOrRange, preferences, formatOptions), refactorName14, actionName2, interactiveRefactorArguments);
  }
  function toLineColumnOffset(fileName, position) {
    if (position === 0) {
      return { line: 0, character: 0 };
    }
    return sourceMapper.toLineColumnOffset(fileName, position);
  }
  function prepareCallHierarchy(fileName, position) {
    synchronizeHostData();
    const declarations = ts_CallHierarchy_exports.resolveCallHierarchyDeclaration(program, getTouchingPropertyName(getValidSourceFile(fileName), position));
    return declarations && mapOneOrMany(declarations, (declaration) => ts_CallHierarchy_exports.createCallHierarchyItem(program, declaration));
  }
  function provideCallHierarchyIncomingCalls(fileName, position) {
    synchronizeHostData();
    const sourceFile = getValidSourceFile(fileName);
    const declaration = firstOrOnly(ts_CallHierarchy_exports.resolveCallHierarchyDeclaration(program, position === 0 ? sourceFile : getTouchingPropertyName(sourceFile, position)));
    return declaration ? ts_CallHierarchy_exports.getIncomingCalls(program, declaration, cancellationToken) : [];
  }
  function provideCallHierarchyOutgoingCalls(fileName, position) {
    synchronizeHostData();
    const sourceFile = getValidSourceFile(fileName);
    const declaration = firstOrOnly(ts_CallHierarchy_exports.resolveCallHierarchyDeclaration(program, position === 0 ? sourceFile : getTouchingPropertyName(sourceFile, position)));
    return declaration ? ts_CallHierarchy_exports.getOutgoingCalls(program, declaration) : [];
  }
  function provideInlayHints2(fileName, span, preferences = emptyOptions) {
    synchronizeHostData();
    const sourceFile = getValidSourceFile(fileName);
    return ts_InlayHints_exports.provideInlayHints(getInlayHintsContext(sourceFile, span, preferences));
  }
  function mapCode2(sourceFile, contents, focusLocations, formatOptions, preferences) {
    return ts_MapCode_exports.mapCode(
      syntaxTreeCache.getCurrentSourceFile(sourceFile),
      contents,
      focusLocations,
      host,
      ts_formatting_exports.getFormatContext(formatOptions, host),
      preferences
    );
  }
  const ls = {
    dispose,
    cleanupSemanticCache,
    getSyntacticDiagnostics,
    getSemanticDiagnostics,
    getSuggestionDiagnostics,
    getCompilerOptionsDiagnostics,
    getSyntacticClassifications: getSyntacticClassifications2,
    getSemanticClassifications: getSemanticClassifications3,
    getEncodedSyntacticClassifications: getEncodedSyntacticClassifications2,
    getEncodedSemanticClassifications: getEncodedSemanticClassifications3,
    getCompletionsAtPosition: getCompletionsAtPosition2,
    getCompletionEntryDetails: getCompletionEntryDetails2,
    getCompletionEntrySymbol: getCompletionEntrySymbol2,
    getSignatureHelpItems: getSignatureHelpItems2,
    getQuickInfoAtPosition,
    getDefinitionAtPosition: getDefinitionAtPosition2,
    getDefinitionAndBoundSpan: getDefinitionAndBoundSpan2,
    getImplementationAtPosition,
    getTypeDefinitionAtPosition: getTypeDefinitionAtPosition2,
    getReferencesAtPosition,
    findReferences,
    getFileReferences,
    getDocumentHighlights,
    getNameOrDottedNameSpan,
    getBreakpointStatementAtPosition,
    getNavigateToItems: getNavigateToItems2,
    getRenameInfo: getRenameInfo2,
    getSmartSelectionRange: getSmartSelectionRange2,
    findRenameLocations,
    getNavigationBarItems: getNavigationBarItems2,
    getNavigationTree: getNavigationTree2,
    getOutliningSpans,
    getTodoComments,
    getBraceMatchingAtPosition,
    getIndentationAtPosition,
    getFormattingEditsForRange,
    getFormattingEditsForDocument,
    getFormattingEditsAfterKeystroke,
    getDocCommentTemplateAtPosition: getDocCommentTemplateAtPosition2,
    isValidBraceCompletionAtPosition,
    getJsxClosingTagAtPosition,
    getLinkedEditingRangeAtPosition,
    getSpanOfEnclosingComment,
    getCodeFixesAtPosition,
    getCombinedCodeFix,
    applyCodeActionCommand,
    organizeImports: organizeImports2,
    getEditsForFileRename: getEditsForFileRename2,
    getEmitOutput,
    getNonBoundSourceFile,
    getProgram,
    getCurrentProgram: () => program,
    getAutoImportProvider,
    updateIsDefinitionOfReferencedSymbols,
    getApplicableRefactors: getApplicableRefactors2,
    getEditsForRefactor: getEditsForRefactor2,
    getMoveToRefactoringFileSuggestions,
    toLineColumnOffset,
    getSourceMapper: () => sourceMapper,
    clearSourceMapperCache: () => sourceMapper.clearCache(),
    prepareCallHierarchy,
    provideCallHierarchyIncomingCalls,
    provideCallHierarchyOutgoingCalls,
    toggleLineComment,
    toggleMultilineComment,
    commentSelection,
    uncommentSelection,
    provideInlayHints: provideInlayHints2,
    getSupportedCodeFixes,
    getPasteEdits,
    mapCode: mapCode2
  };
  switch (languageServiceMode) {
    case 0 /* Semantic */:
      break;
    case 1 /* PartialSemantic */:
      invalidOperationsInPartialSemanticMode.forEach(
        (key) => ls[key] = () => {
          throw new Error(`LanguageService Operation: ${key} not allowed in LanguageServiceMode.PartialSemantic`);
        }
      );
      break;
    case 2 /* Syntactic */:
      invalidOperationsInSyntacticMode.forEach(
        (key) => ls[key] = () => {
          throw new Error(`LanguageService Operation: ${key} not allowed in LanguageServiceMode.Syntactic`);
        }
      );
      break;
    default:
      Debug.assertNever(languageServiceMode);
  }
  return ls;
}
function getNameTable(sourceFile) {
  if (!sourceFile.nameTable) {
    initializeNameTable(sourceFile);
  }
  return sourceFile.nameTable;
}
function initializeNameTable(sourceFile) {
  const nameTable = sourceFile.nameTable = /* @__PURE__ */ new Map();
  sourceFile.forEachChild(function walk(node) {
    if (isIdentifier(node) && !isTagName(node) && node.escapedText || isStringOrNumericLiteralLike(node) && literalIsName(node)) {
      const text = getEscapedTextOfIdentifierOrLiteral(node);
      nameTable.set(text, nameTable.get(text) === void 0 ? node.pos : -1);
    } else if (isPrivateIdentifier(node)) {
      const text = node.escapedText;
      nameTable.set(text, nameTable.get(text) === void 0 ? node.pos : -1);
    }
    forEachChild(node, walk);
    if (hasJSDocNodes(node)) {
      for (const jsDoc of node.jsDoc) {
        forEachChild(jsDoc, walk);
      }
    }
  });
}
function literalIsName(node) {
  return isDeclarationName(node) || node.parent.kind === 283 /* ExternalModuleReference */ || isArgumentOfElementAccessExpression(node) || isLiteralComputedPropertyDeclarationName(node);
}
function getContainingObjectLiteralElement(node) {
  const element = getContainingObjectLiteralElementWorker(node);
  return element && (isObjectLiteralExpression(element.parent) || isJsxAttributes(element.parent)) ? element : void 0;
}
function getContainingObjectLiteralElementWorker(node) {
  switch (node.kind) {
    case 11 /* StringLiteral */:
    case 15 /* NoSubstitutionTemplateLiteral */:
    case 9 /* NumericLiteral */:
      if (node.parent.kind === 167 /* ComputedPropertyName */) {
        return isObjectLiteralElement(node.parent.parent) ? node.parent.parent : void 0;
      }
    case 80 /* Identifier */:
      return isObjectLiteralElement(node.parent) && (node.parent.parent.kind === 210 /* ObjectLiteralExpression */ || node.parent.parent.kind === 292 /* JsxAttributes */) && node.parent.name === node ? node.parent : void 0;
  }
  return void 0;
}
function getSymbolAtLocationForQuickInfo(node, checker) {
  const object = getContainingObjectLiteralElement(node);
  if (object) {
    const contextualType = checker.getContextualType(object.parent);
    const properties = contextualType && getPropertySymbolsFromContextualType(
      object,
      checker,
      contextualType,
      /*unionSymbolOk*/
      false
    );
    if (properties && properties.length === 1) {
      return first(properties);
    }
  }
  return checker.getSymbolAtLocation(node);
}
function getPropertySymbolsFromContextualType(node, checker, contextualType, unionSymbolOk) {
  const name = getNameFromPropertyName(node.name);
  if (!name) return emptyArray;
  if (!contextualType.isUnion()) {
    const symbol = contextualType.getProperty(name);
    return symbol ? [symbol] : emptyArray;
  }
  const filteredTypes = isObjectLiteralExpression(node.parent) || isJsxAttributes(node.parent) ? filter(contextualType.types, (t) => !checker.isTypeInvalidDueToUnionDiscriminant(t, node.parent)) : contextualType.types;
  const discriminatedPropertySymbols = mapDefined(filteredTypes, (t) => t.getProperty(name));
  if (unionSymbolOk && (discriminatedPropertySymbols.length === 0 || discriminatedPropertySymbols.length === contextualType.types.length)) {
    const symbol = contextualType.getProperty(name);
    if (symbol) return [symbol];
  }
  if (!filteredTypes.length && !discriminatedPropertySymbols.length) {
    return mapDefined(contextualType.types, (t) => t.getProperty(name));
  }
  return deduplicate(discriminatedPropertySymbols, equateValues);
}
function isArgumentOfElementAccessExpression(node) {
  return node && node.parent && node.parent.kind === 212 /* ElementAccessExpression */ && node.parent.argumentExpression === node;
}
function getDefaultLibFilePath(options) {
  if (sys) {
    return combinePaths(getDirectoryPath(normalizePath(sys.getExecutingFilePath())), getDefaultLibFileName(options));
  }
  throw new Error("getDefaultLibFilePath is only supported when consumed as a node module. ");
}
setObjectAllocator(getServicesObjectAllocator());

// src/services/transform.ts
function transform(source, transformers, compilerOptions) {
  const diagnostics = [];
  compilerOptions = fixupCompilerOptions(compilerOptions, diagnostics);
  const nodes = isArray(source) ? source : [source];
  const result = transformNodes(
    /*resolver*/
    void 0,
    /*host*/
    void 0,
    factory,
    compilerOptions,
    nodes,
    transformers,
    /*allowDtsFiles*/
    true
  );
  result.diagnostics = concatenate(result.diagnostics, diagnostics);
  return result;
}

// src/services/_namespaces/ts.BreakpointResolver.ts
var ts_BreakpointResolver_exports = {};
__export(ts_BreakpointResolver_exports, {
  spanInSourceFileAtLocation: () => spanInSourceFileAtLocation
});

// src/services/breakpoints.ts
function spanInSourceFileAtLocation(sourceFile, position) {
  if (sourceFile.isDeclarationFile) {
    return void 0;
  }
  let tokenAtLocation = getTokenAtPosition(sourceFile, position);
  const lineOfPosition = sourceFile.getLineAndCharacterOfPosition(position).line;
  if (sourceFile.getLineAndCharacterOfPosition(tokenAtLocation.getStart(sourceFile)).line > lineOfPosition) {
    const preceding = findPrecedingToken(tokenAtLocation.pos, sourceFile);
    if (!preceding || sourceFile.getLineAndCharacterOfPosition(preceding.getEnd()).line !== lineOfPosition) {
      return void 0;
    }
    tokenAtLocation = preceding;
  }
  if (tokenAtLocation.flags & 33554432 /* Ambient */) {
    return void 0;
  }
  return spanInNode(tokenAtLocation);
  function textSpan(startNode2, endNode2) {
    const lastDecorator = canHaveDecorators(startNode2) ? findLast(startNode2.modifiers, isDecorator) : void 0;
    const start = lastDecorator ? skipTrivia(sourceFile.text, lastDecorator.end) : startNode2.getStart(sourceFile);
    return createTextSpanFromBounds(start, (endNode2 || startNode2).getEnd());
  }
  function textSpanEndingAtNextToken(startNode2, previousTokenToFindNextEndToken) {
    return textSpan(startNode2, findNextToken(previousTokenToFindNextEndToken, previousTokenToFindNextEndToken.parent, sourceFile));
  }
  function spanInNodeIfStartsOnSameLine(node, otherwiseOnNode) {
    if (node && lineOfPosition === sourceFile.getLineAndCharacterOfPosition(node.getStart(sourceFile)).line) {
      return spanInNode(node);
    }
    return spanInNode(otherwiseOnNode);
  }
  function spanInNodeArray(nodeArray, node, match) {
    if (nodeArray) {
      const index = nodeArray.indexOf(node);
      if (index >= 0) {
        let start = index;
        let end = index + 1;
        while (start > 0 && match(nodeArray[start - 1])) start--;
        while (end < nodeArray.length && match(nodeArray[end])) end++;
        return createTextSpanFromBounds(skipTrivia(sourceFile.text, nodeArray[start].pos), nodeArray[end - 1].end);
      }
    }
    return textSpan(node);
  }
  function spanInPreviousNode(node) {
    return spanInNode(findPrecedingToken(node.pos, sourceFile));
  }
  function spanInNextNode(node) {
    return spanInNode(findNextToken(node, node.parent, sourceFile));
  }
  function spanInNode(node) {
    if (node) {
      const { parent: parent2 } = node;
      switch (node.kind) {
        case 243 /* VariableStatement */:
          return spanInVariableDeclaration(node.declarationList.declarations[0]);
        case 260 /* VariableDeclaration */:
        case 172 /* PropertyDeclaration */:
        case 171 /* PropertySignature */:
          return spanInVariableDeclaration(node);
        case 169 /* Parameter */:
          return spanInParameterDeclaration(node);
        case 262 /* FunctionDeclaration */:
        case 174 /* MethodDeclaration */:
        case 173 /* MethodSignature */:
        case 177 /* GetAccessor */:
        case 178 /* SetAccessor */:
        case 176 /* Constructor */:
        case 218 /* FunctionExpression */:
        case 219 /* ArrowFunction */:
          return spanInFunctionDeclaration(node);
        case 241 /* Block */:
          if (isFunctionBlock(node)) {
            return spanInFunctionBlock(node);
          }
        case 268 /* ModuleBlock */:
          return spanInBlock(node);
        case 299 /* CatchClause */:
          return spanInBlock(node.block);
        case 244 /* ExpressionStatement */:
          return textSpan(node.expression);
        case 253 /* ReturnStatement */:
          return textSpan(node.getChildAt(0), node.expression);
        case 247 /* WhileStatement */:
          return textSpanEndingAtNextToken(node, node.expression);
        case 246 /* DoStatement */:
          return spanInNode(node.statement);
        case 259 /* DebuggerStatement */:
          return textSpan(node.getChildAt(0));
        case 245 /* IfStatement */:
          return textSpanEndingAtNextToken(node, node.expression);
        case 256 /* LabeledStatement */:
          return spanInNode(node.statement);
        case 252 /* BreakStatement */:
        case 251 /* ContinueStatement */:
          return textSpan(node.getChildAt(0), node.label);
        case 248 /* ForStatement */:
          return spanInForStatement(node);
        case 249 /* ForInStatement */:
          return textSpanEndingAtNextToken(node, node.expression);
        case 250 /* ForOfStatement */:
          return spanInInitializerOfForLike(node);
        case 255 /* SwitchStatement */:
          return textSpanEndingAtNextToken(node, node.expression);
        case 296 /* CaseClause */:
        case 297 /* DefaultClause */:
          return spanInNode(node.statements[0]);
        case 258 /* TryStatement */:
          return spanInBlock(node.tryBlock);
        case 257 /* ThrowStatement */:
          return textSpan(node, node.expression);
        case 277 /* ExportAssignment */:
          return textSpan(node, node.expression);
        case 271 /* ImportEqualsDeclaration */:
          return textSpan(node, node.moduleReference);
        case 272 /* ImportDeclaration */:
          return textSpan(node, node.moduleSpecifier);
        case 278 /* ExportDeclaration */:
          return textSpan(node, node.moduleSpecifier);
        case 267 /* ModuleDeclaration */:
          if (getModuleInstanceState(node) !== 1 /* Instantiated */) {
            return void 0;
          }
        case 263 /* ClassDeclaration */:
        case 266 /* EnumDeclaration */:
        case 306 /* EnumMember */:
        case 208 /* BindingElement */:
          return textSpan(node);
        case 254 /* WithStatement */:
          return spanInNode(node.statement);
        case 170 /* Decorator */:
          return spanInNodeArray(parent2.modifiers, node, isDecorator);
        case 206 /* ObjectBindingPattern */:
        case 207 /* ArrayBindingPattern */:
          return spanInBindingPattern(node);
        case 264 /* InterfaceDeclaration */:
        case 265 /* TypeAliasDeclaration */:
          return void 0;
        case 27 /* SemicolonToken */:
        case 1 /* EndOfFileToken */:
          return spanInNodeIfStartsOnSameLine(findPrecedingToken(node.pos, sourceFile));
        case 28 /* CommaToken */:
          return spanInPreviousNode(node);
        case 19 /* OpenBraceToken */:
          return spanInOpenBraceToken(node);
        case 20 /* CloseBraceToken */:
          return spanInCloseBraceToken(node);
        case 24 /* CloseBracketToken */:
          return spanInCloseBracketToken(node);
        case 21 /* OpenParenToken */:
          return spanInOpenParenToken(node);
        case 22 /* CloseParenToken */:
          return spanInCloseParenToken(node);
        case 59 /* ColonToken */:
          return spanInColonToken(node);
        case 32 /* GreaterThanToken */:
        case 30 /* LessThanToken */:
          return spanInGreaterThanOrLessThanToken(node);
        case 117 /* WhileKeyword */:
          return spanInWhileKeyword(node);
        case 93 /* ElseKeyword */:
        case 85 /* CatchKeyword */:
        case 98 /* FinallyKeyword */:
          return spanInNextNode(node);
        case 165 /* OfKeyword */:
          return spanInOfKeyword(node);
        default:
          if (isArrayLiteralOrObjectLiteralDestructuringPattern(node)) {
            return spanInArrayLiteralOrObjectLiteralDestructuringPattern(node);
          }
          if ((node.kind === 80 /* Identifier */ || node.kind === 230 /* SpreadElement */ || node.kind === 303 /* PropertyAssignment */ || node.kind === 304 /* ShorthandPropertyAssignment */) && isArrayLiteralOrObjectLiteralDestructuringPattern(parent2)) {
            return textSpan(node);
          }
          if (node.kind === 226 /* BinaryExpression */) {
            const { left, operatorToken } = node;
            if (isArrayLiteralOrObjectLiteralDestructuringPattern(left)) {
              return spanInArrayLiteralOrObjectLiteralDestructuringPattern(
                left
              );
            }
            if (operatorToken.kind === 64 /* EqualsToken */ && isArrayLiteralOrObjectLiteralDestructuringPattern(node.parent)) {
              return textSpan(node);
            }
            if (operatorToken.kind === 28 /* CommaToken */) {
              return spanInNode(left);
            }
          }
          if (isExpressionNode(node)) {
            switch (parent2.kind) {
              case 246 /* DoStatement */:
                return spanInPreviousNode(node);
              case 170 /* Decorator */:
                return spanInNode(node.parent);
              case 248 /* ForStatement */:
              case 250 /* ForOfStatement */:
                return textSpan(node);
              case 226 /* BinaryExpression */:
                if (node.parent.operatorToken.kind === 28 /* CommaToken */) {
                  return textSpan(node);
                }
                break;
              case 219 /* ArrowFunction */:
                if (node.parent.body === node) {
                  return textSpan(node);
                }
                break;
            }
          }
          switch (node.parent.kind) {
            case 303 /* PropertyAssignment */:
              if (node.parent.name === node && !isArrayLiteralOrObjectLiteralDestructuringPattern(node.parent.parent)) {
                return spanInNode(node.parent.initializer);
              }
              break;
            case 216 /* TypeAssertionExpression */:
              if (node.parent.type === node) {
                return spanInNextNode(node.parent.type);
              }
              break;
            case 260 /* VariableDeclaration */:
            case 169 /* Parameter */: {
              const { initializer, type } = node.parent;
              if (initializer === node || type === node || isAssignmentOperator(node.kind)) {
                return spanInPreviousNode(node);
              }
              break;
            }
            case 226 /* BinaryExpression */: {
              const { left } = node.parent;
              if (isArrayLiteralOrObjectLiteralDestructuringPattern(left) && node !== left) {
                return spanInPreviousNode(node);
              }
              break;
            }
            default:
              if (isFunctionLike(node.parent) && node.parent.type === node) {
                return spanInPreviousNode(node);
              }
          }
          return spanInNode(node.parent);
      }
    }
    function textSpanFromVariableDeclaration(variableDeclaration) {
      if (isVariableDeclarationList(variableDeclaration.parent) && variableDeclaration.parent.declarations[0] === variableDeclaration) {
        return textSpan(findPrecedingToken(variableDeclaration.pos, sourceFile, variableDeclaration.parent), variableDeclaration);
      } else {
        return textSpan(variableDeclaration);
      }
    }
    function spanInVariableDeclaration(variableDeclaration) {
      if (variableDeclaration.parent.parent.kind === 249 /* ForInStatement */) {
        return spanInNode(variableDeclaration.parent.parent);
      }
      const parent2 = variableDeclaration.parent;
      if (isBindingPattern(variableDeclaration.name)) {
        return spanInBindingPattern(variableDeclaration.name);
      }
      if (hasOnlyExpressionInitializer(variableDeclaration) && variableDeclaration.initializer || hasSyntacticModifier(variableDeclaration, 32 /* Export */) || parent2.parent.kind === 250 /* ForOfStatement */) {
        return textSpanFromVariableDeclaration(variableDeclaration);
      }
      if (isVariableDeclarationList(variableDeclaration.parent) && variableDeclaration.parent.declarations[0] !== variableDeclaration) {
        return spanInNode(findPrecedingToken(variableDeclaration.pos, sourceFile, variableDeclaration.parent));
      }
    }
    function canHaveSpanInParameterDeclaration(parameter) {
      return !!parameter.initializer || parameter.dotDotDotToken !== void 0 || hasSyntacticModifier(parameter, 1 /* Public */ | 2 /* Private */);
    }
    function spanInParameterDeclaration(parameter) {
      if (isBindingPattern(parameter.name)) {
        return spanInBindingPattern(parameter.name);
      } else if (canHaveSpanInParameterDeclaration(parameter)) {
        return textSpan(parameter);
      } else {
        const functionDeclaration = parameter.parent;
        const indexOfParameter = functionDeclaration.parameters.indexOf(parameter);
        Debug.assert(indexOfParameter !== -1);
        if (indexOfParameter !== 0) {
          return spanInParameterDeclaration(functionDeclaration.parameters[indexOfParameter - 1]);
        } else {
          return spanInNode(functionDeclaration.body);
        }
      }
    }
    function canFunctionHaveSpanInWholeDeclaration(functionDeclaration) {
      return hasSyntacticModifier(functionDeclaration, 32 /* Export */) || functionDeclaration.parent.kind === 263 /* ClassDeclaration */ && functionDeclaration.kind !== 176 /* Constructor */;
    }
    function spanInFunctionDeclaration(functionDeclaration) {
      if (!functionDeclaration.body) {
        return void 0;
      }
      if (canFunctionHaveSpanInWholeDeclaration(functionDeclaration)) {
        return textSpan(functionDeclaration);
      }
      return spanInNode(functionDeclaration.body);
    }
    function spanInFunctionBlock(block) {
      const nodeForSpanInBlock = block.statements.length ? block.statements[0] : block.getLastToken();
      if (canFunctionHaveSpanInWholeDeclaration(block.parent)) {
        return spanInNodeIfStartsOnSameLine(block.parent, nodeForSpanInBlock);
      }
      return spanInNode(nodeForSpanInBlock);
    }
    function spanInBlock(block) {
      switch (block.parent.kind) {
        case 267 /* ModuleDeclaration */:
          if (getModuleInstanceState(block.parent) !== 1 /* Instantiated */) {
            return void 0;
          }
        case 247 /* WhileStatement */:
        case 245 /* IfStatement */:
        case 249 /* ForInStatement */:
          return spanInNodeIfStartsOnSameLine(block.parent, block.statements[0]);
        case 248 /* ForStatement */:
        case 250 /* ForOfStatement */:
          return spanInNodeIfStartsOnSameLine(findPrecedingToken(block.pos, sourceFile, block.parent), block.statements[0]);
      }
      return spanInNode(block.statements[0]);
    }
    function spanInInitializerOfForLike(forLikeStatement) {
      if (forLikeStatement.initializer.kind === 261 /* VariableDeclarationList */) {
        const variableDeclarationList = forLikeStatement.initializer;
        if (variableDeclarationList.declarations.length > 0) {
          return spanInNode(variableDeclarationList.declarations[0]);
        }
      } else {
        return spanInNode(forLikeStatement.initializer);
      }
    }
    function spanInForStatement(forStatement) {
      if (forStatement.initializer) {
        return spanInInitializerOfForLike(forStatement);
      }
      if (forStatement.condition) {
        return textSpan(forStatement.condition);
      }
      if (forStatement.incrementor) {
        return textSpan(forStatement.incrementor);
      }
    }
    function spanInBindingPattern(bindingPattern) {
      const firstBindingElement = forEach(bindingPattern.elements, (element) => element.kind !== 232 /* OmittedExpression */ ? element : void 0);
      if (firstBindingElement) {
        return spanInNode(firstBindingElement);
      }
      if (bindingPattern.parent.kind === 208 /* BindingElement */) {
        return textSpan(bindingPattern.parent);
      }
      return textSpanFromVariableDeclaration(bindingPattern.parent);
    }
    function spanInArrayLiteralOrObjectLiteralDestructuringPattern(node2) {
      Debug.assert(node2.kind !== 207 /* ArrayBindingPattern */ && node2.kind !== 206 /* ObjectBindingPattern */);
      const elements = node2.kind === 209 /* ArrayLiteralExpression */ ? node2.elements : node2.properties;
      const firstBindingElement = forEach(elements, (element) => element.kind !== 232 /* OmittedExpression */ ? element : void 0);
      if (firstBindingElement) {
        return spanInNode(firstBindingElement);
      }
      return textSpan(node2.parent.kind === 226 /* BinaryExpression */ ? node2.parent : node2);
    }
    function spanInOpenBraceToken(node2) {
      switch (node2.parent.kind) {
        case 266 /* EnumDeclaration */:
          const enumDeclaration = node2.parent;
          return spanInNodeIfStartsOnSameLine(findPrecedingToken(node2.pos, sourceFile, node2.parent), enumDeclaration.members.length ? enumDeclaration.members[0] : enumDeclaration.getLastToken(sourceFile));
        case 263 /* ClassDeclaration */:
          const classDeclaration = node2.parent;
          return spanInNodeIfStartsOnSameLine(findPrecedingToken(node2.pos, sourceFile, node2.parent), classDeclaration.members.length ? classDeclaration.members[0] : classDeclaration.getLastToken(sourceFile));
        case 269 /* CaseBlock */:
          return spanInNodeIfStartsOnSameLine(node2.parent.parent, node2.parent.clauses[0]);
      }
      return spanInNode(node2.parent);
    }
    function spanInCloseBraceToken(node2) {
      switch (node2.parent.kind) {
        case 268 /* ModuleBlock */:
          if (getModuleInstanceState(node2.parent.parent) !== 1 /* Instantiated */) {
            return void 0;
          }
        case 266 /* EnumDeclaration */:
        case 263 /* ClassDeclaration */:
          return textSpan(node2);
        case 241 /* Block */:
          if (isFunctionBlock(node2.parent)) {
            return textSpan(node2);
          }
        case 299 /* CatchClause */:
          return spanInNode(lastOrUndefined(node2.parent.statements));
        case 269 /* CaseBlock */:
          const caseBlock = node2.parent;
          const lastClause = lastOrUndefined(caseBlock.clauses);
          if (lastClause) {
            return spanInNode(lastOrUndefined(lastClause.statements));
          }
          return void 0;
        case 206 /* ObjectBindingPattern */:
          const bindingPattern = node2.parent;
          return spanInNode(lastOrUndefined(bindingPattern.elements) || bindingPattern);
        default:
          if (isArrayLiteralOrObjectLiteralDestructuringPattern(node2.parent)) {
            const objectLiteral = node2.parent;
            return textSpan(lastOrUndefined(objectLiteral.properties) || objectLiteral);
          }
          return spanInNode(node2.parent);
      }
    }
    function spanInCloseBracketToken(node2) {
      switch (node2.parent.kind) {
        case 207 /* ArrayBindingPattern */:
          const bindingPattern = node2.parent;
          return textSpan(lastOrUndefined(bindingPattern.elements) || bindingPattern);
        default:
          if (isArrayLiteralOrObjectLiteralDestructuringPattern(node2.parent)) {
            const arrayLiteral = node2.parent;
            return textSpan(lastOrUndefined(arrayLiteral.elements) || arrayLiteral);
          }
          return spanInNode(node2.parent);
      }
    }
    function spanInOpenParenToken(node2) {
      if (node2.parent.kind === 246 /* DoStatement */ || // Go to while keyword and do action instead
      node2.parent.kind === 213 /* CallExpression */ || node2.parent.kind === 214 /* NewExpression */) {
        return spanInPreviousNode(node2);
      }
      if (node2.parent.kind === 217 /* ParenthesizedExpression */) {
        return spanInNextNode(node2);
      }
      return spanInNode(node2.parent);
    }
    function spanInCloseParenToken(node2) {
      switch (node2.parent.kind) {
        case 218 /* FunctionExpression */:
        case 262 /* FunctionDeclaration */:
        case 219 /* ArrowFunction */:
        case 174 /* MethodDeclaration */:
        case 173 /* MethodSignature */:
        case 177 /* GetAccessor */:
        case 178 /* SetAccessor */:
        case 176 /* Constructor */:
        case 247 /* WhileStatement */:
        case 246 /* DoStatement */:
        case 248 /* ForStatement */:
        case 250 /* ForOfStatement */:
        case 213 /* CallExpression */:
        case 214 /* NewExpression */:
        case 217 /* ParenthesizedExpression */:
          return spanInPreviousNode(node2);
        default:
          return spanInNode(node2.parent);
      }
    }
    function spanInColonToken(node2) {
      if (isFunctionLike(node2.parent) || node2.parent.kind === 303 /* PropertyAssignment */ || node2.parent.kind === 169 /* Parameter */) {
        return spanInPreviousNode(node2);
      }
      return spanInNode(node2.parent);
    }
    function spanInGreaterThanOrLessThanToken(node2) {
      if (node2.parent.kind === 216 /* TypeAssertionExpression */) {
        return spanInNextNode(node2);
      }
      return spanInNode(node2.parent);
    }
    function spanInWhileKeyword(node2) {
      if (node2.parent.kind === 246 /* DoStatement */) {
        return textSpanEndingAtNextToken(node2, node2.parent.expression);
      }
      return spanInNode(node2.parent);
    }
    function spanInOfKeyword(node2) {
      if (node2.parent.kind === 250 /* ForOfStatement */) {
        return spanInNextNode(node2);
      }
      return spanInNode(node2.parent);
    }
  }
}

// src/services/_namespaces/ts.CallHierarchy.ts
var ts_CallHierarchy_exports = {};
__export(ts_CallHierarchy_exports, {
  createCallHierarchyItem: () => createCallHierarchyItem,
  getIncomingCalls: () => getIncomingCalls,
  getOutgoingCalls: () => getOutgoingCalls,
  resolveCallHierarchyDeclaration: () => resolveCallHierarchyDeclaration
});

// src/services/callHierarchy.ts
function isNamedExpression(node) {
  return (isFunctionExpression(node) || isClassExpression(node)) && isNamedDeclaration(node);
}
function isVariableLike2(node) {
  return isPropertyDeclaration(node) || isVariableDeclaration(node);
}
function isAssignedExpression(node) {
  return (isFunctionExpression(node) || isArrowFunction(node) || isClassExpression(node)) && isVariableLike2(node.parent) && node === node.parent.initializer && isIdentifier(node.parent.name) && (!!(getCombinedNodeFlags(node.parent) & 2 /* Const */) || isPropertyDeclaration(node.parent));
}
function isPossibleCallHierarchyDeclaration(node) {
  return isSourceFile(node) || isModuleDeclaration(node) || isFunctionDeclaration(node) || isFunctionExpression(node) || isClassDeclaration(node) || isClassExpression(node) || isClassStaticBlockDeclaration(node) || isMethodDeclaration(node) || isMethodSignature(node) || isGetAccessorDeclaration(node) || isSetAccessorDeclaration(node);
}
function isValidCallHierarchyDeclaration(node) {
  return isSourceFile(node) || isModuleDeclaration(node) && isIdentifier(node.name) || isFunctionDeclaration(node) || isClassDeclaration(node) || isClassStaticBlockDeclaration(node) || isMethodDeclaration(node) || isMethodSignature(node) || isGetAccessorDeclaration(node) || isSetAccessorDeclaration(node) || isNamedExpression(node) || isAssignedExpression(node);
}
function getCallHierarchyDeclarationReferenceNode(node) {
  if (isSourceFile(node)) return node;
  if (isNamedDeclaration(node)) return node.name;
  if (isAssignedExpression(node)) return node.parent.name;
  return Debug.checkDefined(node.modifiers && find(node.modifiers, isDefaultModifier3));
}
function isDefaultModifier3(node) {
  return node.kind === 90 /* DefaultKeyword */;
}
function getSymbolOfCallHierarchyDeclaration(typeChecker, node) {
  const location = getCallHierarchyDeclarationReferenceNode(node);
  return location && typeChecker.getSymbolAtLocation(location);
}
function getCallHierarchyItemName(program, node) {
  if (isSourceFile(node)) {
    return { text: node.fileName, pos: 0, end: 0 };
  }
  if ((isFunctionDeclaration(node) || isClassDeclaration(node)) && !isNamedDeclaration(node)) {
    const defaultModifier = node.modifiers && find(node.modifiers, isDefaultModifier3);
    if (defaultModifier) {
      return { text: "default", pos: defaultModifier.getStart(), end: defaultModifier.getEnd() };
    }
  }
  if (isClassStaticBlockDeclaration(node)) {
    const sourceFile = node.getSourceFile();
    const pos = skipTrivia(sourceFile.text, moveRangePastModifiers(node).pos);
    const end = pos + 6;
    const typeChecker = program.getTypeChecker();
    const symbol = typeChecker.getSymbolAtLocation(node.parent);
    const prefix = symbol ? `${typeChecker.symbolToString(symbol, node.parent)} ` : "";
    return { text: `${prefix}static {}`, pos, end };
  }
  const declName = isAssignedExpression(node) ? node.parent.name : Debug.checkDefined(getNameOfDeclaration(node), "Expected call hierarchy item to have a name");
  let text = isIdentifier(declName) ? idText(declName) : isStringOrNumericLiteralLike(declName) ? declName.text : isComputedPropertyName(declName) ? isStringOrNumericLiteralLike(declName.expression) ? declName.expression.text : void 0 : void 0;
  if (text === void 0) {
    const typeChecker = program.getTypeChecker();
    const symbol = typeChecker.getSymbolAtLocation(declName);
    if (symbol) {
      text = typeChecker.symbolToString(symbol, node);
    }
  }
  if (text === void 0) {
    const printer = createPrinterWithRemoveCommentsOmitTrailingSemicolon();
    text = usingSingleLineStringWriter((writer) => printer.writeNode(4 /* Unspecified */, node, node.getSourceFile(), writer));
  }
  return { text, pos: declName.getStart(), end: declName.getEnd() };
}
function getCallHierarchItemContainerName(node) {
  var _a, _b, _c, _d;
  if (isAssignedExpression(node)) {
    if (isPropertyDeclaration(node.parent) && isClassLike(node.parent.parent)) {
      return isClassExpression(node.parent.parent) ? (_a = getAssignedName(node.parent.parent)) == null ? void 0 : _a.getText() : (_b = node.parent.parent.name) == null ? void 0 : _b.getText();
    }
    if (isModuleBlock(node.parent.parent.parent.parent) && isIdentifier(node.parent.parent.parent.parent.parent.name)) {
      return node.parent.parent.parent.parent.parent.name.getText();
    }
    return;
  }
  switch (node.kind) {
    case 177 /* GetAccessor */:
    case 178 /* SetAccessor */:
    case 174 /* MethodDeclaration */:
      if (node.parent.kind === 210 /* ObjectLiteralExpression */) {
        return (_c = getAssignedName(node.parent)) == null ? void 0 : _c.getText();
      }
      return (_d = getNameOfDeclaration(node.parent)) == null ? void 0 : _d.getText();
    case 262 /* FunctionDeclaration */:
    case 263 /* ClassDeclaration */:
    case 267 /* ModuleDeclaration */:
      if (isModuleBlock(node.parent) && isIdentifier(node.parent.parent.name)) {
        return node.parent.parent.name.getText();
      }
  }
}
function findImplementation(typeChecker, node) {
  if (node.body) {
    return node;
  }
  if (isConstructorDeclaration(node)) {
    return getFirstConstructorWithBody(node.parent);
  }
  if (isFunctionDeclaration(node) || isMethodDeclaration(node)) {
    const symbol = getSymbolOfCallHierarchyDeclaration(typeChecker, node);
    if (symbol && symbol.valueDeclaration && isFunctionLikeDeclaration(symbol.valueDeclaration) && symbol.valueDeclaration.body) {
      return symbol.valueDeclaration;
    }
    return void 0;
  }
  return node;
}
function findAllInitialDeclarations(typeChecker, node) {
  const symbol = getSymbolOfCallHierarchyDeclaration(typeChecker, node);
  let declarations;
  if (symbol && symbol.declarations) {
    const indices = indicesOf(symbol.declarations);
    const keys = map(symbol.declarations, (decl) => ({ file: decl.getSourceFile().fileName, pos: decl.pos }));
    indices.sort((a, b) => compareStringsCaseSensitive(keys[a].file, keys[b].file) || keys[a].pos - keys[b].pos);
    const sortedDeclarations = map(indices, (i) => symbol.declarations[i]);
    let lastDecl;
    for (const decl of sortedDeclarations) {
      if (isValidCallHierarchyDeclaration(decl)) {
        if (!lastDecl || lastDecl.parent !== decl.parent || lastDecl.end !== decl.pos) {
          declarations = append(declarations, decl);
        }
        lastDecl = decl;
      }
    }
  }
  return declarations;
}
function findImplementationOrAllInitialDeclarations(typeChecker, node) {
  if (isClassStaticBlockDeclaration(node)) {
    return node;
  }
  if (isFunctionLikeDeclaration(node)) {
    return findImplementation(typeChecker, node) ?? findAllInitialDeclarations(typeChecker, node) ?? node;
  }
  return findAllInitialDeclarations(typeChecker, node) ?? node;
}
function resolveCallHierarchyDeclaration(program, location) {
  const typeChecker = program.getTypeChecker();
  let followingSymbol = false;
  while (true) {
    if (isValidCallHierarchyDeclaration(location)) {
      return findImplementationOrAllInitialDeclarations(typeChecker, location);
    }
    if (isPossibleCallHierarchyDeclaration(location)) {
      const ancestor = findAncestor(location, isValidCallHierarchyDeclaration);
      return ancestor && findImplementationOrAllInitialDeclarations(typeChecker, ancestor);
    }
    if (isDeclarationName(location)) {
      if (isValidCallHierarchyDeclaration(location.parent)) {
        return findImplementationOrAllInitialDeclarations(typeChecker, location.parent);
      }
      if (isPossibleCallHierarchyDeclaration(location.parent)) {
        const ancestor = findAncestor(location.parent, isValidCallHierarchyDeclaration);
        return ancestor && findImplementationOrAllInitialDeclarations(typeChecker, ancestor);
      }
      if (isVariableLike2(location.parent) && location.parent.initializer && isAssignedExpression(location.parent.initializer)) {
        return location.parent.initializer;
      }
      return void 0;
    }
    if (isConstructorDeclaration(location)) {
      if (isValidCallHierarchyDeclaration(location.parent)) {
        return location.parent;
      }
      return void 0;
    }
    if (location.kind === 126 /* StaticKeyword */ && isClassStaticBlockDeclaration(location.parent)) {
      location = location.parent;
      continue;
    }
    if (isVariableDeclaration(location) && location.initializer && isAssignedExpression(location.initializer)) {
      return location.initializer;
    }
    if (!followingSymbol) {
      let symbol = typeChecker.getSymbolAtLocation(location);
      if (symbol) {
        if (symbol.flags & 2097152 /* Alias */) {
          symbol = typeChecker.getAliasedSymbol(symbol);
        }
        if (symbol.valueDeclaration) {
          followingSymbol = true;
          location = symbol.valueDeclaration;
          continue;
        }
      }
    }
    return void 0;
  }
}
function createCallHierarchyItem(program, node) {
  const sourceFile = node.getSourceFile();
  const name = getCallHierarchyItemName(program, node);
  const containerName = getCallHierarchItemContainerName(node);
  const kind = getNodeKind(node);
  const kindModifiers = getNodeModifiers(node);
  const span = createTextSpanFromBounds(skipTrivia(
    sourceFile.text,
    node.getFullStart(),
    /*stopAfterLineBreak*/
    false,
    /*stopAtComments*/
    true
  ), node.getEnd());
  const selectionSpan = createTextSpanFromBounds(name.pos, name.end);
  return { file: sourceFile.fileName, kind, kindModifiers, name: name.text, containerName, span, selectionSpan };
}
function isDefined(x) {
  return x !== void 0;
}
function convertEntryToCallSite(entry) {
  if (entry.kind === ts_FindAllReferences_exports.EntryKind.Node) {
    const { node } = entry;
    if (isCallOrNewExpressionTarget(
      node,
      /*includeElementAccess*/
      true,
      /*skipPastOuterExpressions*/
      true
    ) || isTaggedTemplateTag(
      node,
      /*includeElementAccess*/
      true,
      /*skipPastOuterExpressions*/
      true
    ) || isDecoratorTarget(
      node,
      /*includeElementAccess*/
      true,
      /*skipPastOuterExpressions*/
      true
    ) || isJsxOpeningLikeElementTagName(
      node,
      /*includeElementAccess*/
      true,
      /*skipPastOuterExpressions*/
      true
    ) || isRightSideOfPropertyAccess(node) || isArgumentExpressionOfElementAccess(node)) {
      const sourceFile = node.getSourceFile();
      const ancestor = findAncestor(node, isValidCallHierarchyDeclaration) || sourceFile;
      return { declaration: ancestor, range: createTextRangeFromNode(node, sourceFile) };
    }
  }
}
function getCallSiteGroupKey(entry) {
  return getNodeId(entry.declaration);
}
function createCallHierarchyIncomingCall(from, fromSpans) {
  return { from, fromSpans };
}
function convertCallSiteGroupToIncomingCall(program, entries) {
  return createCallHierarchyIncomingCall(createCallHierarchyItem(program, entries[0].declaration), map(entries, (entry) => createTextSpanFromRange(entry.range)));
}
function getIncomingCalls(program, declaration, cancellationToken) {
  if (isSourceFile(declaration) || isModuleDeclaration(declaration) || isClassStaticBlockDeclaration(declaration)) {
    return [];
  }
  const location = getCallHierarchyDeclarationReferenceNode(declaration);
  const calls = filter(ts_FindAllReferences_exports.findReferenceOrRenameEntries(
    program,
    cancellationToken,
    program.getSourceFiles(),
    location,
    /*position*/
    0,
    { use: ts_FindAllReferences_exports.FindReferencesUse.References },
    convertEntryToCallSite
  ), isDefined);
  return calls ? group(calls, getCallSiteGroupKey, (entries) => convertCallSiteGroupToIncomingCall(program, entries)) : [];
}
function createCallSiteCollector(program, callSites) {
  function recordCallSite(node) {
    const target = isTaggedTemplateExpression(node) ? node.tag : isJsxOpeningLikeElement(node) ? node.tagName : isAccessExpression(node) ? node : isClassStaticBlockDeclaration(node) ? node : node.expression;
    const declaration = resolveCallHierarchyDeclaration(program, target);
    if (declaration) {
      const range = createTextRangeFromNode(target, node.getSourceFile());
      if (isArray(declaration)) {
        for (const decl of declaration) {
          callSites.push({ declaration: decl, range });
        }
      } else {
        callSites.push({ declaration, range });
      }
    }
  }
  function collect(node) {
    if (!node) return;
    if (node.flags & 33554432 /* Ambient */) {
      return;
    }
    if (isValidCallHierarchyDeclaration(node)) {
      if (isClassLike(node)) {
        for (const member of node.members) {
          if (member.name && isComputedPropertyName(member.name)) {
            collect(member.name.expression);
          }
        }
      }
      return;
    }
    switch (node.kind) {
      case 80 /* Identifier */:
      case 271 /* ImportEqualsDeclaration */:
      case 272 /* ImportDeclaration */:
      case 278 /* ExportDeclaration */:
      case 264 /* InterfaceDeclaration */:
      case 265 /* TypeAliasDeclaration */:
        return;
      case 175 /* ClassStaticBlockDeclaration */:
        recordCallSite(node);
        return;
      case 216 /* TypeAssertionExpression */:
      case 234 /* AsExpression */:
        collect(node.expression);
        return;
      case 260 /* VariableDeclaration */:
      case 169 /* Parameter */:
        collect(node.name);
        collect(node.initializer);
        return;
      case 213 /* CallExpression */:
        recordCallSite(node);
        collect(node.expression);
        forEach(node.arguments, collect);
        return;
      case 214 /* NewExpression */:
        recordCallSite(node);
        collect(node.expression);
        forEach(node.arguments, collect);
        return;
      case 215 /* TaggedTemplateExpression */:
        recordCallSite(node);
        collect(node.tag);
        collect(node.template);
        return;
      case 286 /* JsxOpeningElement */:
      case 285 /* JsxSelfClosingElement */:
        recordCallSite(node);
        collect(node.tagName);
        collect(node.attributes);
        return;
      case 170 /* Decorator */:
        recordCallSite(node);
        collect(node.expression);
        return;
      case 211 /* PropertyAccessExpression */:
      case 212 /* ElementAccessExpression */:
        recordCallSite(node);
        forEachChild(node, collect);
        break;
      case 238 /* SatisfiesExpression */:
        collect(node.expression);
        return;
    }
    if (isPartOfTypeNode(node)) {
      return;
    }
    forEachChild(node, collect);
  }
  return collect;
}
function collectCallSitesOfSourceFile(node, collect) {
  forEach(node.statements, collect);
}
function collectCallSitesOfModuleDeclaration(node, collect) {
  if (!hasSyntacticModifier(node, 128 /* Ambient */) && node.body && isModuleBlock(node.body)) {
    forEach(node.body.statements, collect);
  }
}
function collectCallSitesOfFunctionLikeDeclaration(typeChecker, node, collect) {
  const implementation = findImplementation(typeChecker, node);
  if (implementation) {
    forEach(implementation.parameters, collect);
    collect(implementation.body);
  }
}
function collectCallSitesOfClassStaticBlockDeclaration(node, collect) {
  collect(node.body);
}
function collectCallSitesOfClassLikeDeclaration(node, collect) {
  forEach(node.modifiers, collect);
  const heritage = getClassExtendsHeritageElement(node);
  if (heritage) {
    collect(heritage.expression);
  }
  for (const member of node.members) {
    if (canHaveModifiers(member)) {
      forEach(member.modifiers, collect);
    }
    if (isPropertyDeclaration(member)) {
      collect(member.initializer);
    } else if (isConstructorDeclaration(member) && member.body) {
      forEach(member.parameters, collect);
      collect(member.body);
    } else if (isClassStaticBlockDeclaration(member)) {
      collect(member);
    }
  }
}
function collectCallSites(program, node) {
  const callSites = [];
  const collect = createCallSiteCollector(program, callSites);
  switch (node.kind) {
    case 307 /* SourceFile */:
      collectCallSitesOfSourceFile(node, collect);
      break;
    case 267 /* ModuleDeclaration */:
      collectCallSitesOfModuleDeclaration(node, collect);
      break;
    case 262 /* FunctionDeclaration */:
    case 218 /* FunctionExpression */:
    case 219 /* ArrowFunction */:
    case 174 /* MethodDeclaration */:
    case 177 /* GetAccessor */:
    case 178 /* SetAccessor */:
      collectCallSitesOfFunctionLikeDeclaration(program.getTypeChecker(), node, collect);
      break;
    case 263 /* ClassDeclaration */:
    case 231 /* ClassExpression */:
      collectCallSitesOfClassLikeDeclaration(node, collect);
      break;
    case 175 /* ClassStaticBlockDeclaration */:
      collectCallSitesOfClassStaticBlockDeclaration(node, collect);
      break;
    default:
      Debug.assertNever(node);
  }
  return callSites;
}
function createCallHierarchyOutgoingCall(to, fromSpans) {
  return { to, fromSpans };
}
function convertCallSiteGroupToOutgoingCall(program, entries) {
  return createCallHierarchyOutgoingCall(createCallHierarchyItem(program, entries[0].declaration), map(entries, (entry) => createTextSpanFromRange(entry.range)));
}
function getOutgoingCalls(program, declaration) {
  if (declaration.flags & 33554432 /* Ambient */ || isMethodSignature(declaration)) {
    return [];
  }
  return group(collectCallSites(program, declaration), getCallSiteGroupKey, (entries) => convertCallSiteGroupToOutgoingCall(program, entries));
}

// src/services/_namespaces/ts.classifier.ts
var ts_classifier_exports = {};
__export(ts_classifier_exports, {
  v2020: () => ts_classifier_v2020_exports
});

// src/services/_namespaces/ts.classifier.v2020.ts
var ts_classifier_v2020_exports = {};
__export(ts_classifier_v2020_exports, {
  TokenEncodingConsts: () => TokenEncodingConsts,
  TokenModifier: () => TokenModifier,
  TokenType: () => TokenType,
  getEncodedSemanticClassifications: () => getEncodedSemanticClassifications2,
  getSemanticClassifications: () => getSemanticClassifications2
});

// src/services/_namespaces/ts.codefix.ts
var ts_codefix_exports = {};
__export(ts_codefix_exports, {
  PreserveOptionalFlags: () => PreserveOptionalFlags,
  addNewNodeForMemberSymbol: () => addNewNodeForMemberSymbol,
  codeFixAll: () => codeFixAll,
  createCodeFixAction: () => createCodeFixAction,
  createCodeFixActionMaybeFixAll: () => createCodeFixActionMaybeFixAll,
  createCodeFixActionWithoutFixAll: () => createCodeFixActionWithoutFixAll,
  createCombinedCodeActions: () => createCombinedCodeActions,
  createFileTextChanges: () => createFileTextChanges,
  createImportAdder: () => createImportAdder,
  createImportSpecifierResolver: () => createImportSpecifierResolver,
  createJsonPropertyAssignment: () => createJsonPropertyAssignment,
  createMissingMemberNodes: () => createMissingMemberNodes,
  createSignatureDeclarationFromCallExpression: () => createSignatureDeclarationFromCallExpression,
  createSignatureDeclarationFromSignature: () => createSignatureDeclarationFromSignature,
  createStubbedBody: () => createStubbedBody,
  eachDiagnostic: () => eachDiagnostic,
  findAncestorMatchingSpan: () => findAncestorMatchingSpan,
  findJsonProperty: () => findJsonProperty,
  generateAccessorFromProperty: () => generateAccessorFromProperty,
  getAccessorConvertiblePropertyAtPosition: () => getAccessorConvertiblePropertyAtPosition,
  getAllFixes: () => getAllFixes,
  getAllSupers: () => getAllSupers,
  getArgumentTypesAndTypeParameters: () => getArgumentTypesAndTypeParameters,
  getFixes: () => getFixes,
  getImportCompletionAction: () => getImportCompletionAction,
  getImportKind: () => getImportKind,
  getJSDocTypedefNodes: () => getJSDocTypedefNodes,
  getNoopSymbolTrackerWithResolver: () => getNoopSymbolTrackerWithResolver,
  getPromoteTypeOnlyCompletionAction: () => getPromoteTypeOnlyCompletionAction,
  getSupportedErrorCodes: () => getSupportedErrorCodes,
  importFixName: () => importFixName,
  importSymbols: () => importSymbols,
  parameterShouldGetTypeFromJSDoc: () => parameterShouldGetTypeFromJSDoc,
  registerCodeFix: () => registerCodeFix,
  setJsonCompilerOptionValue: () => setJsonCompilerOptionValue,
  setJsonCompilerOptionValues: () => setJsonCompilerOptionValues,
  tryGetAutoImportableReferenceFromTypeNode: () => tryGetAutoImportableReferenceFromTypeNode,
  typeToAutoImportableTypeNode: () => typeToAutoImportableTypeNode
});

// src/services/codeFixProvider.ts
var errorCodeToFixes = createMultiMap();
var fixIdToRegistration = /* @__PURE__ */ new Map();
function createCodeFixActionWithoutFixAll(fixName8, changes, description3) {
  return createCodeFixActionWorker(
    fixName8,
    diagnosticToString(description3),
    changes,
    /*fixId*/
    void 0,
    /*fixAllDescription*/
    void 0
  );
}
function createCodeFixAction(fixName8, changes, description3, fixId55, fixAllDescription, command) {
  return createCodeFixActionWorker(fixName8, diagnosticToString(description3), changes, fixId55, diagnosticToString(fixAllDescription), command);
}
function createCodeFixActionMaybeFixAll(fixName8, changes, description3, fixId55, fixAllDescription, command) {
  return createCodeFixActionWorker(fixName8, diagnosticToString(description3), changes, fixId55, fixAllDescription && diagnosticToString(fixAllDescription), command);
}
function createCodeFixActionWorker(fixName8, description3, changes, fixId55, fixAllDescription, command) {
  return { fixName: fixName8, description: description3, changes, fixId: fixId55, fixAllDescription, commands: command ? [command] : void 0 };
}
function registerCodeFix(reg) {
  for (const error2 of reg.errorCodes) {
    errorCodeToFixesArray = void 0;
    errorCodeToFixes.add(String(error2), reg);
  }
  if (reg.fixIds) {
    for (const fixId55 of reg.fixIds) {
      Debug.assert(!fixIdToRegistration.has(fixId55));
      fixIdToRegistration.set(fixId55, reg);
    }
  }
}
var errorCodeToFixesArray;
function getSupportedErrorCodes() {
  return errorCodeToFixesArray ?? (errorCodeToFixesArray = arrayFrom(errorCodeToFixes.keys()));
}
function removeFixIdIfFixAllUnavailable(registration, diagnostics) {
  const { errorCodes: errorCodes67 } = registration;
  let maybeFixableDiagnostics = 0;
  for (const diag2 of diagnostics) {
    if (contains(errorCodes67, diag2.code)) maybeFixableDiagnostics++;
    if (maybeFixableDiagnostics > 1) break;
  }
  const fixAllUnavailable = maybeFixableDiagnostics < 2;
  return ({ fixId: fixId55, fixAllDescription, ...action }) => {
    return fixAllUnavailable ? action : { ...action, fixId: fixId55, fixAllDescription };
  };
}
function getFixes(context) {
  const diagnostics = getDiagnostics(context);
  const registrations = errorCodeToFixes.get(String(context.errorCode));
  return flatMap(registrations, (f) => map(f.getCodeActions(context), removeFixIdIfFixAllUnavailable(f, diagnostics)));
}
function getAllFixes(context) {
  return fixIdToRegistration.get(cast(context.fixId, isString)).getAllCodeActions(context);
}
function createCombinedCodeActions(changes, commands) {
  return { changes, commands };
}
function createFileTextChanges(fileName, textChanges2) {
  return { fileName, textChanges: textChanges2 };
}
function codeFixAll(context, errorCodes67, use) {
  const commands = [];
  const changes = ts_textChanges_exports.ChangeTracker.with(context, (t) => eachDiagnostic(context, errorCodes67, (diag2) => use(t, diag2, commands)));
  return createCombinedCodeActions(changes, commands.length === 0 ? void 0 : commands);
}
function eachDiagnostic(context, errorCodes67, cb) {
  for (const diag2 of getDiagnostics(context)) {
    if (contains(errorCodes67, diag2.code)) {
      cb(diag2);
    }
  }
}
function getDiagnostics({ program, sourceFile, cancellationToken }) {
  const diagnostics = [
    ...program.getSemanticDiagnostics(sourceFile, cancellationToken),
    ...program.getSyntacticDiagnostics(sourceFile, cancellationToken),
    ...computeSuggestionDiagnostics(sourceFile, program, cancellationToken)
  ];
  if (getEmitDeclarations(program.getCompilerOptions())) {
    diagnostics.push(
      ...program.getDeclarationDiagnostics(sourceFile, cancellationToken)
    );
  }
  return diagnostics;
}

// src/services/codefixes/addConvertToUnknownForNonOverlappingTypes.ts
var fixId = "addConvertToUnknownForNonOverlappingTypes";
var errorCodes = [Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first.code];
registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToAddConvertToUnknownForNonOverlappingTypes(context) {
    const assertion = getAssertion(context.sourceFile, context.span.start);
    if (assertion === void 0) return void 0;
    const changes = ts_textChanges_exports.ChangeTracker.with(context, (t) => makeChange(t, context.sourceFile, assertion));
    return [createCodeFixAction(fixId, changes, Diagnostics.Add_unknown_conversion_for_non_overlapping_types, fixId, Diagnostics.Add_unknown_to_all_conversions_of_non_overlapping_types)];
  },
  fixIds: [fixId],
  getAllCodeActions: (context) => codeFixAll(context, errorCodes, (changes, diag2) => {
    const assertion = getAssertion(diag2.file, diag2.start);
    if (assertion) {
      makeChange(changes, diag2.file, assertion);
    }
  })
});
function makeChange(changeTracker, sourceFile, assertion) {
  const replacement = isAsExpression(assertion) ? factory.createAsExpression(assertion.expression, factory.createKeywordTypeNode(159 /* UnknownKeyword */)) : factory.createTypeAssertion(factory.createKeywordTypeNode(159 /* UnknownKeyword */), assertion.expression);
  changeTracker.replaceNode(sourceFile, assertion.expression, replacement);
}
function getAssertion(sourceFile, pos) {
  if (isInJSFile(sourceFile)) return void 0;
  return findAncestor(getTokenAtPosition(sourceFile, pos), (n) => isAsExpression(n) || isTypeAssertionExpression(n));
}

// src/services/codefixes/addEmptyExportDeclaration.ts
registerCodeFix({
  errorCodes: [
    Diagnostics.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module.code,
    Diagnostics.await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module.code,
    Diagnostics.for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module.code
  ],
  getCodeActions: function getCodeActionsToAddEmptyExportDeclaration(context) {
    const { sourceFile } = context;
    const changes = ts_textChanges_exports.ChangeTracker.with(context, (changes2) => {
      const exportDeclaration = factory.createExportDeclaration(
        /*modifiers*/
        void 0,
        /*isTypeOnly*/
        false,
        factory.createNamedExports([]),
        /*moduleSpecifier*/
        void 0
      );
      changes2.insertNodeAtEndOfScope(sourceFile, sourceFile, exportDeclaration);
    });
    return [createCodeFixActionWithoutFixAll("addEmptyExportDeclaration", changes, Diagnostics.Add_export_to_make_this_file_into_a_module)];
  }
});

// src/services/codefixes/addMissingAsync.ts
var fixId2 = "addMissingAsync";
var errorCodes2 = [
  Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1.code,
  Diagnostics.Type_0_is_not_assignable_to_type_1.code,
  Diagnostics.Type_0_is_not_comparable_to_type_1.code
];
registerCodeFix({
  fixIds: [fixId2],
  errorCodes: errorCodes2,
  getCodeActions: function getCodeActionsToAddMissingAsync(context) {
    const { sourceFile, errorCode, cancellationToken, program, span } = context;
    const diagnostic = find(program.getTypeChecker().getDiagnostics(sourceFile, cancellationToken), getIsMatchingAsyncError(span, errorCode));
    const directSpan = diagnostic && diagnostic.relatedInformation && find(diagnostic.relatedInformation, (r) => r.code === Diagnostics.Did_you_mean_to_mark_this_function_as_async.code);
    const decl = getFixableErrorSpanDeclaration(sourceFile, directSpan);
    if (!decl) {
      return;
    }
    const trackChanges = (cb) => ts_textChanges_exports.ChangeTracker.with(context, cb);
    return [getFix(context, decl, trackChanges)];
  },
  getAllCodeActions: (context) => {
    const { sourceFile } = context;
    const fixedDeclarations = /* @__PURE__ */ new Set();
    return codeFixAll(context, errorCodes2, (t, diagnostic) => {
      const span = diagnostic.relatedInformation && find(diagnostic.relatedInformation, (r) => r.code === Diagnostics.Did_you_mean_to_mark_this_function_as_async.code);
      const decl = getFixableErrorSpanDeclaration(sourceFile, span);
      if (!decl) {
        return;
      }
      const trackChanges = (cb) => (cb(t), []);
      return getFix(context, decl, trackChanges, fixedDeclarations);
    });
  }
});
function getFix(context, decl, trackChanges, fixedDeclarations) {
  const changes = trackChanges((t) => makeChange2(t, context.sourceFile, decl, fixedDeclarations));
  return createCodeFixAction(fixId2, changes, Diagnostics.Add_async_modifier_to_containing_function, fixId2, Diagnostics.Add_all_missing_async_modifiers);
}
function makeChange2(changeTracker, sourceFile, insertionSite, fixedDeclarations) {
  if (fixedDeclarations) {
    if (fixedDeclarations.has(getNodeId(insertionSite))) {
      return;
    }
  }
  fixedDeclarations == null ? void 0 : fixedDeclarations.add(getNodeId(insertionSite));
  const cloneWithModifier = factory.replaceModifiers(
    getSynthesizedDeepClone(
      insertionSite,
      /*includeTrivia*/
      true
    ),
    factory.createNodeArray(factory.createModifiersFromModifierFlags(getSyntacticModifierFlags(insertionSite) | 1024 /* Async */))
  );
  changeTracker.replaceNode(
    sourceFile,
    insertionSite,
    cloneWithModifier
  );
}
function getFixableErrorSpanDeclaration(sourceFile, span) {
  if (!span) return void 0;
  const token = getTokenAtPosition(sourceFile, span.start);
  const decl = findAncestor(token, (node) => {
    if (node.getStart(sourceFile) < span.start || node.getEnd() > textSpanEnd(span)) {
      return "quit";
    }
    return (isArrowFunction(node) || isMethodDeclaration(node) || isFunctionExpression(node) || isFunctionDeclaration(node)) && textSpansEqual(span, createTextSpanFromNode(node, sourceFile));
  });
  return decl;
}
function getIsMatchingAsyncError(span, errorCode) {
  return ({ start, length: length2, relatedInformation, code }) => isNumber(start) && isNumber(length2) && textSpansEqual({ start, length: length2 }, span) && code === errorCode && !!relatedInformation && some(relatedInformation, (related) => related.code === Diagnostics.Did_you_mean_to_mark_this_function_as_async.code);
}

// src/services/codefixes/addMissingAwait.ts
var fixId3 = "addMissingAwait";
var propertyAccessCode = Diagnostics.Property_0_does_not_exist_on_type_1.code;
var callableConstructableErrorCodes = [
  Diagnostics.This_expression_is_not_callable.code,
  Diagnostics.This_expression_is_not_constructable.code
];
var errorCodes3 = [
  Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type.code,
  Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type.code,
  Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type.code,
  Diagnostics.Operator_0_cannot_be_applied_to_type_1.code,
  Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2.code,
  Diagnostics.This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap.code,
  Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined.code,
  Diagnostics.Type_0_is_not_an_array_type.code,
  Diagnostics.Type_0_is_not_an_array_type_or_a_string_type.code,
  Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher.code,
  Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator.code,
  Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator.code,
  Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator.code,
  Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator.code,
  Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1.code,
  propertyAccessCode,
  ...callableConstructableErrorCodes
];
registerCodeFix({
  fixIds: [fixId3],
  errorCodes: errorCodes3,
  getCodeActions: function getCodeActionsToAddMissingAwait(context) {
    const { sourceFile, errorCode, span, cancellationToken, program } = context;
    const expression = getAwaitErrorSpanExpression(sourceFile, errorCode, span, cancellationToken, program);
    if (!expression) {
      return;
    }
    const checker = context.program.getTypeChecker();
    const trackChanges = (cb) => ts_textChanges_exports.ChangeTracker.with(context, cb);
    return compact([
      getDeclarationSiteFix(context, expression, errorCode, checker, trackChanges),
      getUseSiteFix(context, expression, errorCode, checker, trackChanges)
    ]);
  },
  getAllCodeActions: (context) => {
    const { sourceFile, program, cancellationToken } = context;
    const checker = context.program.getTypeChecker();
    const fixedDeclarations = /* @__PURE__ */ new Set();
    return codeFixAll(context, errorCodes3, (t, diagnostic) => {
      const expression = getAwaitErrorSpanExpression(sourceFile, diagnostic.code, diagnostic, cancellationToken, program);
      if (!expression) {
        return;
      }
      const trackChanges = (cb) => (cb(t), []);
      return getDeclarationSiteFix(context, expression, diagnostic.code, checker, trackChanges, fixedDeclarations) || getUseSiteFix(context, expression, diagnostic.code, checker, trackChanges, fixedDeclarations);
    });
  }
});
function getAwaitErrorSpanExpression(sourceFile, errorCode, span, cancellationToken, program) {
  const expression = getFixableErrorSpanExpression(sourceFile, span);
  return expression && isMissingAwaitError(sourceFile, errorCode, span, cancellationToken, program) && isInsideAwaitableBody(expression) ? expression : void 0;
}
function getDeclarationSiteFix(context, expression, errorCode, checker, trackChanges, fixedDeclarations) {
  const { sourceFile, program, cancellationToken } = context;
  const awaitableInitializers = findAwaitableInitializers(expression, sourceFile, cancellationToken, program, checker);
  if (awaitableInitializers) {
    const initializerChanges = trackChanges((t) => {
      forEach(awaitableInitializers.initializers, ({ expression: expression2 }) => makeChange3(t, errorCode, sourceFile, checker, expression2, fixedDeclarations));
      if (fixedDeclarations && awaitableInitializers.needsSecondPassForFixAll) {
        makeChange3(t, errorCode, sourceFile, checker, expression, fixedDeclarations);
      }
    });
    return createCodeFixActionWithoutFixAll(
      "addMissingAwaitToInitializer",
      initializerChanges,
      awaitableInitializers.initializers.length === 1 ? [Diagnostics.Add_await_to_initializer_for_0, awaitableInitializers.initializers[0].declarationSymbol.name] : Diagnostics.Add_await_to_initializers
    );
  }
}
function getUseSiteFix(context, expression, errorCode, checker, trackChanges, fixedDeclarations) {
  const changes = trackChanges((t) => makeChange3(t, errorCode, context.sourceFile, checker, expression, fixedDeclarations));
  return createCodeFixAction(fixId3, changes, Diagnostics.Add_await, fixId3, Diagnostics.Fix_all_expressions_possibly_missing_await);
}
function isMissingAwaitError(sourceFile, errorCode, span, cancellationToken, program) {
  const checker = program.getTypeChecker();
  const diagnostics = checker.getDiagnostics(sourceFile, cancellationToken);
  return some(diagnostics, ({ start, length: length2, relatedInformation, code }) => isNumber(start) && isNumber(length2) && textSpansEqual({ start, length: length2 }, span) && code === errorCode && !!relatedInformation && some(relatedInformation, (related) => related.code === Diagnostics.Did_you_forget_to_use_await.code));
}
function findAwaitableInitializers(expression, sourceFile, cancellationToken, program, checker) {
  const identifiers = getIdentifiersFromErrorSpanExpression(expression, checker);
  if (!identifiers) {
    return;
  }
  let isCompleteFix = identifiers.isCompleteFix;
  let initializers;
  for (const identifier of identifiers.identifiers) {
    const symbol = checker.getSymbolAtLocation(identifier);
    if (!symbol) {
      continue;
    }
    const declaration = tryCast(symbol.valueDeclaration, isVariableDeclaration);
    const variableName = declaration && tryCast(declaration.name, isIdentifier);
    const variableStatement = getAncestor(declaration, 243 /* VariableStatement */);
    if (!declaration || !variableStatement || declaration.type || !declaration.initializer || variableStatement.getSourceFile() !== sourceFile || hasSyntacticModifier(variableStatement, 32 /* Export */) || !variableName || !isInsideAwaitableBody(declaration.initializer)) {
      isCompleteFix = false;
      continue;
    }
    const diagnostics = program.getSemanticDiagnostics(sourceFile, cancellationToken);
    const isUsedElsewhere = ts_FindAllReferences_exports.Core.eachSymbolReferenceInFile(variableName, checker, sourceFile, (reference) => {
      return identifier !== reference && !symbolReferenceIsAlsoMissingAwait(reference, diagnostics, sourceFile, checker);
    });
    if (isUsedElsewhere) {
      isCompleteFix = false;
      continue;
    }
    (initializers || (initializers = [])).push({
      expression: declaration.initializer,
      declarationSymbol: symbol
    });
  }
  return initializers && {
    initializers,
    needsSecondPassForFixAll: !isCompleteFix
  };
}
function getIdentifiersFromErrorSpanExpression(expression, checker) {
  if (isPropertyAccessExpression(expression.parent) && isIdentifier(expression.parent.expression)) {
    return { identifiers: [expression.parent.expression], isCompleteFix: true };
  }
  if (isIdentifier(expression)) {
    return { identifiers: [expression], isCompleteFix: true };
  }
  if (isBinaryExpression(expression)) {
    let sides;
    let isCompleteFix = true;
    for (const side of [expression.left, expression.right]) {
      const type = checker.getTypeAtLocation(side);
      if (checker.getPromisedTypeOfPromise(type)) {
        if (!isIdentifier(side)) {
          isCompleteFix = false;
          continue;
        }
        (sides || (sides = [])).push(side);
      }
    }
    return sides && { identifiers: sides, isCompleteFix };
  }
}
function symbolReferenceIsAlsoMissingAwait(reference, diagnostics, sourceFile, checker) {
  const errorNode = isPropertyAccessExpression(reference.parent) ? reference.parent.name : isBinaryExpression(reference.parent) ? reference.parent : reference;
  const diagnostic = find(diagnostics, (diagnostic2) => diagnostic2.start === errorNode.getStart(sourceFile) && diagnostic2.start + diagnostic2.length === errorNode.getEnd());
  return diagnostic && contains(errorCodes3, diagnostic.code) || // A Promise is usually not correct in a binary expression (it's not valid
  // in an arithmetic expression and an equality comparison seems unusual),
  // but if the other side of the binary expression has an error, the side
  // is typed `any` which will squash the error that would identify this
  // Promise as an invalid operand. So if the whole binary expression is
  // typed `any` as a result, there is a strong likelihood that this Promise
  // is accidentally missing `await`.
  checker.getTypeAtLocation(errorNode).flags & 1 /* Any */;
}
function isInsideAwaitableBody(node) {
  return node.flags & 65536 /* AwaitContext */ || !!findAncestor(node, (ancestor) => ancestor.parent && isArrowFunction(ancestor.parent) && ancestor.parent.body === ancestor || isBlock(ancestor) && (ancestor.parent.kind === 262 /* FunctionDeclaration */ || ancestor.parent.kind === 218 /* FunctionExpression */ || ancestor.parent.kind === 219 /* ArrowFunction */ || ancestor.parent.kind === 174 /* MethodDeclaration */));
}
function makeChange3(changeTracker, errorCode, sourceFile, checker, insertionSite, fixedDeclarations) {
  if (isForOfStatement(insertionSite.parent) && !insertionSite.parent.awaitModifier) {
    const exprType = checker.getTypeAtLocation(insertionSite);
    const asyncIter = checker.getAsyncIterableType();
    if (asyncIter && checker.isTypeAssignableTo(exprType, asyncIter)) {
      const forOf = insertionSite.parent;
      changeTracker.replaceNode(sourceFile, forOf, factory.updateForOfStatement(forOf, factory.createToken(135 /* AwaitKeyword */), forOf.initializer, forOf.expression, forOf.statement));
      return;
    }
  }
  if (isBinaryExpression(insertionSite)) {
    for (const side of [insertionSite.left, insertionSite.right]) {
      if (fixedDeclarations && isIdentifier(side)) {
        const symbol = checker.getSymbolAtLocation(side);
        if (symbol && fixedDeclarations.has(getSymbolId(symbol))) {
          continue;
        }
      }
      const type = checker.getTypeAtLocation(side);
      const newNode = checker.getPromisedTypeOfPromise(type) ? factory.createAwaitExpression(side) : side;
      changeTracker.replaceNode(sourceFile, side, newNode);
    }
  } else if (errorCode === propertyAccessCode && isPropertyAccessExpression(insertionSite.parent)) {
    if (fixedDeclarations && isIdentifier(insertionSite.parent.expression)) {
      const symbol = checker.getSymbolAtLocation(insertionSite.parent.expression);
      if (symbol && fixedDeclarations.has(getSymbolId(symbol))) {
        return;
      }
    }
    changeTracker.replaceNode(
      sourceFile,
      insertionSite.parent.expression,
      factory.createParenthesizedExpression(factory.createAwaitExpression(insertionSite.parent.expression))
    );
    insertLeadingSemicolonIfNeeded(changeTracker, insertionSite.parent.expression, sourceFile);
  } else if (contains(callableConstructableErrorCodes, errorCode) && isCallOrNewExpression(insertionSite.parent)) {
    if (fixedDeclarations && isIdentifier(insertionSite)) {
      const symbol = checker.getSymbolAtLocation(insertionSite);
      if (symbol && fixedDeclarations.has(getSymbolId(symbol))) {
        return;
      }
    }
    changeTracker.replaceNode(sourceFile, insertionSite, factory.createParenthesizedExpression(factory.createAwaitExpression(insertionSite)));
    insertLeadingSemicolonIfNeeded(changeTracker, insertionSite, sourceFile);
  } else {
    if (fixedDeclarations && isVariableDeclaration(insertionSite.parent) && isIdentifier(insertionSite.parent.name)) {
      const symbol = checker.getSymbolAtLocation(insertionSite.parent.name);
      if (symbol && !tryAddToSet(fixedDeclarations, getSymbolId(symbol))) {
        return;
      }
    }
    changeTracker.replaceNode(sourceFile, insertionSite, factory.createAwaitExpression(insertionSite));
  }
}
function insertLeadingSemicolonIfNeeded(changeTracker, beforeNode, sourceFile) {
  const precedingToken = findPrecedingToken(beforeNode.pos, sourceFile);
  if (precedingToken && positionIsASICandidate(precedingToken.end, precedingToken.parent, sourceFile)) {
    changeTracker.insertText(sourceFile, beforeNode.getStart(sourceFile), ";");
  }
}

// src/services/codefixes/addMissingConst.ts
var fixId4 = "addMissingConst";
var errorCodes4 = [
  Diagnostics.Cannot_find_name_0.code,
  Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer.code
];
registerCodeFix({
  errorCodes: errorCodes4,
  getCodeActions: function getCodeActionsToAddMissingConst(context) {
    const changes = ts_textChanges_exports.ChangeTracker.with(context, (t) => makeChange4(t, context.sourceFile, context.span.start, context.program));
    if (changes.length > 0) {
      return [createCodeFixAction(fixId4, changes, Diagnostics.Add_const_to_unresolved_variable, fixId4, Diagnostics.Add_const_to_all_unresolved_variables)];
    }
  },
  fixIds: [fixId4],
  getAllCodeActions: (context) => {
    const fixedNodes = /* @__PURE__ */ new Set();
    return codeFixAll(context, errorCodes4, (changes, diag2) => makeChange4(changes, diag2.file, diag2.start, context.program, fixedNodes));
  }
});
function makeChange4(changeTracker, sourceFile, pos, program, fixedNodes) {
  const token = getTokenAtPosition(sourceFile, pos);
  const forInitializer = findAncestor(token, (node) => isForInOrOfStatement(node.parent) ? node.parent.initializer === node : isPossiblyPartOfDestructuring(node) ? false : "quit");
  if (forInitializer) return applyChange(changeTracker, forInitializer, sourceFile, fixedNodes);
  const parent2 = token.parent;
  if (isBinaryExpression(parent2) && parent2.operatorToken.kind === 64 /* EqualsToken */ && isExpressionStatement(parent2.parent)) {
    return applyChange(changeTracker, token, sourceFile, fixedNodes);
  }
  if (isArrayLiteralExpression(parent2)) {
    const checker = program.getTypeChecker();
    if (!every(parent2.elements, (element) => arrayElementCouldBeVariableDeclaration(element, checker))) {
      return;
    }
    return applyChange(changeTracker, parent2, sourceFile, fixedNodes);
  }
  const commaExpression = findAncestor(token, (node) => isExpressionStatement(node.parent) ? true : isPossiblyPartOfCommaSeperatedInitializer(node) ? false : "quit");
  if (commaExpression) {
    const checker = program.getTypeChecker();
    if (!expressionCouldBeVariableDeclaration(commaExpression, checker)) {
      return;
    }
    return applyChange(changeTracker, commaExpression, sourceFile, fixedNodes);
  }
}
function applyChange(changeTracker, initializer, sourceFile, fixedNodes) {
  if (!fixedNodes || tryAddToSet(fixedNodes, initializer)) {
    changeTracker.insertModifierBefore(sourceFile, 87 /* ConstKeyword */, initializer);
  }
}
function isPossiblyPartOfDestructuring(node) {
  switch (node.kind) {
    case 80 /* Identifier */:
    case 209 /* ArrayLiteralExpression */:
    case 210 /* ObjectLiteralExpression */:
    case 303 /* PropertyAssignment */:
    case 304 /* ShorthandPropertyAssignment */:
      return true;
    default:
      return false;
  }
}
function arrayElementCouldBeVariableDeclaration(expression, checker) {
  const identifier = isIdentifier(expression) ? expression : isAssignmentExpression(
    expression,
    /*excludeCompoundAssignment*/
    true
  ) && isIdentifier(expression.left) ? expression.left : void 0;
  return !!identifier && !checker.getSymbolAtLocation(identifier);
}
function isPossiblyPartOfCommaSeperatedInitializer(node) {
  switch (node.kind) {
    case 80 /* Identifier */:
    case 226 /* BinaryExpression */:
    case 28 /* CommaToken */:
      return true;
    default:
      return false;
  }
}
function expressionCouldBeVariableDeclaration(expression, checker) {
  if (!isBinaryExpression(expression)) {
    return false;
  }
  if (expression.operatorToken.kind === 28 /* CommaToken */) {
    return every([expression.left, expression.right], (expression2) => expressionCouldBeVariableDeclaration(expression2, checker));
  }
  return expression.operatorToken.kind === 64 /* EqualsToken */ && isIdentifier(expression.left) && !checker.getSymbolAtLocation(expression.left);
}

// src/services/codefixes/addMissingDeclareProperty.ts
var fixId5 = "addMissingDeclareProperty";
var errorCodes5 = [
  Diagnostics.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration.code
];
registerCodeFix({
  errorCodes: errorCodes5,
  getCodeActions: function getCodeActionsToAddMissingDeclareOnProperty(context) {
    const changes = ts_textChanges_exports.ChangeTracker.with(context, (t) => makeChange5(t, context.sourceFile, context.span.start));
    if (changes.length > 0) {
      return [createCodeFixAction(fixId5, changes, Diagnostics.Prefix_with_declare, fixId5, Diagnostics.Prefix_all_incorrect_property_declarations_with_declare)];
    }
  },
  fixIds: [fixId5],
  getAllCodeActions: (context) => {
    const fixedNodes = /* @__PURE__ */ new Set();
    return codeFixAll(context, errorCodes5, (changes, diag2) => makeChange5(changes, diag2.file, diag2.start, fixedNodes));
  }
});
function makeChange5(changeTracker, sourceFile, pos, fixedNodes) {
  const token = getTokenAtPosition(sourceFile, pos);
  if (!isIdentifier(token)) {
    return;
  }
  const declaration = token.parent;
  if (declaration.kind === 172 /* PropertyDeclaration */ && (!fixedNodes || tryAddToSet(fixedNodes, declaration))) {
    changeTracker.insertModifierBefore(sourceFile, 138 /* DeclareKeyword */, declaration);
  }
}

// src/services/codefixes/addMissingInvocationForDecorator.ts
var fixId6 = "addMissingInvocationForDecorator";
var errorCodes6 = [Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0.code];
registerCodeFix({
  errorCodes: errorCodes6,
  getCodeActions: function getCodeActionsToAddMissingInvocationForDecorator(context) {
    const changes = ts_textChanges_exports.ChangeTracker.with(context, (t) => makeChange6(t, context.sourceFile, context.span.start));
    return [createCodeFixAction(fixId6, changes, Diagnostics.Call_decorator_expression, fixId6, Diagnostics.Add_to_all_uncalled_decorators)];
  },
  fixIds: [fixId6],
  getAllCodeActions: (context) => codeFixAll(context, errorCodes6, (changes, diag2) => makeChange6(changes, diag2.file, diag2.start))
});
function makeChange6(changeTracker, sourceFile, pos) {
  const token = getTokenAtPosition(sourceFile, pos);
  const decorator = findAncestor(token, isDecorator);
  Debug.assert(!!decorator, "Expected position to be owned by a decorator.");
  const replacement = factory.createCallExpression(
    decorator.expression,
    /*typeArguments*/
    void 0,
    /*argumentsArray*/
    void 0
  );
  changeTracker.replaceNode(sourceFile, decorator.expression, replacement);
}

// src/services/codefixes/addNameToNamelessParameter.ts
var fixId7 = "addNameToNamelessParameter";
var errorCodes7 = [Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1.code];
registerCodeFix({
  errorCodes: errorCodes7,
  getCodeActions: function getCodeActionsToAddNameToNamelessParameter(context) {
    const changes = ts_textChanges_exports.ChangeTracker.with(context, (t) => makeChange7(t, context.sourceFile, context.span.start));
    return [createCodeFixAction(fixId7, changes, Diagnostics.Add_parameter_name, fixId7, Diagnostics.Add_names_to_all_parameters_without_names)];
  },
  fixIds: [fixId7],
  getAllCodeActions: (context) => codeFixAll(context, errorCodes7, (changes, diag2) => makeChange7(changes, diag2.file, diag2.start))
});
function makeChange7(changeTracker, sourceFile, start) {
  const token = getTokenAtPosition(sourceFile, start);
  const param = token.parent;
  if (!isParameter(param)) {
    return Debug.fail("Tried to add a parameter name to a non-parameter: " + Debug.formatSyntaxKind(token.kind));
  }
  const i = param.parent.parameters.indexOf(param);
  Debug.assert(!param.type, "Tried to add a parameter name to a parameter that already had one.");
  Debug.assert(i > -1, "Parameter not found in parent parameter list.");
  let end = param.name.getEnd();
  let typeNode = factory.createTypeReferenceNode(
    param.name,
    /*typeArguments*/
    void 0
  );
  let nextParam = tryGetNextParam(sourceFile, param);
  while (nextParam) {
    typeNode = factory.createArrayTypeNode(typeNode);
    end = nextParam.getEnd();
    nextParam = tryGetNextParam(sourceFile, nextParam);
  }
  const replacement = factory.createParameterDeclaration(
    param.modifiers,
    param.dotDotDotToken,
    "arg" + i,
    param.questionToken,
    param.dotDotDotToken && !isArrayTypeNode(typeNode) ? factory.createArrayTypeNode(typeNode) : typeNode,
    param.initializer
  );
  changeTracker.replaceRange(sourceFile, createRange(param.getStart(sourceFile), end), replacement);
}
function tryGetNextParam(sourceFile, param) {
  const nextToken = findNextToken(param.name, param.parent, sourceFile);
  if (nextToken && nextToken.kind === 23 /* OpenBracketToken */ && isArrayBindingPattern(nextToken.parent) && isParameter(nextToken.parent.parent)) {
    return nextToken.parent.parent;
  }
  return void 0;
}

// src/services/codefixes/addOptionalPropertyUndefined.ts
var addOptionalPropertyUndefined = "addOptionalPropertyUndefined";
var errorCodes8 = [
  Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target.code,
  Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties.code,
  Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties.code
];
registerCodeFix({
  errorCodes: errorCodes8,
  getCodeActions(context) {
    const typeChecker = context.program.getTypeChecker();
    const toAdd = getPropertiesToAdd(context.sourceFile, context.span, typeChecker);
    if (!toAdd.length) {
      return void 0;
    }
    const changes = ts_textChanges_exports.ChangeTracker.with(context, (t) => addUndefinedToOptionalProperty(t, toAdd));
    return [createCodeFixActionWithoutFixAll(addOptionalPropertyUndefined, changes, Diagnostics.Add_undefined_to_optional_property_type)];
  },
  fixIds: [addOptionalPropertyUndefined]
});
function getPropertiesToAdd(file, span, checker) {
  var _a, _b;
  const sourceTarget = getSourceTarget(getFixableErrorSpanExpression(file, span), checker);
  if (!sourceTarget) {
    return emptyArray;
  }
  const { source: sourceNode, target: targetNode } = sourceTarget;
  const target = shouldUseParentTypeOfProperty(sourceNode, targetNode, checker) ? checker.getTypeAtLocation(targetNode.expression) : checker.getTypeAtLocation(targetNode);
  if ((_b = (_a = target.symbol) == null ? void 0 : _a.declarations) == null ? void 0 : _b.some((d) => getSourceFileOfNode(d).fileName.match(/\.d\.ts$/))) {
    return emptyArray;
  }
  return checker.getExactOptionalProperties(target);
}
function shouldUseParentTypeOfProperty(sourceNode, targetNode, checker) {
  return isPropertyAccessExpression(targetNode) && !!checker.getExactOptionalProperties(checker.getTypeAtLocation(targetNode.expression)).length && checker.getTypeAtLocation(sourceNode) === checker.getUndefinedType();
}
function getSourceTarget(errorNode, checker) {
  var _a;
  if (!errorNode) {
    return void 0;
  } else if (isBinaryExpression(errorNode.parent) && errorNode.parent.operatorToken.kind === 64 /* EqualsToken */) {
    return { source: errorNode.parent.right, target: errorNode.parent.left };
  } else if (isVariableDeclaration(errorNode.parent) && errorNode.parent.initializer) {
    return { source: errorNode.parent.initializer, target: errorNode.parent.name };
  } else if (isCallExpression(errorNode.parent)) {
    const n = checker.getSymbolAtLocation(errorNode.parent.expression);
    if (!(n == null ? void 0 : n.valueDeclaration) || !isFunctionLikeKind(n.valueDeclaration.kind)) return void 0;
    if (!isExpression(errorNode)) return void 0;
    const i = errorNode.parent.arguments.indexOf(errorNode);
    if (i === -1) return void 0;
    const name = n.valueDeclaration.parameters[i].name;
    if (isIdentifier(name)) return { source: errorNode, target: name };
  } else if (isPropertyAssignment(errorNode.parent) && isIdentifier(errorNode.parent.name) || isShorthandPropertyAssignment(errorNode.parent)) {
    const parentTarget = getSourceTarget(errorNode.parent.parent, checker);
    if (!parentTarget) return void 0;
    const prop = checker.getPropertyOfType(checker.getTypeAtLocation(parentTarget.target), errorNode.parent.name.text);
    const declaration = (_a = prop == null ? void 0 : prop.declarations) == null ? void 0 : _a[0];
    if (!declaration) return void 0;
    return {
      source: isPropertyAssignment(errorNode.parent) ? errorNode.parent.initializer : errorNode.parent.name,
      target: declaration
    };
  }
  return void 0;
}
function addUndefinedToOptionalProperty(changes, toAdd) {
  for (const add of toAdd) {
    const d = add.valueDeclaration;
    if (d && (isPropertySignature(d) || isPropertyDeclaration(d)) && d.type) {
      const t = factory.createUnionTypeNode([
        ...d.type.kind === 192 /* UnionType */ ? d.type.types : [d.type],
        factory.createTypeReferenceNode("undefined")
      ]);
      changes.replaceNode(d.getSourceFile(), d.type, t);
    }
  }
}

// src/services/codefixes/annotateWithTypeFromJSDoc.ts
var fixId8 = "annotateWithTypeFromJSDoc";
var errorCodes9 = [Diagnostics.JSDoc_types_may_be_moved_to_TypeScript_types.code];
registerCodeFix({
  errorCodes: errorCodes9,
  getCodeActions(context) {
    const decl = getDeclaration(context.sourceFile, context.span.start);
    if (!decl) return;
    const changes = ts_textChanges_exports.ChangeTracker.with(context, (t) => doChange8(t, context.sourceFile, decl));
    return [createCodeFixAction(fixId8, changes, Diagnostics.Annotate_with_type_from_JSDoc, fixId8, Diagnostics.Annotate_everything_with_types_from_JSDoc)];
  },
  fixIds: [fixId8],
  getAllCodeActions: (context) => codeFixAll(context, errorCodes9, (changes, diag2) => {
    const decl = getDeclaration(diag2.file, diag2.start);
    if (decl) doChange8(changes, diag2.file, decl);
  })
});
function getDeclaration(file, pos) {
  const name = getTokenAtPosition(file, pos);
  return tryCast(isParameter(name.parent) ? name.parent.parent : name.parent, parameterShouldGetTypeFromJSDoc);
}
function parameterShouldGetTypeFromJSDoc(node) {
  return isDeclarationWithType(node) && hasUsableJSDoc(node);
}
function hasUsableJSDoc(decl) {
  return isFunctionLikeDeclaration(decl) ? decl.parameters.some(hasUsableJSDoc) || !decl.type && !!getJSDocReturnType(decl) : !decl.type && !!getJSDocType(decl);
}
function doChange8(changes, sourceFile, decl) {
  if (isFunctionLikeDeclaration(decl) && (getJSDocReturnType(decl) || decl.parameters.some((p) => !!getJSDocType(p)))) {
    if (!decl.typeParameters) {
      const typeParameters = getJSDocTypeParameterDeclarations(decl);
      if (typeParameters.length) changes.insertTypeParameters(sourceFile, decl, typeParameters);
    }
    const needParens = isArrowFunction(decl) && !findChildOfKind(decl, 21 /* OpenParenToken */, sourceFile);
    if (needParens) changes.insertNodeBefore(sourceFile, first(decl.parameters), factory.createToken(21 /* OpenParenToken */));
    for (const param of decl.parameters) {
      if (!param.type) {
        const paramType = getJSDocType(param);
        if (paramType) changes.tryInsertTypeAnnotation(sourceFile, param, visitNode(paramType, transformJSDocType, isTypeNode));
      }
    }
    if (needParens) changes.insertNodeAfter(sourceFile, last(decl.parameters), factory.createToken(22 /* CloseParenToken */));
    if (!decl.type) {
      const returnType = getJSDocReturnType(decl);
      if (returnType) changes.tryInsertTypeAnnotation(sourceFile, decl, visitNode(returnType, transformJSDocType, isTypeNode));
    }
  } else {
    const jsdocType = Debug.checkDefined(getJSDocType(decl), "A JSDocType for this declaration should exist");
    Debug.assert(!decl.type, "The JSDocType decl should have a type");
    changes.tryInsertTypeAnnotation(sourceFile, decl, visitNode(jsdocType, transformJSDocType, isTypeNode));
  }
}
function isDeclarationWithType(node) {
  return isFunctionLikeDeclaration(node) || node.kind === 260 /* VariableDeclaration */ || node.kind === 171 /* PropertySignature */ || node.kind === 172 /* PropertyDeclaration */;
}
function transformJSDocType(node) {
  switch (node.kind) {
    case 312 /* JSDocAllType */:
    case 313 /* JSDocUnknownType */:
      return factory.createTypeReferenceNode("any", emptyArray);
    case 316 /* JSDocOptionalType */:
      return transformJSDocOptionalType(node);
    case 315 /* JSDocNonNullableType */:
      return transformJSDocType(node.type);
    case 314 /* JSDocNullableType */:
      return transformJSDocNullableType(node);
    case 318 /* JSDocVariadicType */:
      return transformJSDocVariadicType(node);
    case 317 /* JSDocFunctionType */:
      return transformJSDocFunctionType(node);
    case 183 /* TypeReference */:
      return transformJSDocTypeReference(node);
    case 322 /* JSDocTypeLiteral */:
      return transformJSDocTypeLiteral(node);
    default:
      const visited = visitEachChild(
        node,
        transformJSDocType,
        /*context*/
        void 0
      );
      setEmitFlags(visited, 1 /* SingleLine */);
      return visited;
  }
}
function transformJSDocTypeLiteral(node) {
  const typeNode = factory.createTypeLiteralNode(map(node.jsDocPropertyTags, (tag) => factory.createPropertySignature(
    /*modifiers*/
    void 0,
    isIdentifier(tag.name) ? tag.name : tag.name.right,
    isOptionalJSDocPropertyLikeTag(tag) ? factory.createToken(58 /* QuestionToken */) : void 0,
    tag.typeExpression && visitNode(tag.typeExpression.type, transformJSDocType, isTypeNode) || factory.createKeywordTypeNode(133 /* AnyKeyword */)
  )));
  setEmitFlags(typeNode, 1 /* SingleLine */);
  return typeNode;
}
function transformJSDocOptionalType(node) {
  return factory.createUnionTypeNode([visitNode(node.type, transformJSDocType, isTypeNode), factory.createTypeReferenceNode("undefined", emptyArray)]);
}
function transformJSDocNullableType(node) {
  return factory.createUnionTypeNode([visitNode(node.type, transformJSDocType, isTypeNode), factory.createTypeReferenceNode("null", emptyArray)]);
}
function transformJSDocVariadicType(node) {
  return factory.createArrayTypeNode(visitNode(node.type, transformJSDocType, isTypeNode));
}
function transformJSDocFunctionType(node) {
  return factory.createFunctionTypeNode(emptyArray, node.parameters.map(transformJSDocParameter), node.type ?? factory.createKeywordTypeNode(133 /* AnyKeyword */));
}
function transformJSDocParameter(node) {
  const index = node.parent.parameters.indexOf(node);
  const isRest = node.type.kind === 318 /* JSDocVariadicType */ && index === node.parent.parameters.length - 1;
  const name = node.name || (isRest ? "rest" : "arg" + index);
  const dotdotdot = isRest ? factory.createToken(26 /* DotDotDotToken */) : node.dotDotDotToken;
  return factory.createParameterDeclaration(node.modifiers, dotdotdot, name, node.questionToken, visitNode(node.type, transformJSDocType, isTypeNode), node.initializer);
}
function transformJSDocTypeReference(node) {
  let name = node.typeName;
  let args = node.typeArguments;
  if (isIdentifier(node.typeName)) {
    if (isJSDocIndexSignature(node)) {
      return transformJSDocIndexSignature(node);
    }
    let text = node.typeName.text;
    switch (node.typeName.text) {
      case "String":
      case "Boolean":
      case "Object":
      case "Number":
        text = text.toLowerCase();
        break;
      case "array":
      case "date":
      case "promise":
        text = text[0].toUpperCase() + text.slice(1);
        break;
    }
    name = factory.createIdentifier(text);
    if ((text === "Array" || text === "Promise") && !node.typeArguments) {
      args = factory.createNodeArray([factory.createTypeReferenceNode("any", emptyArray)]);
    } else {
      args = visitNodes2(node.typeArguments, transformJSDocType, isTypeNode);
    }
  }
  return factory.createTypeReferenceNode(name, args);
}
function transformJSDocIndexSignature(node) {
  const index = factory.createParameterDeclaration(
    /*modifiers*/
    void 0,
    /*dotDotDotToken*/
    void 0,
    node.typeArguments[0].kind === 150 /* NumberKeyword */ ? "n" : "s",
    /*questionToken*/
    void 0,
    factory.createTypeReferenceNode(node.typeArguments[0].kind === 150 /* NumberKeyword */ ? "number" : "string", []),
    /*initializer*/
    void 0
  );
  const indexSignature = factory.createTypeLiteralNode([factory.createIndexSignature(
    /*modifiers*/
    void 0,
    [index],
    node.typeArguments[1]
  )]);
  setEmitFlags(indexSignature, 1 /* SingleLine */);
  return indexSignature;
}

// src/services/codefixes/convertFunctionToEs6Class.ts
var fixId9 = "convertFunctionToEs6Class";
var errorCodes10 = [Diagnostics.This_constructor_function_may_be_converted_to_a_class_declaration.code];
registerCodeFix({
  errorCodes: errorCodes10,
  getCodeActions(context) {
    const changes = ts_textChanges_exports.ChangeTracker.with(context, (t) => doChange9(t, context.sourceFile, context.span.start, context.program.getTypeChecker(), context.preferences, context.program.getCompilerOptions()));
    return [createCodeFixAction(fixId9, changes, Diagnostics.Convert_function_to_an_ES2015_class, fixId9, Diagnostics.Convert_all_constructor_functions_to_classes)];
  },
  fixIds: [fixId9],
  getAllCodeActions: (context) => codeFixAll(context, errorCodes10, (changes, err) => doChange9(changes, err.file, err.start, context.program.getTypeChecker(), context.preferences, context.program.getCompilerOptions()))
});
function doChange9(changes, sourceFile, position, checker, preferences, compilerOptions) {
  const ctorSymbol = checker.getSymbolAtLocation(getTokenAtPosition(sourceFile, position));
  if (!ctorSymbol || !ctorSymbol.valueDeclaration || !(ctorSymbol.flags & (16 /* Function */ | 3 /* Variable */))) {
    return void 0;
  }
  const ctorDeclaration = ctorSymbol.valueDeclaration;
  if (isFunctionDeclaration(ctorDeclaration) || isFunctionExpression(ctorDeclaration)) {
    changes.replaceNode(sourceFile, ctorDeclaration, createClassFromFunction(ctorDeclaration));
  } else if (isVariableDeclaration(ctorDeclaration)) {
    const classDeclaration = createClassFromVariableDeclaration(ctorDeclaration);
    if (!classDeclaration) {
      return void 0;
    }
    const ancestor = ctorDeclaration.parent.parent;
    if (isVariableDeclarationList(ctorDeclaration.parent) && ctorDeclaration.parent.declarations.length > 1) {
      changes.delete(sourceFile, ctorDeclaration);
      changes.insertNodeAfter(sourceFile, ancestor, classDeclaration);
    } else {
      changes.replaceNode(sourceFile, ancestor, classDeclaration);
    }
  }
  function createClassElementsFromSymbol(symbol) {
    const memberElements = [];
    if (symbol.exports) {
      symbol.exports.forEach((member) => {
        if (member.name === "prototype" && member.declarations) {
          const firstDeclaration = member.declarations[0];
          if (member.declarations.length === 1 && isPropertyAccessExpression(firstDeclaration) && isBinaryExpression(firstDeclaration.parent) && firstDeclaration.parent.operatorToken.kind === 64 /* EqualsToken */ && isObjectLiteralExpression(firstDeclaration.parent.right)) {
            const prototypes = firstDeclaration.parent.right;
            createClassElement(
              prototypes.symbol,
              /*modifiers*/
              void 0,
              memberElements
            );
          }
        } else {
          createClassElement(member, [factory.createToken(126 /* StaticKeyword */)], memberElements);
        }
      });
    }
    if (symbol.members) {
      symbol.members.forEach((member, key) => {
        var _a, _b, _c, _d;
        if (key === "constructor" && member.valueDeclaration) {
          const prototypeAssignment = (_d = (_c = (_b = (_a = symbol.exports) == null ? void 0 : _a.get("prototype")) == null ? void 0 : _b.declarations) == null ? void 0 : _c[0]) == null ? void 0 : _d.parent;
          if (prototypeAssignment && isBinaryExpression(prototypeAssignment) && isObjectLiteralExpression(prototypeAssignment.right) && some(prototypeAssignment.right.properties, isConstructorAssignment)) {
          } else {
            changes.delete(sourceFile, member.valueDeclaration.parent);
          }
          return;
        }
        createClassElement(
          member,
          /*modifiers*/
          void 0,
          memberElements
        );
      });
    }
    return memberElements;
    function shouldConvertDeclaration(_target, source) {
      if (isAccessExpression(_target)) {
        if (isPropertyAccessExpression(_target) && isConstructorAssignment(_target)) return true;
        return isFunctionLike(source);
      } else {
        return every(_target.properties, (property) => {
          if (isMethodDeclaration(property) || isGetOrSetAccessorDeclaration(property)) return true;
          if (isPropertyAssignment(property) && isFunctionExpression(property.initializer) && !!property.name) return true;
          if (isConstructorAssignment(property)) return true;
          return false;
        });
      }
    }
    function createClassElement(symbol2, modifiers, members) {
      if (!(symbol2.flags & 8192 /* Method */) && !(symbol2.flags & 4096 /* ObjectLiteral */)) {
        return;
      }
      const memberDeclaration = symbol2.valueDeclaration;
      const assignmentBinaryExpression = memberDeclaration.parent;
      const assignmentExpr = assignmentBinaryExpression.right;
      if (!shouldConvertDeclaration(memberDeclaration, assignmentExpr)) {
        return;
      }
      if (some(members, (m) => {
        const name = getNameOfDeclaration(m);
        if (name && isIdentifier(name) && idText(name) === symbolName(symbol2)) {
          return true;
        }
        return false;
      })) {
        return;
      }
      const nodeToDelete = assignmentBinaryExpression.parent && assignmentBinaryExpression.parent.kind === 244 /* ExpressionStatement */ ? assignmentBinaryExpression.parent : assignmentBinaryExpression;
      changes.delete(sourceFile, nodeToDelete);
      if (!assignmentExpr) {
        members.push(factory.createPropertyDeclaration(
          modifiers,
          symbol2.name,
          /*questionOrExclamationToken*/
          void 0,
          /*type*/
          void 0,
          /*initializer*/
          void 0
        ));
        return;
      }
      if (isAccessExpression(memberDeclaration) && (isFunctionExpression(assignmentExpr) || isArrowFunction(assignmentExpr))) {
        const quotePreference = getQuotePreference(sourceFile, preferences);
        const name = tryGetPropertyName(memberDeclaration, compilerOptions, quotePreference);
        if (name) {
          createFunctionLikeExpressionMember(members, assignmentExpr, name);
        }
        return;
      } else if (isObjectLiteralExpression(assignmentExpr)) {
        forEach(
          assignmentExpr.properties,
          (property) => {
            if (isMethodDeclaration(property) || isGetOrSetAccessorDeclaration(property)) {
              members.push(property);
            }
            if (isPropertyAssignment(property) && isFunctionExpression(property.initializer)) {
              createFunctionLikeExpressionMember(members, property.initializer, property.name);
            }
            if (isConstructorAssignment(property)) return;
            return;
          }
        );
        return;
      } else {
        if (isSourceFileJS(sourceFile)) return;
        if (!isPropertyAccessExpression(memberDeclaration)) return;
        const prop = factory.createPropertyDeclaration(
          modifiers,
          memberDeclaration.name,
          /*questionOrExclamationToken*/
          void 0,
          /*type*/
          void 0,
          assignmentExpr
        );
        copyLeadingComments(assignmentBinaryExpression.parent, prop, sourceFile);
        members.push(prop);
        return;
      }
      function createFunctionLikeExpressionMember(members2, expression, name) {
        if (isFunctionExpression(expression)) return createFunctionExpressionMember(members2, expression, name);
        else return createArrowFunctionExpressionMember(members2, expression, name);
      }
      function createFunctionExpressionMember(members2, functionExpression, name) {
        const fullModifiers = concatenate(modifiers, getModifierKindFromSource(functionExpression, 134 /* AsyncKeyword */));
        const method = factory.createMethodDeclaration(
          fullModifiers,
          /*asteriskToken*/
          void 0,
          name,
          /*questionToken*/
          void 0,
          /*typeParameters*/
          void 0,
          functionExpression.parameters,
          /*type*/
          void 0,
          functionExpression.body
        );
        copyLeadingComments(assignmentBinaryExpression, method, sourceFile);
        members2.push(method);
        return;
      }
      function createArrowFunctionExpressionMember(members2, arrowFunction, name) {
        const arrowFunctionBody = arrowFunction.body;
        let bodyBlock;
        if (arrowFunctionBody.kind === 241 /* Block */) {
          bodyBlock = arrowFunctionBody;
        } else {
          bodyBlock = factory.createBlock([factory.createReturnStatement(arrowFunctionBody)]);
        }
        const fullModifiers = concatenate(modifiers, getModifierKindFromSource(arrowFunction, 134 /* AsyncKeyword */));
        const method = factory.createMethodDeclaration(
          fullModifiers,
          /*asteriskToken*/
          void 0,
          name,
          /*questionToken*/
          void 0,
          /*typeParameters*/
          void 0,
          arrowFunction.parameters,
          /*type*/
          void 0,
          bodyBlock
        );
        copyLeadingComments(assignmentBinaryExpression, method, sourceFile);
        members2.push(method);
      }
    }
  }
  function createClassFromVariableDeclaration(node) {
    const initializer = node.initializer;
    if (!initializer || !isFunctionExpression(initializer) || !isIdentifier(node.name)) {
      return void 0;
    }
    const memberElements = createClassElementsFromSymbol(node.symbol);
    if (initializer.body) {
      memberElements.unshift(factory.createConstructorDeclaration(
        /*modifiers*/
        void 0,
        initializer.parameters,
        initializer.body
      ));
    }
    const modifiers = getModifierKindFromSource(node.parent.parent, 95 /* ExportKeyword */);
    const cls = factory.createClassDeclaration(
      modifiers,
      node.name,
      /*typeParameters*/
      void 0,
      /*heritageClauses*/
      void 0,
      memberElements
    );
    return cls;
  }
  function createClassFromFunction(node) {
    const memberElements = createClassElementsFromSymbol(ctorSymbol);
    if (node.body) {
      memberElements.unshift(factory.createConstructorDeclaration(
        /*modifiers*/
        void 0,
        node.parameters,
        node.body
      ));
    }
    const modifiers = getModifierKindFromSource(node, 95 /* ExportKeyword */);
    const cls = factory.createClassDeclaration(
      modifiers,
      node.name,
      /*typeParameters*/
      void 0,
      /*heritageClauses*/
      void 0,
      memberElements
    );
    return cls;
  }
}
function getModifierKindFromSource(source, kind) {
  return canHaveModifiers(source) ? filter(source.modifiers, (modifier) => modifier.kind === kind) : void 0;
}
function isConstructorAssignment(x) {
  if (!x.name) return false;
  if (isIdentifier(x.name) && x.name.text === "constructor") return true;
  return false;
}
function tryGetPropertyName(node, compilerOptions, quotePreference) {
  if (isPropertyAccessExpression(node)) {
    return node.name;
  }
  const propName = node.argumentExpression;
  if (isNumericLiteral(propName)) {
    return propName;
  }
  if (isStringLiteralLike(propName)) {
    return isIdentifierText(propName.text, getEmitScriptTarget(compilerOptions)) ? factory.createIdentifier(propName.text) : isNoSubstitutionTemplateLiteral(propName) ? factory.createStringLiteral(propName.text, quotePreference === 0 /* Single */) : propName;
  }
  return void 0;
}

// src/services/codefixes/convertToAsyncFunction.ts
var fixId10 = "convertToAsyncFunction";
var errorCodes11 = [Diagnostics.This_may_be_converted_to_an_async_function.code];
var codeActionSucceeded = true;
registerCodeFix({
  errorCodes: errorCodes11,
  getCodeActions(context) {
    codeActionSucceeded = true;
    const changes = ts_textChanges_exports.ChangeTracker.with(context, (t) => convertToAsyncFunction(t, context.sourceFile, context.span.start, context.program.getTypeChecker()));
    return codeActionSucceeded ? [createCodeFixAction(fixId10, changes, Diagnostics.Convert_to_async_function, fixId10, Diagnostics.Convert_all_to_async_functions)] : [];
  },
  fixIds: [fixId10],
  getAllCodeActions: (context) => codeFixAll(context, errorCodes11, (changes, err) => convertToAsyncFunction(changes, err.file, err.start, context.program.getTypeChecker()))
});
function convertToAsyncFunction(changes, sourceFile, position, checker) {
  const tokenAtPosition = getTokenAtPosition(sourceFile, position);
  let functionToConvert;
  if (isIdentifier(tokenAtPosition) && isVariableDeclaration(tokenAtPosition.parent) && tokenAtPosition.parent.initializer && isFunctionLikeDeclaration(tokenAtPosition.parent.initializer)) {
    functionToConvert = tokenAtPosition.parent.initializer;
  } else {
    functionToConvert = tryCast(getContainingFunction(getTokenAtPosition(sourceFile, position)), canBeConvertedToAsync);
  }
  if (!functionToConvert) {
    return;
  }
  const synthNamesMap = /* @__PURE__ */ new Map();
  const isInJavascript = isInJSFile(functionToConvert);
  const setOfExpressionsToReturn = getAllPromiseExpressionsToReturn(functionToConvert, checker);
  const functionToConvertRenamed = renameCollidingVarNames(functionToConvert, checker, synthNamesMap);
  if (!returnsPromise(functionToConvertRenamed, checker)) {
    return;
  }
  const returnStatements = functionToConvertRenamed.body && isBlock(functionToConvertRenamed.body) ? getReturnStatementsWithPromiseHandlers(functionToConvertRenamed.body, checker) : emptyArray;
  const transformer = { checker, synthNamesMap, setOfExpressionsToReturn, isInJSFile: isInJavascript };
  if (!returnStatements.length) {
    return;
  }
  const pos = skipTrivia(sourceFile.text, moveRangePastModifiers(functionToConvert).pos);
  changes.insertModifierAt(sourceFile, pos, 134 /* AsyncKeyword */, { suffix: " " });
  for (const returnStatement of returnStatements) {
    forEachChild(returnStatement, function visit(node) {
      if (isCallExpression(node)) {
        const newNodes = transformExpression(
          node,
          node,
          transformer,
          /*hasContinuation*/
          false
        );
        if (hasFailed()) {
          return true;
        }
        changes.replaceNodeWithNodes(sourceFile, returnStatement, newNodes);
      } else if (!isFunctionLike(node)) {
        forEachChild(node, visit);
        if (hasFailed()) {
          return true;
        }
      }
    });
    if (hasFailed()) {
      return;
    }
  }
}
function getReturnStatementsWithPromiseHandlers(body, checker) {
  const res = [];
  forEachReturnStatement(body, (ret) => {
    if (isReturnStatementWithFixablePromiseHandler(ret, checker)) res.push(ret);
  });
  return res;
}
function getAllPromiseExpressionsToReturn(func, checker) {
  if (!func.body) {
    return /* @__PURE__ */ new Set();
  }
  const setOfExpressionsToReturn = /* @__PURE__ */ new Set();
  forEachChild(func.body, function visit(node) {
    if (isPromiseReturningCallExpression(node, checker, "then")) {
      setOfExpressionsToReturn.add(getNodeId(node));
      forEach(node.arguments, visit);
    } else if (isPromiseReturningCallExpression(node, checker, "catch") || isPromiseReturningCallExpression(node, checker, "finally")) {
      setOfExpressionsToReturn.add(getNodeId(node));
      forEachChild(node, visit);
    } else if (isPromiseTypedExpression(node, checker)) {
      setOfExpressionsToReturn.add(getNodeId(node));
    } else {
      forEachChild(node, visit);
    }
  });
  return setOfExpressionsToReturn;
}
function isPromiseReturningCallExpression(node, checker, name) {
  if (!isCallExpression(node)) return false;
  const isExpressionOfName = hasPropertyAccessExpressionWithName(node, name);
  const nodeType = isExpressionOfName && checker.getTypeAtLocation(node);
  return !!(nodeType && checker.getPromisedTypeOfPromise(nodeType));
}
function isReferenceToType(type, target) {
  return (getObjectFlags(type) & 4 /* Reference */) !== 0 && type.target === target;
}
function getExplicitPromisedTypeOfPromiseReturningCallExpression(node, callback, checker) {
  if (node.expression.name.escapedText === "finally") {
    return void 0;
  }
  const promiseType = checker.getTypeAtLocation(node.expression.expression);
  if (isReferenceToType(promiseType, checker.getPromiseType()) || isReferenceToType(promiseType, checker.getPromiseLikeType())) {
    if (node.expression.name.escapedText === "then") {
      if (callback === elementAt(node.arguments, 0)) {
        return elementAt(node.typeArguments, 0);
      } else if (callback === elementAt(node.arguments, 1)) {
        return elementAt(node.typeArguments, 1);
      }
    } else {
      return elementAt(node.typeArguments, 0);
    }
  }
}
function isPromiseTypedExpression(node, checker) {
  if (!isExpression(node)) return false;
  return !!checker.getPromisedTypeOfPromise(checker.getTypeAtLocation(node));
}
function renameCollidingVarNames(nodeToRename, checker, synthNamesMap) {
  const identsToRenameMap = /* @__PURE__ */ new Map();
  const collidingSymbolMap = createMultiMap();
  forEachChild(nodeToRename, function visit(node) {
    if (!isIdentifier(node)) {
      forEachChild(node, visit);
      return;
    }
    const symbol = checker.getSymbolAtLocation(node);
    if (symbol) {
      const type = checker.getTypeAtLocation(node);
      const lastCallSignature = getLastCallSignature(type, checker);
      const symbolIdString = getSymbolId(symbol).toString();
      if (lastCallSignature && !isParameter(node.parent) && !isFunctionLikeDeclaration(node.parent) && !synthNamesMap.has(symbolIdString)) {
        const firstParameter = firstOrUndefined(lastCallSignature.parameters);
        const ident = (firstParameter == null ? void 0 : firstParameter.valueDeclaration) && isParameter(firstParameter.valueDeclaration) && tryCast(firstParameter.valueDeclaration.name, isIdentifier) || factory.createUniqueName("result", 16 /* Optimistic */);
        const synthName = getNewNameIfConflict(ident, collidingSymbolMap);
        synthNamesMap.set(symbolIdString, synthName);
        collidingSymbolMap.add(ident.text, symbol);
      } else if (node.parent && (isParameter(node.parent) || isVariableDeclaration(node.parent) || isBindingElement(node.parent))) {
        const originalName = node.text;
        const collidingSymbols = collidingSymbolMap.get(originalName);
        if (collidingSymbols && collidingSymbols.some((prevSymbol) => prevSymbol !== symbol)) {
          const newName = getNewNameIfConflict(node, collidingSymbolMap);
          identsToRenameMap.set(symbolIdString, newName.identifier);
          synthNamesMap.set(symbolIdString, newName);
          collidingSymbolMap.add(originalName, symbol);
        } else {
          const identifier = getSynthesizedDeepClone(node);
          synthNamesMap.set(symbolIdString, createSynthIdentifier(identifier));
          collidingSymbolMap.add(originalName, symbol);
        }
      }
    }
  });
  return getSynthesizedDeepCloneWithReplacements(
    nodeToRename,
    /*includeTrivia*/
    true,
    (original) => {
      if (isBindingElement(original) && isIdentifier(original.name) && isObjectBindingPattern(original.parent)) {
        const symbol = checker.getSymbolAtLocation(original.name);
        const renameInfo = symbol && identsToRenameMap.get(String(getSymbolId(symbol)));
        if (renameInfo && renameInfo.text !== (original.name || original.propertyName).getText()) {
          return factory.createBindingElement(
            original.dotDotDotToken,
            original.propertyName || original.name,
            renameInfo,
            original.initializer
          );
        }
      } else if (isIdentifier(original)) {
        const symbol = checker.getSymbolAtLocation(original);
        const renameInfo = symbol && identsToRenameMap.get(String(getSymbolId(symbol)));
        if (renameInfo) {
          return factory.createIdentifier(renameInfo.text);
        }
      }
    }
  );
}
function getNewNameIfConflict(name, originalNames) {
  const numVarsSameName = (originalNames.get(name.text) || emptyArray).length;
  const identifier = numVarsSameName === 0 ? name : factory.createIdentifier(name.text + "_" + numVarsSameName);
  return createSynthIdentifier(identifier);
}
function hasFailed() {
  return !codeActionSucceeded;
}
function silentFail() {
  codeActionSucceeded = false;
  return emptyArray;
}
function transformExpression(returnContextNode, node, transformer, hasContinuation, continuationArgName) {
  if (isPromiseReturningCallExpression(node, transformer.checker, "then")) {
    return transformThen(node, elementAt(node.arguments, 0), elementAt(node.arguments, 1), transformer, hasContinuation, continuationArgName);
  }
  if (isPromiseReturningCallExpression(node, transformer.checker, "catch")) {
    return transformCatch(node, elementAt(node.arguments, 0), transformer, hasContinuation, continuationArgName);
  }
  if (isPromiseReturningCallExpression(node, transformer.checker, "finally")) {
    return transformFinally(node, elementAt(node.arguments, 0), transformer, hasContinuation, continuationArgName);
  }
  if (isPropertyAccessExpression(node)) {
    return transformExpression(returnContextNode, node.expression, transformer, hasContinuation, continuationArgName);
  }
  const nodeType = transformer.checker.getTypeAtLocation(node);
  if (nodeType && transformer.checker.getPromisedTypeOfPromise(nodeType)) {
    Debug.assertNode(getOriginalNode(node).parent, isPropertyAccessExpression);
    return transformPromiseExpressionOfPropertyAccess(returnContextNode, node, transformer, hasContinuation, continuationArgName);
  }
  return silentFail();
}
function isNullOrUndefined2({ checker }, node) {
  if (node.kind === 106 /* NullKeyword */) return true;
  if (isIdentifier(node) && !isGeneratedIdentifier(node) && idText(node) === "undefined") {
    const symbol = checker.getSymbolAtLocation(node);
    return !symbol || checker.isUndefinedSymbol(symbol);
  }
  return false;
}
function createUniqueSynthName(prevArgName) {
  const renamedPrevArg = factory.createUniqueName(prevArgName.identifier.text, 16 /* Optimistic */);
  return createSynthIdentifier(renamedPrevArg);
}
function getPossibleNameForVarDecl(node, transformer, continuationArgName) {
  let possibleNameForVarDecl;
  if (continuationArgName && !shouldReturn(node, transformer)) {
    if (isSynthIdentifier(continuationArgName)) {
      possibleNameForVarDecl = continuationArgName;
      transformer.synthNamesMap.forEach((val, key) => {
        if (val.identifier.text === continuationArgName.identifier.text) {
          const newSynthName = createUniqueSynthName(continuationArgName);
          transformer.synthNamesMap.set(key, newSynthName);
        }
      });
    } else {
      possibleNameForVarDecl = createSynthIdentifier(factory.createUniqueName("result", 16 /* Optimistic */), continuationArgName.types);
    }
    declareSynthIdentifier(possibleNameForVarDecl);
  }
  return possibleNameForVarDecl;
}
function finishCatchOrFinallyTransform(node, transformer, tryStatement, possibleNameForVarDecl, continuationArgName) {
  const statements = [];
  let varDeclIdentifier;
  if (possibleNameForVarDecl && !shouldReturn(node, transformer)) {
    varDeclIdentifier = getSynthesizedDeepClone(declareSynthIdentifier(possibleNameForVarDecl));
    const typeArray = possibleNameForVarDecl.types;
    const unionType = transformer.checker.getUnionType(typeArray, 2 /* Subtype */);
    const unionTypeNode = transformer.isInJSFile ? void 0 : transformer.checker.typeToTypeNode(
      unionType,
      /*enclosingDeclaration*/
      void 0,
      /*flags*/
      void 0
    );
    const varDecl = [factory.createVariableDeclaration(
      varDeclIdentifier,
      /*exclamationToken*/
      void 0,
      unionTypeNode
    )];
    const varDeclList = factory.createVariableStatement(
      /*modifiers*/
      void 0,
      factory.createVariableDeclarationList(varDecl, 1 /* Let */)
    );
    statements.push(varDeclList);
  }
  statements.push(tryStatement);
  if (continuationArgName && varDeclIdentifier && isSynthBindingPattern(continuationArgName)) {
    statements.push(factory.createVariableStatement(
      /*modifiers*/
      void 0,
      factory.createVariableDeclarationList([
        factory.createVariableDeclaration(
          getSynthesizedDeepClone(declareSynthBindingPattern(continuationArgName)),
          /*exclamationToken*/
          void 0,
          /*type*/
          void 0,
          varDeclIdentifier
        )
      ], 2 /* Const */)
    ));
  }
  return statements;
}
function transformFinally(node, onFinally, transformer, hasContinuation, continuationArgName) {
  if (!onFinally || isNullOrUndefined2(transformer, onFinally)) {
    return transformExpression(
      /* returnContextNode */
      node,
      node.expression.expression,
      transformer,
      hasContinuation,
      continuationArgName
    );
  }
  const possibleNameForVarDecl = getPossibleNameForVarDecl(node, transformer, continuationArgName);
  const inlinedLeftHandSide = transformExpression(
    /*returnContextNode*/
    node,
    node.expression.expression,
    transformer,
    /*hasContinuation*/
    true,
    possibleNameForVarDecl
  );
  if (hasFailed()) return silentFail();
  const inlinedCallback = transformCallbackArgument(
    onFinally,
    hasContinuation,
    /*continuationArgName*/
    void 0,
    /*inputArgName*/
    void 0,
    node,
    transformer
  );
  if (hasFailed()) return silentFail();
  const tryBlock = factory.createBlock(inlinedLeftHandSide);
  const finallyBlock = factory.createBlock(inlinedCallback);
  const tryStatement = factory.createTryStatement(
    tryBlock,
    /*catchClause*/
    void 0,
    finallyBlock
  );
  return finishCatchOrFinallyTransform(node, transformer, tryStatement, possibleNameForVarDecl, continuationArgName);
}
function transformCatch(node, onRejected, transformer, hasContinuation, continuationArgName) {
  if (!onRejected || isNullOrUndefined2(transformer, onRejected)) {
    return transformExpression(
      /* returnContextNode */
      node,
      node.expression.expression,
      transformer,
      hasContinuation,
      continuationArgName
    );
  }
  const inputArgName = getArgBindingName(onRejected, transformer);
  const possibleNameForVarDecl = getPossibleNameForVarDecl(node, transformer, continuationArgName);
  const inlinedLeftHandSide = transformExpression(
    /*returnContextNode*/
    node,
    node.expression.expression,
    transformer,
    /*hasContinuation*/
    true,
    possibleNameForVarDecl
  );
  if (hasFailed()) return silentFail();
  const inlinedCallback = transformCallbackArgument(onRejected, hasContinuation, possibleNameForVarDecl, inputArgName, node, transformer);
  if (hasFailed()) return silentFail();
  const tryBlock = factory.createBlock(inlinedLeftHandSide);
  const catchClause = factory.createCatchClause(inputArgName && getSynthesizedDeepClone(declareSynthBindingName(inputArgName)), factory.createBlock(inlinedCallback));
  const tryStatement = factory.createTryStatement(
    tryBlock,
    catchClause,
    /*finallyBlock*/
    void 0
  );
  return finishCatchOrFinallyTransform(node, transformer, tryStatement, possibleNameForVarDecl, continuationArgName);
}
function transformThen(node, onFulfilled, onRejected, transformer, hasContinuation, continuationArgName) {
  if (!onFulfilled || isNullOrUndefined2(transformer, onFulfilled)) {
    return transformCatch(node, onRejected, transformer, hasContinuation, continuationArgName);
  }
  if (onRejected && !isNullOrUndefined2(transformer, onRejected)) {
    return silentFail();
  }
  const inputArgName = getArgBindingName(onFulfilled, transformer);
  const inlinedLeftHandSide = transformExpression(
    node.expression.expression,
    node.expression.expression,
    transformer,
    /*hasContinuation*/
    true,
    inputArgName
  );
  if (hasFailed()) return silentFail();
  const inlinedCallback = transformCallbackArgument(onFulfilled, hasContinuation, continuationArgName, inputArgName, node, transformer);
  if (hasFailed()) return silentFail();
  return concatenate(inlinedLeftHandSide, inlinedCallback);
}
function transformPromiseExpressionOfPropertyAccess(returnContextNode, node, transformer, hasContinuation, continuationArgName) {
  if (shouldReturn(returnContextNode, transformer)) {
    let returnValue = getSynthesizedDeepClone(node);
    if (hasContinuation) {
      returnValue = factory.createAwaitExpression(returnValue);
    }
    return [factory.createReturnStatement(returnValue)];
  }
  return createVariableOrAssignmentOrExpressionStatement(
    continuationArgName,
    factory.createAwaitExpression(node),
    /*typeAnnotation*/
    void 0
  );
}
function createVariableOrAssignmentOrExpressionStatement(variableName, rightHandSide, typeAnnotation) {
  if (!variableName || isEmptyBindingName(variableName)) {
    return [factory.createExpressionStatement(rightHandSide)];
  }
  if (isSynthIdentifier(variableName) && variableName.hasBeenDeclared) {
    return [factory.createExpressionStatement(factory.createAssignment(getSynthesizedDeepClone(referenceSynthIdentifier(variableName)), rightHandSide))];
  }
  return [
    factory.createVariableStatement(
      /*modifiers*/
      void 0,
      factory.createVariableDeclarationList([
        factory.createVariableDeclaration(
          getSynthesizedDeepClone(declareSynthBindingName(variableName)),
          /*exclamationToken*/
          void 0,
          typeAnnotation,
          rightHandSide
        )
      ], 2 /* Const */)
    )
  ];
}
function maybeAnnotateAndReturn(expressionToReturn, typeAnnotation) {
  if (typeAnnotation && expressionToReturn) {
    const name = factory.createUniqueName("result", 16 /* Optimistic */);
    return [
      ...createVariableOrAssignmentOrExpressionStatement(createSynthIdentifier(name), expressionToReturn, typeAnnotation),
      factory.createReturnStatement(name)
    ];
  }
  return [factory.createReturnStatement(expressionToReturn)];
}
function transformCallbackArgument(func, hasContinuation, continuationArgName, inputArgName, parent2, transformer) {
  var _a;
  switch (func.kind) {
    case 106 /* NullKeyword */:
      break;
    case 211 /* PropertyAccessExpression */:
    case 80 /* Identifier */:
      if (!inputArgName) {
        break;
      }
      const synthCall = factory.createCallExpression(
        getSynthesizedDeepClone(func),
        /*typeArguments*/
        void 0,
        isSynthIdentifier(inputArgName) ? [referenceSynthIdentifier(inputArgName)] : []
      );
      if (shouldReturn(parent2, transformer)) {
        return maybeAnnotateAndReturn(synthCall, getExplicitPromisedTypeOfPromiseReturningCallExpression(parent2, func, transformer.checker));
      }
      const type = transformer.checker.getTypeAtLocation(func);
      const callSignatures = transformer.checker.getSignaturesOfType(type, 0 /* Call */);
      if (!callSignatures.length) {
        return silentFail();
      }
      const returnType = callSignatures[0].getReturnType();
      const varDeclOrAssignment = createVariableOrAssignmentOrExpressionStatement(continuationArgName, factory.createAwaitExpression(synthCall), getExplicitPromisedTypeOfPromiseReturningCallExpression(parent2, func, transformer.checker));
      if (continuationArgName) {
        continuationArgName.types.push(transformer.checker.getAwaitedType(returnType) || returnType);
      }
      return varDeclOrAssignment;
    case 218 /* FunctionExpression */:
    case 219 /* ArrowFunction */: {
      const funcBody = func.body;
      const returnType2 = (_a = getLastCallSignature(transformer.checker.getTypeAtLocation(func), transformer.checker)) == null ? void 0 : _a.getReturnType();
      if (isBlock(funcBody)) {
        let refactoredStmts = [];
        let seenReturnStatement = false;
        for (const statement of funcBody.statements) {
          if (isReturnStatement(statement)) {
            seenReturnStatement = true;
            if (isReturnStatementWithFixablePromiseHandler(statement, transformer.checker)) {
              refactoredStmts = refactoredStmts.concat(transformReturnStatementWithFixablePromiseHandler(transformer, statement, hasContinuation, continuationArgName));
            } else {
              const possiblyAwaitedRightHandSide = returnType2 && statement.expression ? getPossiblyAwaitedRightHandSide(transformer.checker, returnType2, statement.expression) : statement.expression;
              refactoredStmts.push(...maybeAnnotateAndReturn(possiblyAwaitedRightHandSide, getExplicitPromisedTypeOfPromiseReturningCallExpression(parent2, func, transformer.checker)));
            }
          } else if (hasContinuation && forEachReturnStatement(statement, returnTrue)) {
            return silentFail();
          } else {
            refactoredStmts.push(statement);
          }
        }
        return shouldReturn(parent2, transformer) ? refactoredStmts.map((s) => getSynthesizedDeepClone(s)) : removeReturns(
          refactoredStmts,
          continuationArgName,
          transformer,
          seenReturnStatement
        );
      } else {
        const inlinedStatements = isFixablePromiseHandler(funcBody, transformer.checker) ? transformReturnStatementWithFixablePromiseHandler(transformer, factory.createReturnStatement(funcBody), hasContinuation, continuationArgName) : emptyArray;
        if (inlinedStatements.length > 0) {
          return inlinedStatements;
        }
        if (returnType2) {
          const possiblyAwaitedRightHandSide = getPossiblyAwaitedRightHandSide(transformer.checker, returnType2, funcBody);
          if (!shouldReturn(parent2, transformer)) {
            const transformedStatement = createVariableOrAssignmentOrExpressionStatement(
              continuationArgName,
              possiblyAwaitedRightHandSide,
              /*typeAnnotation*/
              void 0
            );
            if (continuationArgName) {
              continuationArgName.types.push(transformer.checker.getAwaitedType(returnType2) || returnType2);
            }
            return transformedStatement;
          } else {
            return maybeAnnotateAndReturn(possiblyAwaitedRightHandSide, getExplicitPromisedTypeOfPromiseReturningCallExpression(parent2, func, transformer.checker));
          }
        } else {
          return silentFail();
        }
      }
    }
    default:
      return silentFail();
  }
  return emptyArray;
}
function getPossiblyAwaitedRightHandSide(checker, type, expr) {
  const rightHandSide = getSynthesizedDeepClone(expr);
  return !!checker.getPromisedTypeOfPromise(type) ? factory.createAwaitExpression(rightHandSide) : rightHandSide;
}
function getLastCallSignature(type, checker) {
  const callSignatures = checker.getSignaturesOfType(type, 0 /* Call */);
  return lastOrUndefined(callSignatures);
}
function removeReturns(stmts, prevArgName, transformer, seenReturnStatement) {
  const ret = [];
  for (const stmt of stmts) {
    if (isReturnStatement(stmt)) {
      if (stmt.expression) {
        const possiblyAwaitedExpression = isPromiseTypedExpression(stmt.expression, transformer.checker) ? factory.createAwaitExpression(stmt.expression) : stmt.expression;
        if (prevArgName === void 0) {
          ret.push(factory.createExpressionStatement(possiblyAwaitedExpression));
        } else if (isSynthIdentifier(prevArgName) && prevArgName.hasBeenDeclared) {
          ret.push(factory.createExpressionStatement(factory.createAssignment(referenceSynthIdentifier(prevArgName), possiblyAwaitedExpression)));
        } else {
          ret.push(factory.createVariableStatement(
            /*modifiers*/
            void 0,
            factory.createVariableDeclarationList([factory.createVariableDeclaration(
              declareSynthBindingName(prevArgName),
              /*exclamationToken*/
              void 0,
              /*type*/
              void 0,
              possiblyAwaitedExpression
            )], 2 /* Const */)
          ));
        }
      }
    } else {
      ret.push(getSynthesizedDeepClone(stmt));
    }
  }
  if (!seenReturnStatement && prevArgName !== void 0) {
    ret.push(factory.createVariableStatement(
      /*modifiers*/
      void 0,
      factory.createVariableDeclarationList([factory.createVariableDeclaration(
        declareSynthBindingName(prevArgName),
        /*exclamationToken*/
        void 0,
        /*type*/
        void 0,
        factory.createIdentifier("undefined")
      )], 2 /* Const */)
    ));
  }
  return ret;
}
function transformReturnStatementWithFixablePromiseHandler(transformer, innerRetStmt, hasContinuation, continuationArgName) {
  let innerCbBody = [];
  forEachChild(innerRetStmt, function visit(node) {
    if (isCallExpression(node)) {
      const temp = transformExpression(node, node, transformer, hasContinuation, continuationArgName);
      innerCbBody = innerCbBody.concat(temp);
      if (innerCbBody.length > 0) {
        return;
      }
    } else if (!isFunctionLike(node)) {
      forEachChild(node, visit);
    }
  });
  return innerCbBody;
}
function getArgBindingName(funcNode, transformer) {
  const types = [];
  let name;
  if (isFunctionLikeDeclaration(funcNode)) {
    if (funcNode.parameters.length > 0) {
      const param = funcNode.parameters[0].name;
      name = getMappedBindingNameOrDefault(param);
    }
  } else if (isIdentifier(funcNode)) {
    name = getMapEntryOrDefault(funcNode);
  } else if (isPropertyAccessExpression(funcNode) && isIdentifier(funcNode.name)) {
    name = getMapEntryOrDefault(funcNode.name);
  }
  if (!name || "identifier" in name && name.identifier.text === "undefined") {
    return void 0;
  }
  return name;
  function getMappedBindingNameOrDefault(bindingName) {
    if (isIdentifier(bindingName)) return getMapEntryOrDefault(bindingName);
    const elements = flatMap(bindingName.elements, (element) => {
      if (isOmittedExpression(element)) return [];
      return [getMappedBindingNameOrDefault(element.name)];
    });
    return createSynthBindingPattern(bindingName, elements);
  }
  function getMapEntryOrDefault(identifier) {
    const originalNode = getOriginalNode2(identifier);
    const symbol = getSymbol2(originalNode);
    if (!symbol) {
      return createSynthIdentifier(identifier, types);
    }
    const mapEntry = transformer.synthNamesMap.get(getSymbolId(symbol).toString());
    return mapEntry || createSynthIdentifier(identifier, types);
  }
  function getSymbol2(node) {
    var _a;
    return ((_a = tryCast(node, canHaveSymbol)) == null ? void 0 : _a.symbol) ?? transformer.checker.getSymbolAtLocation(node);
  }
  function getOriginalNode2(node) {
    return node.original ? node.original : node;
  }
}
function isEmptyBindingName(bindingName) {
  if (!bindingName) {
    return true;
  }
  if (isSynthIdentifier(bindingName)) {
    return !bindingName.identifier.text;
  }
  return every(bindingName.elements, isEmptyBindingName);
}
function createSynthIdentifier(identifier, types = []) {
  return { kind: 0 /* Identifier */, identifier, types, hasBeenDeclared: false, hasBeenReferenced: false };
}
function createSynthBindingPattern(bindingPattern, elements = emptyArray, types = []) {
  return { kind: 1 /* BindingPattern */, bindingPattern, elements, types };
}
function referenceSynthIdentifier(synthId) {
  synthId.hasBeenReferenced = true;
  return synthId.identifier;
}
function declareSynthBindingName(synthName) {
  return isSynthIdentifier(synthName) ? declareSynthIdentifier(synthName) : declareSynthBindingPattern(synthName);
}
function declareSynthBindingPattern(synthPattern) {
  for (const element of synthPattern.elements) {
    declareSynthBindingName(element);
  }
  return synthPattern.bindingPattern;
}
function declareSynthIdentifier(synthId) {
  synthId.hasBeenDeclared = true;
  return synthId.identifier;
}
function isSynthIdentifier(bindingName) {
  return bindingName.kind === 0 /* Identifier */;
}
function isSynthBindingPattern(bindingName) {
  return bindingName.kind === 1 /* BindingPattern */;
}
function shouldReturn(expression, transformer) {
  return !!expression.original && transformer.setOfExpressionsToReturn.has(getNodeId(expression.original));
}

// src/services/codefixes/convertToEsModule.ts
registerCodeFix({
  errorCodes: [Diagnostics.File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module.code],
  getCodeActions(context) {
    const { sourceFile, program, preferences } = context;
    const changes = ts_textChanges_exports.ChangeTracker.with(context, (changes2) => {
      const moduleExportsChangedToDefault = convertFileToEsModule(sourceFile, program.getTypeChecker(), changes2, getEmitScriptTarget(program.getCompilerOptions()), getQuotePreference(sourceFile, preferences));
      if (moduleExportsChangedToDefault) {
        for (const importingFile of program.getSourceFiles()) {
          fixImportOfModuleExports(importingFile, sourceFile, program, changes2, getQuotePreference(importingFile, preferences));
        }
      }
    });
    return [createCodeFixActionWithoutFixAll("convertToEsModule", changes, Diagnostics.Convert_to_ES_module)];
  }
});
function fixImportOfModuleExports(importingFile, exportingFile, program, changes, quotePreference) {
  var _a;
  for (const moduleSpecifier of importingFile.imports) {
    const imported = (_a = program.getResolvedModuleFromModuleSpecifier(moduleSpecifier, importingFile)) == null ? void 0 : _a.resolvedModule;
    if (!imported || imported.resolvedFileName !== exportingFile.fileName) {
      continue;
    }
    const importNode = importFromModuleSpecifier(moduleSpecifier);
    switch (importNode.kind) {
      case 271 /* ImportEqualsDeclaration */:
        changes.replaceNode(importingFile, importNode, makeImport(
          importNode.name,
          /*namedImports*/
          void 0,
          moduleSpecifier,
          quotePreference
        ));
        break;
      case 213 /* CallExpression */:
        if (isRequireCall(
          importNode,
          /*requireStringLiteralLikeArgument*/
          false
        )) {
          changes.replaceNode(importingFile, importNode, factory.createPropertyAccessExpression(getSynthesizedDeepClone(importNode), "default"));
        }
        break;
    }
  }
}
function convertFileToEsModule(sourceFile, checker, changes, target, quotePreference) {
  const identifiers = { original: collectFreeIdentifiers(sourceFile), additional: /* @__PURE__ */ new Set() };
  const exports2 = collectExportRenames(sourceFile, checker, identifiers);
  convertExportsAccesses(sourceFile, exports2, changes);
  let moduleExportsChangedToDefault = false;
  let useSitesToUnqualify;
  for (const statement of filter(sourceFile.statements, isVariableStatement)) {
    const newUseSites = convertVariableStatement(sourceFile, statement, changes, checker, identifiers, target, quotePreference);
    if (newUseSites) {
      copyEntries(newUseSites, useSitesToUnqualify ?? (useSitesToUnqualify = /* @__PURE__ */ new Map()));
    }
  }
  for (const statement of filter(sourceFile.statements, (s) => !isVariableStatement(s))) {
    const moduleExportsChanged = convertStatement(sourceFile, statement, checker, changes, identifiers, target, exports2, useSitesToUnqualify, quotePreference);
    moduleExportsChangedToDefault = moduleExportsChangedToDefault || moduleExportsChanged;
  }
  useSitesToUnqualify == null ? void 0 : useSitesToUnqualify.forEach((replacement, original) => {
    changes.replaceNode(sourceFile, original, replacement);
  });
  return moduleExportsChangedToDefault;
}
function collectExportRenames(sourceFile, checker, identifiers) {
  const res = /* @__PURE__ */ new Map();
  forEachExportReference(sourceFile, (node) => {
    const { text } = node.name;
    if (!res.has(text) && (isIdentifierANonContextualKeyword(node.name) || checker.resolveName(
      text,
      node,
      111551 /* Value */,
      /*excludeGlobals*/
      true
    ))) {
      res.set(text, makeUniqueName(`_${text}`, identifiers));
    }
  });
  return res;
}
function convertExportsAccesses(sourceFile, exports2, changes) {
  forEachExportReference(sourceFile, (node, isAssignmentLhs) => {
    if (isAssignmentLhs) {
      return;
    }
    const { text } = node.name;
    changes.replaceNode(sourceFile, node, factory.createIdentifier(exports2.get(text) || text));
  });
}
function forEachExportReference(sourceFile, cb) {
  sourceFile.forEachChild(function recur(node) {
    if (isPropertyAccessExpression(node) && isExportsOrModuleExportsOrAlias(sourceFile, node.expression) && isIdentifier(node.name)) {
      const { parent: parent2 } = node;
      cb(node, isBinaryExpression(parent2) && parent2.left === node && parent2.operatorToken.kind === 64 /* EqualsToken */);
    }
    node.forEachChild(recur);
  });
}
function convertStatement(sourceFile, statement, checker, changes, identifiers, target, exports2, useSitesToUnqualify, quotePreference) {
  switch (statement.kind) {
    case 243 /* VariableStatement */:
      convertVariableStatement(sourceFile, statement, changes, checker, identifiers, target, quotePreference);
      return false;
    case 244 /* ExpressionStatement */: {
      const { expression } = statement;
      switch (expression.kind) {
        case 213 /* CallExpression */: {
          if (isRequireCall(
            expression,
            /*requireStringLiteralLikeArgument*/
            true
          )) {
            changes.replaceNode(sourceFile, statement, makeImport(
              /*defaultImport*/
              void 0,
              /*namedImports*/
              void 0,
              expression.arguments[0],
              quotePreference
            ));
          }
          return false;
        }
        case 226 /* BinaryExpression */: {
          const { operatorToken } = expression;
          return operatorToken.kind === 64 /* EqualsToken */ && convertAssignment(sourceFile, checker, expression, changes, exports2, useSitesToUnqualify);
        }
      }
    }
    default:
      return false;
  }
}
function convertVariableStatement(sourceFile, statement, changes, checker, identifiers, target, quotePreference) {
  const { declarationList } = statement;
  let foundImport = false;
  const converted = map(declarationList.declarations, (decl) => {
    const { name, initializer } = decl;
    if (initializer) {
      if (isExportsOrModuleExportsOrAlias(sourceFile, initializer)) {
        foundImport = true;
        return convertedImports([]);
      } else if (isRequireCall(
        initializer,
        /*requireStringLiteralLikeArgument*/
        true
      )) {
        foundImport = true;
        return convertSingleImport(name, initializer.arguments[0], checker, identifiers, target, quotePreference);
      } else if (isPropertyAccessExpression(initializer) && isRequireCall(
        initializer.expression,
        /*requireStringLiteralLikeArgument*/
        true
      )) {
        foundImport = true;
        return convertPropertyAccessImport(name, initializer.name.text, initializer.expression.arguments[0], identifiers, quotePreference);
      }
    }
    return convertedImports([factory.createVariableStatement(
      /*modifiers*/
      void 0,
      factory.createVariableDeclarationList([decl], declarationList.flags)
    )]);
  });
  if (foundImport) {
    changes.replaceNodeWithNodes(sourceFile, statement, flatMap(converted, (c) => c.newImports));
    let combinedUseSites;
    forEach(converted, (c) => {
      if (c.useSitesToUnqualify) {
        copyEntries(c.useSitesToUnqualify, combinedUseSites ?? (combinedUseSites = /* @__PURE__ */ new Map()));
      }
    });
    return combinedUseSites;
  }
}
function convertPropertyAccessImport(name, propertyName, moduleSpecifier, identifiers, quotePreference) {
  switch (name.kind) {
    case 206 /* ObjectBindingPattern */:
    case 207 /* ArrayBindingPattern */: {
      const tmp = makeUniqueName(propertyName, identifiers);
      return convertedImports([
        makeSingleImport(tmp, propertyName, moduleSpecifier, quotePreference),
        makeConst(
          /*modifiers*/
          void 0,
          name,
          factory.createIdentifier(tmp)
        )
      ]);
    }
    case 80 /* Identifier */:
      return convertedImports([makeSingleImport(name.text, propertyName, moduleSpecifier, quotePreference)]);
    default:
      return Debug.assertNever(name, `Convert to ES module got invalid syntax form ${name.kind}`);
  }
}
function convertAssignment(sourceFile, checker, assignment, changes, exports2, useSitesToUnqualify) {
  const { left, right } = assignment;
  if (!isPropertyAccessExpression(left)) {
    return false;
  }
  if (isExportsOrModuleExportsOrAlias(sourceFile, left)) {
    if (isExportsOrModuleExportsOrAlias(sourceFile, right)) {
      changes.delete(sourceFile, assignment.parent);
    } else {
      const replacement = isObjectLiteralExpression(right) ? tryChangeModuleExportsObject(right, useSitesToUnqualify) : isRequireCall(
        right,
        /*requireStringLiteralLikeArgument*/
        true
      ) ? convertReExportAll(right.arguments[0], checker) : void 0;
      if (replacement) {
        changes.replaceNodeWithNodes(sourceFile, assignment.parent, replacement[0]);
        return replacement[1];
      } else {
        changes.replaceRangeWithText(sourceFile, createRange(left.getStart(sourceFile), right.pos), "export default");
        return true;
      }
    }
  } else if (isExportsOrModuleExportsOrAlias(sourceFile, left.expression)) {
    convertNamedExport(sourceFile, assignment, changes, exports2);
  }
  return false;
}
function tryChangeModuleExportsObject(object, useSitesToUnqualify) {
  const statements = mapAllOrFail(object.properties, (prop) => {
    switch (prop.kind) {
      case 177 /* GetAccessor */:
      case 178 /* SetAccessor */:
      case 304 /* ShorthandPropertyAssignment */:
      case 305 /* SpreadAssignment */:
        return void 0;
      case 303 /* PropertyAssignment */:
        return !isIdentifier(prop.name) ? void 0 : convertExportsDotXEquals_replaceNode(prop.name.text, prop.initializer, useSitesToUnqualify);
      case 174 /* MethodDeclaration */:
        return !isIdentifier(prop.name) ? void 0 : functionExpressionToDeclaration(prop.name.text, [factory.createToken(95 /* ExportKeyword */)], prop, useSitesToUnqualify);
      default:
        Debug.assertNever(prop, `Convert to ES6 got invalid prop kind ${prop.kind}`);
    }
  });
  return statements && [statements, false];
}
function convertNamedExport(sourceFile, assignment, changes, exports2) {
  const { text } = assignment.left.name;
  const rename = exports2.get(text);
  if (rename !== void 0) {
    const newNodes = [
      makeConst(
        /*modifiers*/
        void 0,
        rename,
        assignment.right
      ),
      makeExportDeclaration([factory.createExportSpecifier(
        /*isTypeOnly*/
        false,
        rename,
        text
      )])
    ];
    changes.replaceNodeWithNodes(sourceFile, assignment.parent, newNodes);
  } else {
    convertExportsPropertyAssignment(assignment, sourceFile, changes);
  }
}
function convertReExportAll(reExported, checker) {
  const moduleSpecifier = reExported.text;
  const moduleSymbol = checker.getSymbolAtLocation(reExported);
  const exports2 = moduleSymbol ? moduleSymbol.exports : emptyMap;
  return exports2.has("export=" /* ExportEquals */) ? [[reExportDefault(moduleSpecifier)], true] : !exports2.has("default" /* Default */) ? [[reExportStar(moduleSpecifier)], false] : (
    // If there's some non-default export, must include both `export *` and `export default`.
    exports2.size > 1 ? [[reExportStar(moduleSpecifier), reExportDefault(moduleSpecifier)], true] : [[reExportDefault(moduleSpecifier)], true]
  );
}
function reExportStar(moduleSpecifier) {
  return makeExportDeclaration(
    /*exportSpecifiers*/
    void 0,
    moduleSpecifier
  );
}
function reExportDefault(moduleSpecifier) {
  return makeExportDeclaration([factory.createExportSpecifier(
    /*isTypeOnly*/
    false,
    /*propertyName*/
    void 0,
    "default"
  )], moduleSpecifier);
}
function convertExportsPropertyAssignment({ left, right, parent: parent2 }, sourceFile, changes) {
  const name = left.name.text;
  if ((isFunctionExpression(right) || isArrowFunction(right) || isClassExpression(right)) && (!right.name || right.name.text === name)) {
    changes.replaceRange(sourceFile, { pos: left.getStart(sourceFile), end: right.getStart(sourceFile) }, factory.createToken(95 /* ExportKeyword */), { suffix: " " });
    if (!right.name) changes.insertName(sourceFile, right, name);
    const semi = findChildOfKind(parent2, 27 /* SemicolonToken */, sourceFile);
    if (semi) changes.delete(sourceFile, semi);
  } else {
    changes.replaceNodeRangeWithNodes(sourceFile, left.expression, findChildOfKind(left, 25 /* DotToken */, sourceFile), [factory.createToken(95 /* ExportKeyword */), factory.createToken(87 /* ConstKeyword */)], { joiner: " ", suffix: " " });
  }
}
function convertExportsDotXEquals_replaceNode(name, exported, useSitesToUnqualify) {
  const modifiers = [factory.createToken(95 /* ExportKeyword */)];
  switch (exported.kind) {
    case 218 /* FunctionExpression */: {
      const { name: expressionName } = exported;
      if (expressionName && expressionName.text !== name) {
        return exportConst();
      }
    }
    case 219 /* ArrowFunction */:
      return functionExpressionToDeclaration(name, modifiers, exported, useSitesToUnqualify);
    case 231 /* ClassExpression */:
      return classExpressionToDeclaration(name, modifiers, exported, useSitesToUnqualify);
    default:
      return exportConst();
  }
  function exportConst() {
    return makeConst(modifiers, factory.createIdentifier(name), replaceImportUseSites(exported, useSitesToUnqualify));
  }
}
function replaceImportUseSites(nodeOrNodes, useSitesToUnqualify) {
  if (!useSitesToUnqualify || !some(arrayFrom(useSitesToUnqualify.keys()), (original) => rangeContainsRange(nodeOrNodes, original))) {
    return nodeOrNodes;
  }
  return isArray(nodeOrNodes) ? getSynthesizedDeepClonesWithReplacements(
    nodeOrNodes,
    /*includeTrivia*/
    true,
    replaceNode
  ) : getSynthesizedDeepCloneWithReplacements(
    nodeOrNodes,
    /*includeTrivia*/
    true,
    replaceNode
  );
  function replaceNode(original) {
    if (original.kind === 211 /* PropertyAccessExpression */) {
      const replacement = useSitesToUnqualify.get(original);
      useSitesToUnqualify.delete(original);
      return replacement;
    }
  }
}
function convertSingleImport(name, moduleSpecifier, checker, identifiers, target, quotePreference) {
  switch (name.kind) {
    case 206 /* ObjectBindingPattern */: {
      const importSpecifiers = mapAllOrFail(name.elements, (e) => e.dotDotDotToken || e.initializer || e.propertyName && !isIdentifier(e.propertyName) || !isIdentifier(e.name) ? void 0 : makeImportSpecifier2(e.propertyName && e.propertyName.text, e.name.text));
      if (importSpecifiers) {
        return convertedImports([makeImport(
          /*defaultImport*/
          void 0,
          importSpecifiers,
          moduleSpecifier,
          quotePreference
        )]);
      }
    }
    case 207 /* ArrayBindingPattern */: {
      const tmp = makeUniqueName(moduleSpecifierToValidIdentifier(moduleSpecifier.text, target), identifiers);
      return convertedImports([
        makeImport(
          factory.createIdentifier(tmp),
          /*namedImports*/
          void 0,
          moduleSpecifier,
          quotePreference
        ),
        makeConst(
          /*modifiers*/
          void 0,
          getSynthesizedDeepClone(name),
          factory.createIdentifier(tmp)
        )
      ]);
    }
    case 80 /* Identifier */:
      return convertSingleIdentifierImport(name, moduleSpecifier, checker, identifiers, quotePreference);
    default:
      return Debug.assertNever(name, `Convert to ES module got invalid name kind ${name.kind}`);
  }
}
function convertSingleIdentifierImport(name, moduleSpecifier, checker, identifiers, quotePreference) {
  const nameSymbol = checker.getSymbolAtLocation(name);
  const namedBindingsNames = /* @__PURE__ */ new Map();
  let needDefaultImport = false;
  let useSitesToUnqualify;
  for (const use of identifiers.original.get(name.text)) {
    if (checker.getSymbolAtLocation(use) !== nameSymbol || use === name) {
      continue;
    }
    const { parent: parent2 } = use;
    if (isPropertyAccessExpression(parent2)) {
      const { name: { text: propertyName } } = parent2;
      if (propertyName === "default") {
        needDefaultImport = true;
        const importDefaultName = use.getText();
        (useSitesToUnqualify ?? (useSitesToUnqualify = /* @__PURE__ */ new Map())).set(parent2, factory.createIdentifier(importDefaultName));
      } else {
        Debug.assert(parent2.expression === use, "Didn't expect expression === use");
        let idName = namedBindingsNames.get(propertyName);
        if (idName === void 0) {
          idName = makeUniqueName(propertyName, identifiers);
          namedBindingsNames.set(propertyName, idName);
        }
        (useSitesToUnqualify ?? (useSitesToUnqualify = /* @__PURE__ */ new Map())).set(parent2, factory.createIdentifier(idName));
      }
    } else {
      needDefaultImport = true;
    }
  }
  const namedBindings = namedBindingsNames.size === 0 ? void 0 : arrayFrom(mapIterator(namedBindingsNames.entries(), ([propertyName, idName]) => factory.createImportSpecifier(
    /*isTypeOnly*/
    false,
    propertyName === idName ? void 0 : factory.createIdentifier(propertyName),
    factory.createIdentifier(idName)
  )));
  if (!namedBindings) {
    needDefaultImport = true;
  }
  return convertedImports(
    [makeImport(needDefaultImport ? getSynthesizedDeepClone(name) : void 0, namedBindings, moduleSpecifier, quotePreference)],
    useSitesToUnqualify
  );
}
function makeUniqueName(name, identifiers) {
  while (identifiers.original.has(name) || identifiers.additional.has(name)) {
    name = `_${name}`;
  }
  identifiers.additional.add(name);
  return name;
}
function collectFreeIdentifiers(file) {
  const map2 = createMultiMap();
  forEachFreeIdentifier(file, (id) => map2.add(id.text, id));
  return map2;
}
function forEachFreeIdentifier(node, cb) {
  if (isIdentifier(node) && isFreeIdentifier(node)) cb(node);
  node.forEachChild((child) => forEachFreeIdentifier(child, cb));
}
function isFreeIdentifier(node) {
  const { parent: parent2 } = node;
  switch (parent2.kind) {
    case 211 /* PropertyAccessExpression */:
      return parent2.name !== node;
    case 208 /* BindingElement */:
      return parent2.propertyName !== node;
    case 276 /* ImportSpecifier */:
      return parent2.propertyName !== node;
    default:
      return true;
  }
}
function functionExpressionToDeclaration(name, additionalModifiers, fn, useSitesToUnqualify) {
  return factory.createFunctionDeclaration(
    concatenate(additionalModifiers, getSynthesizedDeepClones(fn.modifiers)),
    getSynthesizedDeepClone(fn.asteriskToken),
    name,
    getSynthesizedDeepClones(fn.typeParameters),
    getSynthesizedDeepClones(fn.parameters),
    getSynthesizedDeepClone(fn.type),
    factory.converters.convertToFunctionBlock(replaceImportUseSites(fn.body, useSitesToUnqualify))
  );
}
function classExpressionToDeclaration(name, additionalModifiers, cls, useSitesToUnqualify) {
  return factory.createClassDeclaration(
    concatenate(additionalModifiers, getSynthesizedDeepClones(cls.modifiers)),
    name,
    getSynthesizedDeepClones(cls.typeParameters),
    getSynthesizedDeepClones(cls.heritageClauses),
    replaceImportUseSites(cls.members, useSitesToUnqualify)
  );
}
function makeSingleImport(localName, propertyName, moduleSpecifier, quotePreference) {
  return propertyName === "default" ? makeImport(
    factory.createIdentifier(localName),
    /*namedImports*/
    void 0,
    moduleSpecifier,
    quotePreference
  ) : makeImport(
    /*defaultImport*/
    void 0,
    [makeImportSpecifier2(propertyName, localName)],
    moduleSpecifier,
    quotePreference
  );
}
function makeImportSpecifier2(propertyName, name) {
  return factory.createImportSpecifier(
    /*isTypeOnly*/
    false,
    propertyName !== void 0 && propertyName !== name ? factory.createIdentifier(propertyName) : void 0,
    factory.createIdentifier(name)
  );
}
function makeConst(modifiers, name, init) {
  return factory.createVariableStatement(
    modifiers,
    factory.createVariableDeclarationList(
      [factory.createVariableDeclaration(
        name,
        /*exclamationToken*/
        void 0,
        /*type*/
        void 0,
        init
      )],
      2 /* Const */
    )
  );
}
function makeExportDeclaration(exportSpecifiers, moduleSpecifier) {
  return factory.createExportDeclaration(
    /*modifiers*/
    void 0,
    /*isTypeOnly*/
    false,
    exportSpecifiers && factory.createNamedExports(exportSpecifiers),
    moduleSpecifier === void 0 ? void 0 : factory.createStringLiteral(moduleSpecifier)
  );
}
function convertedImports(newImports, useSitesToUnqualify) {
  return {
    newImports,
    useSitesToUnqualify
  };
}

// src/services/codefixes/correctQualifiedNameToIndexedAccessType.ts
var fixId11 = "correctQualifiedNameToIndexedAccessType";
var errorCodes12 = [Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1.code];
registerCodeFix({
  errorCodes: errorCodes12,
  getCodeActions(context) {
    const qualifiedName = getQualifiedName(context.sourceFile, context.span.start);
    if (!qualifiedName) return void 0;
    const changes = ts_textChanges_exports.ChangeTracker.with(context, (t) => doChange10(t, context.sourceFile, qualifiedName));
    const newText = `${qualifiedName.left.text}["${qualifiedName.right.text}"]`;
    return [createCodeFixAction(fixId11, changes, [Diagnostics.Rewrite_as_the_indexed_access_type_0, newText], fixId11, Diagnostics.Rewrite_all_as_indexed_access_types)];
  },
  fixIds: [fixId11],
  getAllCodeActions: (context) => codeFixAll(context, errorCodes12, (changes, diag2) => {
    const q = getQualifiedName(diag2.file, diag2.start);
    if (q) {
      doChange10(changes, diag2.file, q);
    }
  })
});
function getQualifiedName(sourceFile, pos) {
  const qualifiedName = findAncestor(getTokenAtPosition(sourceFile, pos), isQualifiedName);
  Debug.assert(!!qualifiedName, "Expected position to be owned by a qualified name.");
  return isIdentifier(qualifiedName.left) ? qualifiedName : void 0;
}
function doChange10(changeTracker, sourceFile, qualifiedName) {
  const rightText = qualifiedName.right.text;
  const replacement = factory.createIndexedAccessTypeNode(
    factory.createTypeReferenceNode(
      qualifiedName.left,
MZ                @                                       	!L!This program cannot be run in DOS mode.
$       PE  L c/b         !  0         N       `    @                               @                           \N  O    `  (           :  '                                                                          H           .text   .       0                    `.rsrc   (   `      2              @  @.reloc            8              @  B                N      H     \K     	       P   *  J                                             lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet   )      hSystem.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aPADPAD\k8w4y{pF+s3{LVcd=}XUZ>7HZ*c+;?jt
7
T[N6,h;?TBTM\)eYfmm5Oq;7s
Dso|    E     h        0  5  !  G  [   m        6  _  5  j                  f  G                  |    	  R  
  VA c c o u n t M a n a g e r P r o b l e m E x e c u t i n g I n G l o b a l M u t e x     6B l u e B a d g e A c c o u n t I m a g e 1 9 2 1 9 2 8   .B r o w s e r N a v i g a t i o n F a i l e d n  8B r o w s e r N a v i g a t i o n T o U r l F a i l e d   *B r o w s e r S c r i p t D i s a b l e d   ,E r r o r D e s e r i a l i z e F a i l e d (  *E x p l i c i t T r u s t R e q u i r e d K  (M i c r o s o f t L o g o _ 1 2 8 x L G   (N a v i g a t i o n B a d G a t e w a y   (N a v i g a t i o n B a d R e q u e s t   &N a v i g a t i o n F o r b i d d e n   0N a v i g a t i o n G a t e w a y T i m e o u t %  :N a v i g a t i o n I n t e r n a l S e r v e r E r r o r [  $N a v i g a t i o n N o t F o u n d   8N a v i g a t i o n S e r v i c e U n a v a i l a b l e   ,N a v i g a t i o n U n a u t h o r i z e d   N o n e 0  LR e g i s t r y A c c o u n t S t o r e C a n n o t C r e a t e S u b K e y 7  DR e g i s t r y A c c o u n t S t o r e M e m b e r N o t V a l i d ]  "S T A T h r e a d R e q u i r e d    S e r v e r B a d R e q u e s t   S e r v e r F o r b i d d e n   2S e r v e r I n t e r n a l S e r v e r E r r o r <  S e r v e r N o t F o u n d o  0S e r v e r S e r v i c e U n a v a i l a b l e   $S e r v e r U n a u t h o r i z e d   $S e r v e r U n k n o w n E r r o r   S i g n I n C a n c e l l e d 5  ,T o k e n D e s e r i a l i z e F a i l e d I  4U I C r e d P r o v i d e r _ M e s s a g e T e x t l  0U I C r e d P r o v i d e r _ T i t l e T e x t   (U n e x p e c t e d N a v i g a t i o n   2U n e x p e c t e d N a v i g a t i o n T o U r l   $U n k n o w n C l i e n t E r r o r   U n k n o w n E r r o r   NV s A c c o u n t P r o v i d e r A c c o u n t N o t F o u n d F r o m K e y "  *V s A c c o u n t P r o v i d e r N a m e K  ZV s A c c o u n t P r o v i d e r S e t A d a l C a c h e I n v a l i d O p e r a t i o n ]  FV s A c c o u n t P r o v i d e r U n s u p p o r t e d A c c o u n t   LV s A c c o u n t P r o v i d e r U s e r N a m e C a n n o t B e E m p t y   :V s A c c o u n t P r o v i d e r W o r k O r S c h o o l   6{0}@              QSystem.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a   System.Drawing.Bitmap   Data   	        PNG

   IHDR              gAMA  a  JIDATHKV	Pg^ZkZih:=zU0uVDCQQX4[A/I!1'B0	 KA7ow.6d.m~Rg3Kk_]5-ZG'Ob)7%*=4`{(]|r-ut9O;C5CC>.<9TtqqrXN 
3%]AQkoD!mHp|ZR1bisG;@V_j%_W#5NFHsmjNtCX<5cd?V<,nce-wJh<ouUB!{z)K`>,ka18Q	S3R_
Z%H9Z%qterm~b5;(+"u"[E/k+I:BOtG NnnO5EE(NI;r5^ lS/j&v*__r4F|TN3">%(8@V+uUL"PP!_~10*L#^=^m+BiRpL(n,	djz1e`md*a{K
l>0:>o]se{,iM(1b[Q^l~{x1 ru <:H!I3;{| ~q>\hl&Z.m/t#^ #OZeF%$cAL
_o"_J<\a& =A(fu>U n&dy6!GtI| RH4`Iaz)B	MYG7)&y6!pI[z))DoE{Eb!g9XP]xC}2$#xfN8l6X<z~F5s,h=n+eC$wF}#y!@
^/'uV[	qVU,T:'UCWy	6]SXz'0dc	S.Q4BP!P7Z,K9SkQ`C/<'qP0L#:ZmcQD]XLfUgC:9c0RSl0 Atq[n<%
e*`d{Ga 'r8>oK"\n8Z;Pr0aHgH QQG%O9KSf,0}h$q4<VNBK(F=\/yqcBc!@St>/4%G?B84E%^~Sc8t Z|c*WI0>',Abp      IENDB`: SP324081:  Internet Explorer  JavaScript  Cookie! JavaScript ?@              QSystem.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a   System.Drawing.Bitmap   Data   	        PNG

   IHDR         >a   gAMA  a   	pHYs    +  IDATx^AMEA VpL),=7&04>} @v; Xv  `
dn + V  @v; Xv  `
dn + V  @v; Xv  `
dn + V  @v; Xv  `
dn + V  @v; Xv  `
dn + V  @v; Xv  `
dn + V  @v; Xv  `
dn + V  @v; Xv  `?="""""}/_> V  @v; Xv  `
dn + V  @v; Xv  `
dn + V  @v; Xv  `
dn + V  @v; Xv  `
dn + V  @v; Xv  `
dn + V  @v; Xv  `
dn + V  @v; Xv  `
dn + V  @v; Xv =Gf=t    IENDB`4SP324087: +SP324086: +SP324084: 4SP324088: +SP324089: 1SP324085: .SP324082: CSP324083: ()$ {0}\\{1}={0}:{1}2 STA 1SP324094: 7SP324092: 1SP324095: 1SP324093: +SP324090: 4SP324091: .SP324096: !! {0}: .SP324098: SP324099: 'Microsoft ! ADAL E ProviderId         lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet          PADPADPv/Y	hOR4]t   Y          <   e  A d d N e w A c c o u n t     C a n c e l B u t t o n    D i a l o g H e a d e r #   D i a l o g T i t l e 7   O k B u t t o n E   ...(_N)...
(_S)        lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet          PADPADPNjM    c   b  ^c o n t r o l s / a c c o u n t p i c k e r / a c c o u n t p i c k e r w i n d o w . b a m l     6c o n t r o l s / b r o w s e r w i n d o w . b a m l u  !p     M S B A M L   `   `   `   6  2Microsoft.VisualStudio.Services.Client.InteractiveW    QMicrosoft.VisualStudio.Services.Client.Controls.AccountPicker.AccountPickerWindow   > 9http://schemas.microsoft.com/winfx/2006/xaml/presentation  2x,http://schemas.microsoft.com/winfx/2006/xaml  Bmc;http://schemas.openxmlformats.org/markup-compatibility/2006  8d2http://schemas.microsoft.com/expression/blend/2008     Title$  Choose an account$151.767$410.58  ShowInTaskbar .    
ResizeMode$ NoResize=  WindowStartupLocation$ CenterOwner=#   SizeToContent$ Height=. .+ -    Name$ Header$Choose your account:$Center=$10q -    Name$ AccountComboBox$
10,0q  DisplayMemberPath$ DisplayName   Path$ Accounts 	  Orientation$	 
Horizontal=$Center=$10,30,10,10q.+ -   
 Name$
 OkButton$95$	5,0q$	1,3q  	IsDefault . $Select -   $
 CancelButton$95$	5,0q$	1,3q  IsCancel . $New...!&     M S B A M L   `   `   `   6  2Microsoft.VisualStudio.Services.Client.InteractiveC    =Microsoft.VisualStudio.Services.Client.Controls.BrowserWindow   > 9http://schemas.microsoft.com/winfx/2006/xaml/presentation  2x,http://schemas.microsoft.com/winfx/2006/xaml  Bmc;http://schemas.openxmlformats.org/markup-compatibility/2006  8d2http://schemas.microsoft.com/expression/blend/2008  $	570$	464   WindowStyle$
  None=  
ResizeMode$ NoResize=  ShowInTaskbar .    WindowStartupLocation$ CenterOwner=# # |.    	Resources    CloseButtonStyle  
TargetType  Property  Value %   &	         Style_1" . Setter_1  
   Setter_2  
   Setter_3  $ 1q. 
$1q|.  ._ |.    RowDefinitions  $39  $* .+ $0$0q#[  $Right=$	Top=$10q	  IsCancel	 . $2 *CloseCommand+.F $10$10
  Stretch$
 Uniform=|             @KL -  z          [  	=   z  z  z @KL @KL   z      z  	=  	=         |.     Path$ (TextElement.Foreground)  RelativeSource  *Self+\ XPresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35(  "System.Windows.Controls.WebBrowser  -     Name$ 
WebBrowser$1-  'System.Windows.Input.KeyboardNavigation   TabIndex$ 1d,QJk9LCUq\s2aP3GU2,uPvo_+T7Ypj|^-nuG&Cnm#	n`mBSJB         v4.0.30319     l   |   #~     \  #Strings    D     #US L     #GUID   \     #Blob               %3                                              
 G        O        k              <Module> Microsoft.VisualStudio.Services.Client.Interactive.resources zh-HANS Resources.zh-HANS.resources Microsoft.VisualStudio.Services.Client.Controls.AccountPicker.AccountPickerResources.zh-HANS.resources Microsoft.VisualStudio.Services.Client.Interactive.g.zh-HANS.resources Microsoft.VisualStudio.Services.Client.Interactive.resources.dll          7DQ Isp   $          $  RSA1     W.jvlL;6!r<wwO)2!d\L(]b,e,=t]o-~^=&Ce m4MZ N          N                          N            _CorDllMain mscoree.dll     %  @                                                                                                                                                                                                                                                                                                                                                                                   0                 	  H   X`            4   V S _ V E R S I O N _ I N F O           :~   :~                         D    V a r F i l e I n f o     $    T r a n s l a t i o n     0   S t r i n g F i l e I n f o      0 8 0 4 0 4 b 0   * 	  C o m m e n t s   d 0 2 1 f 8 c 8     L   C o m p a n y N a m e     M i c r o s o f t   C o r p o r a t i o n    7  F i l e D e s c r i p t i o n     M i c r o s o f t . V i s u a l S t u d i o . S e r v i c e s . C l i e n t . I n t e r a c t i v e . d l l      4  F i l e V e r s i o n     1 6 . 2 0 1 . 3 2 3 1 4 . 1   b u i l t   b y :   r e l e a s e s / M 2 0 1   ( 5 f e c c 9 d a c 7 )    A  I n t e r n a l N a m e   M i c r o s o f t . V i s u a l S t u d i o . S e r v i c e s . C l i e n t . I n t e r a c t i v e . r e s o u r c e s . d l l     d    L e g a l C o p y r i g h t      M i c r o s o f t   C o r p o r a t i o n 0OYu@b	gCg)R0   A  O r i g i n a l F i l e n a m e   M i c r o s o f t . V i s u a l S t u d i o . S e r v i c e s . C l i e n t . I n t e r a c t i v e . r e s o u r c e s . d l l     b !  P r o d u c t N a m e     M i c r o s o f t    A z u r e    D e v O p s   S e r v e r      B   P r o d u c t V e r s i o n   1 6 . 2 0 1 . 3 2 3 1 4 . 1                                                                                                                                                                                                                              @     >                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      '    0'	*H'u0'q10	`He 0\
+7N0L0
+70	  010	`He  _)T@FaDspXT+;003  R39    R0	*H 0~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20110210902183259Z220901183259Z0t10	UUS10U
Washington10URedmond10U
Microsoft Corporation10UMicrosoft Corporation0"0	*H  0
 #4BWq%:/LJ'_5@-qM ACPb"{6B5}oN/Esl4/N]/J|D]
y\lYz2S
n `Du$ThFrGh)33N0ml8{c!SP>r?~g+G|t|@IA*~NWM ~0z0U%0
+7L+0U5ZAkN|Fy0PUI0GE0C1)0'U Microsoft Operations Puerto Rico10U230012+4675970U#0HndP77"mu0TUM0K0IGEChttp://www.microsoft.com/pkiops/crl/MicCodSigPCA2011_2011-07-08.crl0a+U0S0Q+0Ehttp://www.microsoft.com/pkiops/certs/MicCodSigPCA2011_2011-07-08.crt0U0 0	*H  I7,dL@a@b,g`_ZGY1)R-tL]AG)\_K	CGK#=WcoNdS34;IS8EOh:zQ40Y v/.L*o1cJg>wQ)\]L "jyD18/&.v[KX&bnwv&=bjujAZAz8`+3Y3u4kfeu8kY(*1+8^T\INKBG7q#j3~^2
[ >MX[%$23+=F%R2av/U:kzc'tE9!dvP[l]rMw286O."y<I2i0z0b
a     0	*H 010	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20110110708205909Z260708210909Z0~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20110"0	*H  0
 r.nM4X!B*kZP8I7k891Byd~`$lIh^S
,+z	Y`fv2R&/PD].uhm:\F8dnd5xc-@\yI)w=+ZMV(zr:I^C{{>]O/Y;-3X>2=8~,NV!5%9ndS#_R!t%_('(8%9J6|#faj(I_%]!K>RW?$z[/#p]QFw _UK9#ID|Erzr$FWMI0[f{KI)(}gbx_/W\w((m(,@7OD	LC/tnx X,]`>O3NFl 00	+7 0UHndP77"mu0	+7
 S u b C A0U0U00U#0r-:1CN1#40ZUS0Q0OMKIhttp://crl.microsoft.com/pki/crl/products/MicRooCerAut2011_2011_03_22.crl0^+R0P0N+0Bhttp://www.microsoft.com/pki/certs/MicRooCerAut2011_2011_03_22.crt0U 00	+7.00?+3http://www.microsoft.com/pkiops/docs/primarycps.htm0@+042  L e g a l _ p o l i c y _ s t a t e m e n t . 0	*H  gTy.tg"cB}ye_.,>rm?
;Gic"5]e}FPU|K<BRk>.)=w9dD=xz#}t&F*hh.*?*kXIc	inZF+;5n%'(M=2-[I9

QEX82q'',: iYhnot@*(>?MfMo}Ev@*e]Rbc6']cA[>wuaaA(e/\ FY	KH )?Ew5zz"HG#kKux7yK#hui;0Lumc=VNOW"x2!zA
?]WqVNHEBv[
HkymmjRszP1v0r00~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20113  R39    R0	`He 0	*H	1
+70
+710
+70/	*H	1" T=GF; o&0B
+71402 M i c r o s o f thttp://www.microsoft.com0	*H  )Mz*KbWSt?	O]y"%,!|lmwi($=w];BMre2P/K0i/wkl	bXL:c,gLY,3=AijLfE{d]3F!3qN<20+6CFX*)gh2Um	Lg$	Z 0
+710	*H010	`He 0Q*H	@<08
+Y
010	`He  662;6Nb_6e[20220314104200.337Z0010	UUS10U
Washington10URedmond10U
Microsoft Corporation1%0#UMicrosoft America Operations1&0$UThales TSS ESN:E5A6-E27C-592E1%0#UMicrosoft Time-Stamp ServiceW003  71%   0	*H 0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100211202190512Z230228190512Z010	UUS10U
Washington10URedmond10U
Microsoft Corporation1%0#UMicrosoft America Operations1&0$UThales TSS ESN:E5A6-E27C-592E1%0#UMicrosoft Time-Stamp Service0"0	*H  0
 mAgK;?Z$!?PABvbpij;<5pX>_>mZ./2FA/$JzU)XfpGdrXNLu5@6o4
9p;d#r}QDpS`8gJnX /~o\3	u
n;&X~_0e> 5Ni^Fs:}VCWs2\co#KT=!\{mO<}0[_Xe _1C ep~,e 6d$}kh}kt+|:]"#%q'NGE~fGmK0bT~m"R&+ph"qJSaCMHyzWPW"?Up:cYFo'4Gkb 6020UbWW`|~o0U#0] ^b]eS5r0_UX0V0TRPNhttp://www.microsoft.com/pkiops/crl/Microsoft%20Time-Stamp%20PCA%202010(1).crl0l+`0^0\+0Phttp://www.microsoft.com/pkiops/certs/Microsoft%20Time-Stamp%20PCA%202010(1).crt0U0 0U%0
+0	*H  6'gA  	D#niy[g/mW~GHV=nX"%'@+^'3d^z[9tJ-Am,jp(p)(sE9l7<|vJs"&e_FdFODr@jMd#95+![vV&e7dA,=t/%5bhHUnCrK	Hw(0WiWF0p,kdvA;c}u;(oKS.rqJIZ4>iac(`P o1-)}^oO~>`,KRAs&B\uX^`LV]pANy(tv^Wq6\0q0Y3   kI     0	*H 010	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20100210930182225Z300930183225Z0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100"0	*H  0
 Lr!y$ylNu5WlJ>`3\OfSqZ~JZ6gF#w2`}jRDFkvPDq\Q17
8n&S|9azri65&d;{3[~Rb%j]SVM9,Qpi6-p15($~TUmh;Fz)7EFn20\O,bJq[g`= s}AFu_4 }~Er/}_~66L+nQsM7t4G|?L^s=CN39LBh.QFjZasg^(v3r 
co6d[!]_0tPa65Gk\RQ]%PzlrR<7?xE^ri{>j. 00	+7 0#	+7*Rd<F5)/0U] ^b]eS5r0\U U0S0Q+7L}0A0?+3http://www.microsoft.com/pkiops/Docs/Repository.htm0U%0
+0	+7
 S u b C A0U0U00U#0V\bh=[0VUO0M0KIGEhttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z+N0L0J+0>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0	*H  U}*,g1$[rKo\>NGdx=139q6?dl|u9m1l"fg:SMx6.V i	{jo)n?Humm#TxSu$W=heV(U'$@]='@8)TBjBRu6as.,k{n?,	x[It=J>f;O2tLrou04zP
X@<TmctH,NG-qd$sm	WITds[DZk(g($8Kn!TkjEG^OLvWT	iD~|als
Af=iAI~~;>1Q{p(6L
4$5g+"'B=%tt[j>~13}{8pD::bpcSMmqjU3Xpf070010	UUS10U
Washington10URedmond10U
Microsoft Corporation1%0#UMicrosoft America Operations1&0$UThales TSS ESN:E5A6-E27C-592E1%0#UMicrosoft Time-Stamp Service#
0+ GXSf(KOc0~0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100	*H  @0"20220314122009Z20220315122009Z0w0=
+Y
1/0-0
 @ 0
 30 0
 y 06
+Y
1(0&0
+Y

0  
0 0	*H  W9Pt/wqFtM'jBKG$7cH=xu!w	:[WY!rNHoMqU&  n7`2*10	00|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20103  71%   0	`He J0	*H	1*H	0/	*H	1" vMm@~MpVW\)zXh[>0*H	/1000 \K{i#?wTw2O,I00~0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20103  71%   0" n,c R
oQs2C |;x0	*H  M;!!g:x fH<<@bKn^:YB!sw OjDf
U=lLUay5G6k9IAwn2g|xOJS91R^i v: 1P5OC{y$:SUk`*:CS!-!)z <zOKs[faP5])?Y2y05h]9>cww?SJ)r=3lm+DC*qxU`u4CR[wAwU@3UlE3f6Q t~KYj,XF!fP\M^.DWg2@0%aZt__I57?$!#DF5a5MeU"iZ
Ef={                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Text;
using System.Windows.Forms;

using FdsDB;
using FdsCtrl;
using FdsNote.Dialog;
using FdsNote.Recept;
using GrapeCityEx;
using System.Collections;
using FdsNote.Login;

namespace FdsNote.Daicho
{
	public class SJigyoListCtrl : System.Windows.Forms.UserControl
	{
		#region ### `
		/// <summary>XgFP}X^</summary>
		private const int COL_HOCD = 0;
		/// <summary>XgFKpN</summary>
		private const int COL_SDATE = 1;
		/// <summary>XgFL</summary>
		private const int COL_EDATE = 2;
		/// <summary>XgFnP</summary>
		private const int COL_TANKA = 3;
		/// <summary>XgFKp</summary>
		private const int COL_JIGNO = 4;
		/// <summary>XgFIuWFNg</summary>
		private const int COL_OBJ = 5;
		#endregion

		private System.Windows.Forms.Button BtnCopy;
		private System.Windows.Forms.Button BtnEdit;
		private System.Windows.Forms.Button BtnDel;
		private System.Windows.Forms.Button BtnNew;
		private FlexGridCtrl SheetList;

		/// <summary> 
		/// KvfUCiB
		/// </summary>
		private System.ComponentModel.Container components = null;

		/// <summary> 
		/// gp\[XN[AbvB
		/// </summary>
		/// <param name="disposing">}l[W \[Xj trueAj false B</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region R|[lg fUCiR[h

		/// <summary> 
		/// fUCi T|[gKv\bhB\bhe 
		/// R[h GfB^XB
		/// </summary>
		private void InitializeComponent()
		{
			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(SJigyoListCtrl));
			GrapeCityEx.FlexGridCtrl.FlexCellStyles flexCellStyles1 = new GrapeCityEx.FlexGridCtrl.FlexCellStyles();
			GrapeCityEx.FlexGridCtrl.FlexCellStyle flexCellStyle1 = new GrapeCityEx.FlexGridCtrl.FlexCellStyle();
			GrapeCityEx.FlexGridCtrl.FlexCellStyles flexCellStyles2 = new GrapeCityEx.FlexGridCtrl.FlexCellStyles();
			GrapeCityEx.FlexGridCtrl.FlexCellStyle flexCellStyle2 = new GrapeCityEx.FlexGridCtrl.FlexCellStyle();
			GrapeCityEx.FlexGridCtrl.FlexCellStyles flexCellStyles3 = new GrapeCityEx.FlexGridCtrl.FlexCellStyles();
			GrapeCityEx.FlexGridCtrl.FlexCellStyle flexCellStyle3 = new GrapeCityEx.FlexGridCtrl.FlexCellStyle();
			GrapeCityEx.FlexGridCtrl.FlexCellStyles flexCellStyles4 = new GrapeCityEx.FlexGridCtrl.FlexCellStyles();
			GrapeCityEx.FlexGridCtrl.FlexCellStyle flexCellStyle4 = new GrapeCityEx.FlexGridCtrl.FlexCellStyle();
			GrapeCityEx.FlexGridCtrl.FlexCellStyles flexCellStyles5 = new GrapeCityEx.FlexGridCtrl.FlexCellStyles();
			GrapeCityEx.FlexGridCtrl.FlexCellStyle flexCellStyle5 = new GrapeCityEx.FlexGridCtrl.FlexCellStyle();
			GrapeCityEx.FlexGridCtrl.FlexCellStyles flexCellStyles6 = new GrapeCityEx.FlexGridCtrl.FlexCellStyles();
			GrapeCityEx.FlexGridCtrl.FlexCellStyle flexCellStyle6 = new GrapeCityEx.FlexGridCtrl.FlexCellStyle();
			GrapeCityEx.FlexGridCtrl.FlexCellStyle flexCellStyle7 = new GrapeCityEx.FlexGridCtrl.FlexCellStyle();
			GrapeCityEx.FlexGridCtrl.FlexCellStyle flexCellStyle8 = new GrapeCityEx.FlexGridCtrl.FlexCellStyle();
			GrapeCityEx.FlexGridCtrl.FlexCellStyle flexCellStyle9 = new GrapeCityEx.FlexGridCtrl.FlexCellStyle();
			GrapeCityEx.FlexGridCtrl.FlexCellStyle flexCellStyle10 = new GrapeCityEx.FlexGridCtrl.FlexCellStyle();
			GrapeCityEx.FlexGridCtrl.FlexCellStyle flexCellStyle11 = new GrapeCityEx.FlexGridCtrl.FlexCellStyle();
			GrapeCityEx.FlexGridCtrl.FlexCellStyle flexCellStyle12 = new GrapeCityEx.FlexGridCtrl.FlexCellStyle();
			this.BtnCopy = new System.Windows.Forms.Button();
			this.BtnEdit = new System.Windows.Forms.Button();
			this.BtnDel = new System.Windows.Forms.Button();
			this.BtnNew = new System.Windows.Forms.Button();
			this.SheetList = new GrapeCityEx.FlexGridCtrl();
			((System.ComponentModel.ISupportInitialize)(this.SheetList)).BeginInit();
			this.SuspendLayout();
			// 
			// BtnCopy
			// 
			this.BtnCopy.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.BtnCopy.ForeColor = System.Drawing.Color.Black;
			this.BtnCopy.Location = new System.Drawing.Point(955, 0);
			this.BtnCopy.Name = "BtnCopy";
			this.BtnCopy.Size = new System.Drawing.Size(70, 25);
			this.BtnCopy.TabIndex = 18;
			this.BtnCopy.Text = "";
			this.BtnCopy.Click += new System.EventHandler(this.BtnCopy_Click);
			// 
			// BtnEdit
			// 
			this.BtnEdit.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.BtnEdit.ForeColor = System.Drawing.Color.Black;
			this.BtnEdit.Location = new System.Drawing.Point(880, 30);
			this.BtnEdit.Name = "BtnEdit";
			this.BtnEdit.Size = new System.Drawing.Size(70, 25);
			this.BtnEdit.TabIndex = 17;
			this.BtnEdit.Text = "W";
			this.BtnEdit.Click += new System.EventHandler(this.BtnEdit_Click);
			// 
			// BtnDel
			// 
			this.BtnDel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.BtnDel.ForeColor = System.Drawing.Color.Red;
			this.BtnDel.Location = new System.Drawing.Point(955, 30);
			this.BtnDel.Name = "BtnDel";
			this.BtnDel.Size = new System.Drawing.Size(70, 25);
			this.BtnDel.TabIndex = 19;
			this.BtnDel.Text = "";
			this.BtnDel.Click += new System.EventHandler(this.BtnDel_Click);
			// 
			// BtnNew
			// 
			this.BtnNew.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.BtnNew.ForeColor = System.Drawing.Color.Blue;
			this.BtnNew.Location = new System.Drawing.Point(880, 0);
			this.BtnNew.Name = "BtnNew";
			this.BtnNew.Size = new System.Drawing.Size(70, 25);
			this.BtnNew.TabIndex = 16;
			this.BtnNew.Text = "";
			this.BtnNew.Click += new System.EventHandler(this.BtnNew_Click);
			// 
			// SheetList
			// 
			this.SheetList.AllowClipboard = false;
			this.SheetList.AllowDragDrop = false;
			this.SheetList.AllowDragging = C1.Win.C1FlexGrid.AllowDraggingEnum.None;
			this.SheetList.AllowMerging = C1.Win.C1FlexGrid.AllowMergingEnum.Custom;
			this.SheetList.AllowSorting = C1.Win.C1FlexGrid.AllowSortingEnum.None;
			this.SheetList.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.SheetList.BackColor = System.Drawing.Color.White;
			this.SheetList.BorderStyle = C1.Win.C1FlexGrid.Util.BaseControls.BorderStyleEnum.FixedSingle;
			this.SheetList.CellBackColor = System.Drawing.Color.White;
			this.SheetList.CellEnabled = true;
			this.SheetList.CellFont = new System.Drawing.Font("Meiryo UI", 9F);
			this.SheetList.CellForeColor = System.Drawing.Color.Black;
			this.SheetList.CellPatternColor = System.Drawing.Color.Black;
			this.SheetList.CellPatternStyle = System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal;
			this.SheetList.CellText = "";
			this.SheetList.CellValue = null;
			this.SheetList.ColumnHeaderCaptions = ((System.Collections.Generic.List<System.Collections.Generic.List<string>>)(resources.GetObject("SheetList.ColumnHeaderCaptions")));
			this.SheetList.ColumnHeaderHeights = ((System.Collections.Generic.List<int>)(resources.GetObject("SheetList.ColumnHeaderHeights")));
			this.SheetList.ColumnHeaderMaxRows = 1;
			this.SheetList.ColumnHeaderMergeSetteing = null;
			flexCellStyle1.BackColor = System.Drawing.SystemColors.Control;
			flexCellStyle1.BackgroundImageLayout = C1.Win.C1FlexGrid.ImageAlignEnum.Hide;
			flexCellStyle1.DefinedElements = C1.Win.C1FlexGrid.StyleElementFlags.None;
			flexCellStyle1.Display = C1.Win.C1FlexGrid.DisplayEnum.TextOnly;
			flexCellStyle1.Font = new System.Drawing.Font("Meiryo UI", 9F);
			flexCellStyle1.ImageSpacing = 2;
			flexCellStyle1.Margins = new System.Drawing.Printing.Margins(1, 1, 1, 1);
			flexCellStyle1.StyleKey = "CH_0_0";
			flexCellStyle1.TextAlign = C1.Win.C1FlexGrid.TextAlignEnum.CenterCenter;
			flexCellStyle1.ZeroString = null;
			flexCellStyles1.Styles = new GrapeCityEx.FlexGridCtrl.FlexCellStyle[] {
        flexCellStyle1};
			flexCellStyle2.BackColor = System.Drawing.SystemColors.Control;
			flexCellStyle2.BackgroundImageLayout = C1.Win.C1FlexGrid.ImageAlignEnum.Hide;
			flexCellStyle2.DefinedElements = C1.Win.C1FlexGrid.StyleElementFlags.None;
			flexCellStyle2.Display = C1.Win.C1FlexGrid.DisplayEnum.TextOnly;
			flexCellStyle2.Font = new System.Drawing.Font("Meiryo UI", 9F);
			flexCellStyle2.ImageSpacing = 2;
			flexCellStyle2.Margins = new System.Drawing.Printing.Margins(1, 1, 1, 1);
			flexCellStyle2.StyleKey = "CH_1_0";
			flexCellStyle2.TextAlign = C1.Win.C1FlexGrid.TextAlignEnum.CenterCenter;
			flexCellStyle2.ZeroString = null;
			flexCellStyles2.Styles = new GrapeCityEx.FlexGridCtrl.FlexCellStyle[] {
        flexCellStyle2};
			flexCellStyle3.BackColor = System.Drawing.SystemColors.Control;
			flexCellStyle3.BackgroundImageLayout = C1.Win.C1FlexGrid.ImageAlignEnum.Hide;
			flexCellStyle3.DefinedElements = C1.Win.C1FlexGrid.StyleElementFlags.None;
			flexCellStyle3.Display = C1.Win.C1FlexGrid.DisplayEnum.TextOnly;
			flexCellStyle3.Font = new System.Drawing.Font("Meiryo UI", 9F);
			flexCellStyle3.ImageSpacing = 2;
			flexCellStyle3.Margins = new System.Drawing.Printing.Margins(1, 1, 1, 1);
			flexCellStyle3.StyleKey = "CH_2_0";
			flexCellStyle3.TextAlign = C1.Win.C1FlexGrid.TextAlignEnum.CenterCenter;
			flexCellStyle3.ZeroString = null;
			flexCellStyles3.Styles = new GrapeCityEx.FlexGridCtrl.FlexCellStyle[] {
        flexCellStyle3};
			flexCellStyle4.BackColor = System.Drawing.SystemColors.Control;
			flexCellStyle4.BackgroundImageLayout = C1.Win.C1FlexGrid.ImageAlignEnum.Hide;
			flexCellStyle4.DefinedElements = C1.Win.C1FlexGrid.StyleElementFlags.None;
			flexCellStyle4.Display = C1.Win.C1FlexGrid.DisplayEnum.TextOnly;
			flexCellStyle4.Font = new System.Drawing.Font("Meiryo UI", 9F);
			flexCellStyle4.ImageSpacing = 2;
			flexCellStyle4.Margins = new System.Drawing.Printing.Margins(1, 1, 1, 1);
			flexCellStyle4.StyleKey = "CH_3_0";
			flexCellStyle4.TextAlign = C1.Win.C1FlexGrid.TextAlignEnum.CenterCenter;
			flexCellStyle4.ZeroString = null;
			flexCellStyles4.Styles = new GrapeCityEx.FlexGridCtrl.FlexCellStyle[] {
        flexCellStyle4};
			flexCellStyle5.BackColor = System.Drawing.SystemColors.Control;
			flexCellStyle5.BackgroundImageLayout = C1.Win.C1FlexGrid.ImageAlignEnum.Hide;
			flexCellStyle5.DefinedElements = C1.Win.C1FlexGrid.StyleElementFlags.None;
			flexCellStyle5.Display = C1.Win.C1FlexGrid.DisplayEnum.TextOnly;
			flexCellStyle5.Font = new System.Drawing.Font("Meiryo UI", 9F);
			flexCellStyle5.ImageSpacing = 2;
			flexCellStyle5.Margins = new System.Drawing.Printing.Margins(1, 1, 1, 1);
			flexCellStyle5.StyleKey = "CH_4_0";
			flexCellStyle5.TextAlign = C1.Win.C1FlexGrid.TextAlignEnum.CenterCenter;
			flexCellStyle5.ZeroString = null;
			flexCellStyles5.Styles = new GrapeCityEx.FlexGridCtrl.FlexCellStyle[] {
        flexCellStyle5};
			flexCellStyle6.BackColor = System.Drawing.SystemColors.Control;
			flexCellStyle6.BackgroundImageLayout = C1.Win.C1FlexGrid.ImageAlignEnum.Hide;
			flexCellStyle6.DefinedElements = C1.Win.C1FlexGrid.StyleElementFlags.None;
			flexCellStyle6.Display = C1.Win.C1FlexGrid.DisplayEnum.TextOnly;
			flexCellStyle6.Font = new System.Drawing.Font("Meiryo UI", 9F);
			flexCellStyle6.ImageSpacing = 2;
			flexCellStyle6.Margins = new System.Drawing.Printing.Margins(1, 1, 1, 1);
			flexCellStyle6.StyleKey = "CH_3_0";
			flexCellStyle6.TextAlign = C1.Win.C1FlexGrid.TextAlignEnum.CenterCenter;
			flexCellStyle6.ZeroString = null;
			flexCellStyles6.Styles = new GrapeCityEx.FlexGridCtrl.FlexCellStyle[] {
        flexCellStyle6};
			this.SheetList.ColumnHeaderStyles = new GrapeCityEx.FlexGridCtrl.FlexCellStyles[] {
        flexCellStyles1,
        flexCellStyles2,
        flexCellStyles3,
        flexCellStyles4,
        flexCellStyles5,
        flexCellStyles6};
			this.SheetList.ColumnInfo = resources.GetString("SheetList.ColumnInfo");
			flexCellStyle7.BackColor = System.Drawing.Color.White;
			flexCellStyle7.BackgroundImageLayout = C1.Win.C1FlexGrid.ImageAlignEnum.Hide;
			flexCellStyle7.DefinedElements = C1.Win.C1FlexGrid.StyleElementFlags.None;
			flexCellStyle7.Display = C1.Win.C1FlexGrid.DisplayEnum.TextOnly;
			flexCellStyle7.Font = new System.Drawing.Font("Meiryo UI", 9F);
			flexCellStyle7.ImageSpacing = 2;
			flexCellStyle7.Margins = new System.Drawing.Printing.Margins(1, 1, 1, 1);
			flexCellStyle7.StyleKey = "COL_0_0";
			flexCellStyle7.TextAlign = C1.Win.C1FlexGrid.TextAlignEnum.LeftCenter;
			flexCellStyle7.ZeroString = null;
			flexCellStyle8.BackColor = System.Drawing.Color.White;
			flexCellStyle8.BackgroundImageLayout = C1.Win.C1FlexGrid.ImageAlignEnum.Hide;
			flexCellStyle8.DefinedElements = C1.Win.C1FlexGrid.StyleElementFlags.None;
			flexCellStyle8.Display = C1.Win.C1FlexGrid.DisplayEnum.TextOnly;
			flexCellStyle8.Font = new System.Drawing.Font("Meiryo UI", 9F);
			flexCellStyle8.Format = "gee.MM.dd";
			flexCellStyle8.ImageSpacing = 2;
			flexCellStyle8.Margins = new System.Drawing.Printing.Margins(1, 1, 1, 1);
			flexCellStyle8.StyleKey = "COL_1_0";
			flexCellStyle8.TextAlign = C1.Win.C1FlexGrid.TextAlignEnum.CenterCenter;
			flexCellStyle8.ZeroString = null;
			flexCellStyle9.BackColor = System.Drawing.Color.White;
			flexCellStyle9.BackgroundImageLayout = C1.Win.C1FlexGrid.ImageAlignEnum.Hide;
			flexCellStyle9.DefinedElements = C1.Win.C1FlexGrid.StyleElementFlags.None;
			flexCellStyle9.Display = C1.Win.C1FlexGrid.DisplayEnum.TextOnly;
			flexCellStyle9.Font = new System.Drawing.Font("Meiryo UI", 9F);
			flexCellStyle9.Format = "gee.MM.dd";
			flexCellStyle9.ImageSpacing = 2;
			flexCellStyle9.Margins = new System.Drawing.Printing.Margins(1, 1, 1, 1);
			flexCellStyle9.NullDateString = "";
			flexCellStyle9.StyleKey = "COL_2_0";
			flexCellStyle9.TextAlign = C1.Win.C1FlexGrid.TextAlignEnum.CenterCenter;
			flexCellStyle9.ZeroString = null;
			flexCellStyle10.BackColor = System.Drawing.Color.White;
			flexCellStyle10.BackgroundImageLayout = C1.Win.C1FlexGrid.ImageAlignEnum.Hide;
			flexCellStyle10.DefinedElements = C1.Win.C1FlexGrid.StyleElementFlags.None;
			flexCellStyle10.Display = C1.Win.C1FlexGrid.DisplayEnum.TextOnly;
			flexCellStyle10.Font = new System.Drawing.Font("Meiryo UI", 9F);
			flexCellStyle10.Format = "N2";
			flexCellStyle10.ImageSpacing = 2;
			flexCellStyle10.Margins = new System.Drawing.Printing.Margins(1, 1, 1, 1);
			flexCellStyle10.StyleKey = "COL_3_0";
			flexCellStyle10.TextAlign = C1.Win.C1FlexGrid.TextAlignEnum.CenterCenter;
			flexCellStyle10.ZeroString = null;
			flexCellStyle11.BackColor = System.Drawing.Color.White;
			flexCellStyle11.BackgroundImageLayout = C1.Win.C1FlexGrid.ImageAlignEnum.Hide;
			flexCellStyle11.DefinedElements = C1.Win.C1FlexGrid.StyleElementFlags.None;
			flexCellStyle11.Display = C1.Win.C1FlexGrid.DisplayEnum.TextOnly;
			flexCellStyle11.Font = new System.Drawing.Font("Meiryo UI", 9F);
			flexCellStyle11.ImageSpacing = 2;
			flexCellStyle11.Margins = new System.Drawing.Printing.Margins(1, 1, 1, 1);
			flexCellStyle11.StyleKey = "COL_4_0";
			flexCellStyle11.TextAlign = C1.Win.C1FlexGrid.TextAlignEnum.LeftCenter;
			flexCellStyle11.ZeroString = null;
			flexCellStyle12.BackColor = System.Drawing.Color.White;
			flexCellStyle12.BackgroundImageLayout = C1.Win.C1FlexGrid.ImageAlignEnum.Hide;
			flexCellStyle12.DefinedElements = C1.Win.C1FlexGrid.StyleElementFlags.None;
			flexCellStyle12.Display = C1.Win.C1FlexGrid.DisplayEnum.TextOnly;
			flexCellStyle12.Font = new System.Drawing.Font("Meiryo UI", 9F);
			flexCellStyle12.Format = "N2";
			flexCellStyle12.ImageSpacing = 2;
			flexCellStyle12.Margins = new System.Drawing.Printing.Margins(1, 1, 1, 1);
			flexCellStyle12.StyleKey = "COL_3_0";
			flexCellStyle12.TextAlign = C1.Win.C1FlexGrid.TextAlignEnum.CenterCenter;
			flexCellStyle12.ZeroString = null;
			this.SheetList.ColumnStyles = new GrapeCityEx.FlexGridCtrl.FlexCellStyle[] {
        flexCellStyle7,
        flexCellStyle8,
        flexCellStyle9,
        flexCellStyle10,
        flexCellStyle11,
        flexCellStyle12};
			this.SheetList.CornerHeaderCaptions = ((System.Collections.Generic.List<System.Collections.Generic.List<string>>)(resources.GetObject("SheetList.CornerHeaderCaptions")));
			this.SheetList.CornerHeaderMergeSetteing = null;
			this.SheetList.CrossCursor = System.Windows.Forms.Cursors.Default;
			this.SheetList.CtrlText = null;
			this.SheetList.CustomSort = true;
			this.SheetList.DrawMode = C1.Win.C1FlexGrid.DrawModeEnum.OwnerDraw;
			this.SheetList.EditState = false;
			this.SheetList.FocusRect = C1.Win.C1FlexGrid.FocusRectEnum.Solid;
			this.SheetList.Font = new System.Drawing.Font("Meiryo UI", 9F);
			this.SheetList.ForeColor = System.Drawing.Color.Black;
			this.SheetList.FreezeColumns = 0;
			this.SheetList.FreezeRows = 0;
			this.SheetList.GrayAreaColor = System.Drawing.SystemColors.AppWorkspace;
			this.SheetList.HighlightBorderDirection = C1.Win.C1FlexGrid.BorderDirEnum.Both;
			this.SheetList.HighlightBorderStyle = C1.Win.C1FlexGrid.BorderStyleEnum.Flat;
			this.SheetList.HighlightColor = System.Drawing.Color.LightSkyBlue;
			this.SheetList.Location = new System.Drawing.Point(0, 0);
			this.SheetList.MaxColumns = 6;
			this.SheetList.MaxRows = 3;
			this.SheetList.MergeSetteing = null;
			this.SheetList.Name = "SheetList";
			this.SheetList.PrintAutoFit = false;
			this.SheetList.PrintGridLine = false;
			this.SheetList.PrintOutLine = false;
			this.SheetList.PrintRange = null;
			this.SheetList.PrintToMax = false;
			this.SheetList.RowColorPattern = null;
			this.SheetList.RowHeaderCaptions = ((System.Collections.Generic.List<System.Collections.Generic.List<string>>)(resources.GetObject("SheetList.RowHeaderCaptions")));
			this.SheetList.RowHeaderMergeSetteing = null;
			this.SheetList.RowHeaderWidths = ((System.Collections.Generic.List<int>)(resources.GetObject("SheetList.RowHeaderWidths")));
			this.SheetList.RowHeight = 20;
			this.SheetList.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
			this.SheetList.ScrollOptions = C1.Win.C1FlexGrid.ScrollFlags.AlwaysVisible;
			this.SheetList.SelectedColumn = 2;
			this.SheetList.SelectedRow = -2;
			this.SheetList.SelectionMode = C1.Win.C1FlexGrid.SelectionModeEnum.Row;
			this.SheetList.ShowHorizontalGrid = true;
			this.SheetList.ShowVerticalGrid = true;
			this.SheetList.Size = new System.Drawing.Size(875, 150);
			this.SheetList.StyleInfo = resources.GetString("SheetList.StyleInfo");
			this.SheetList.TabIndex = 22;
			this.SheetList.CellDoubleClick += new C1.Win.C1FlexGrid.RowColEventHandler(this.SheetList_CellDoubleClick);
			// 
			// SJigyoListCtrl
			// 
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None;
			this.Controls.Add(this.SheetList);
			this.Controls.Add(this.BtnCopy);
			this.Controls.Add(this.BtnEdit);
			this.Controls.Add(this.BtnDel);
			this.Controls.Add(this.BtnNew);
			this.Font = new System.Drawing.Font("Meiryo UI", 9F);
			this.Name = "SJigyoListCtrl";
			this.Size = new System.Drawing.Size(1030, 150);
			((System.ComponentModel.ISupportInitialize)(this.SheetList)).EndInit();
			this.ResumeLayout(false);

		}

		#endregion

		/// <summary>f[^NX</summary>
		private RDataCtrl RDCtrl;

		/// <summary>Xg_uNbNp</summary>
		private NoteSecurity.AuthInfo _Auth = null;

		/// <summary>lXCxg</summary>
		public event EventHandler ValueChanged;

		/// <summary></summary>
		private bool _AuthWrite = true;

		/// <summary>
		/// RXgN^
		/// </summary>
		public SJigyoListCtrl()
		{
			InitializeComponent();
			Init();
		}

		/// <summary>
		/// 
		/// </summary>
		private void Init()
		{
			Clear();
		}

		/// <summary>
		/// NA
		/// </summary>
		public void Clear()
		{
			SheetList.MaxRows = 0;
		}

		/// <summary>
		/// XgZbg
		/// </summary>
		public void SetList( RDataCtrl rdctrl, ArrayList array )
		{
			RDCtrl = rdctrl;

			Clear();

			if( array == null || array.Count <= 0 ) return;

			SheetList.Redraw = false;

			SheetList.MaxRows = array.Count;

			array.Sort( new HistnkComparer( HistnkComparer.SORT_SINGLE_SDATE ) );

			int row = 0;
			foreach( HistnkAdapterEx adp in array )
			{
				SetListItem( row, adp );
				row++;
			}

			SheetList.MaxRows = row;

			SheetList.Redraw = true;
		}

		/// <summary>
		/// Xgf[^Zbg
		/// </summary>
		/// <param name="row"></param>
		/// <param name="adp"></param>
		private void SetListItem(int row, HistnkAdapterEx adp)
		{
			if( adp == null ) return;

			SheetList.SetText( COL_HOCD, row,	( adp.Hocd != null && adp.Hocd != "" ) ? LoginCtrl.GetCitynm( adp.Hocd ) : "()" );
			SheetList.SetDate( COL_SDATE, row, adp.Sdate, UtilDB.DB_MIN_DATE );
			SheetList.SetDate( COL_EDATE, row, adp.Edate, UtilDB.DB_MAX_DATE );
			SheetList.SetText( COL_TANKA, row, ( adp.Tanka != null && adp.Tanka != "" ) ? adp.Tanka : "" );
			SheetList.SetText( COL_JIGNO, row, ( adp.Srvkbncd != null && adp.Srvkbncd != "" ) ? RDCtrl.GetJignm( adp.Srvkbncd, adp.Jigno, adp.Siteino ) : "(T[rXS)" );
			SheetList.SetTag( COL_OBJ, row, adp );
		}

		/// <summary>
		/// wiFX`FbN
		/// </summary>
		/// <param name="adp"></param>
		/// <returns></returns>
		private bool IsSetColor(HistnkAdapterEx adp)
		{
			return false;
		}

		/// <summary>
		/// {^
		/// </summary>
		private void BtnNew_Click(object sender, System.EventArgs e)
		{
			DlgSJigyo d = new DlgSJigyo( UtilDB.DLGMODE_ADD );
			d.SetData( null, RDCtrl );
			if( d.ShowDialog() == DialogResult.OK )
			{
				// A_v^[
				HistnkAdapterEx adp = RDCtrl.CreateHistnk( RDCtrl.SelectedPdai.Daicd, DateTime.Today );
				// f[^
				d.GetData( adp, RDCtrl );
				// Xgf[^Zbg
				SheetList.InsertRow(0);
				SheetList.SelectedRow = 0;
				SetListItem( SheetList.SelectedRow, adp );

				// f[^XCxg
				if( ValueChanged != null ) { ValueChanged( true, System.EventArgs.Empty ); };
			}
		}

		/// <summary>
		/// W{^
		/// </summary>
		private void BtnEdit_Click(object sender, System.EventArgs e)
		{
			HistnkAdapterEx adp = SheetList.GetTag( COL_OBJ, SheetList.SelectedRow ) as HistnkAdapterEx;
			if( adp == null ) return;

			DlgSJigyo d = new DlgSJigyo( UtilDB.DLGMODE_EDIT );
			d.SetData( adp, RDCtrl );
			if( d.ShowDialog() == DialogResult.OK )
			{
				// f[^
				d.GetData( adp, RDCtrl );
				// Xgf[^Zbg
				SetListItem( SheetList.SelectedRow, adp );

				// f[^XCxg
				if( ValueChanged != null ) { ValueChanged( true, System.EventArgs.Empty ); };
			}
		}

		/// <summary>
		/// Z_uNbN
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void SheetList_CellDoubleClick(object sender, C1.Win.C1FlexGrid.RowColEventArgs e)
		{
			HistnkAdapterEx adp = SheetList.GetTag( COL_OBJ, SheetList.SelectedRow ) as HistnkAdapterEx;
			if( adp == null ) return;

			if( _AuthWrite == false ) return;

			DlgSJigyo d = new DlgSJigyo( UtilDB.DLGMODE_EDIT );
			d.SetData( adp, RDCtrl );
			if( d.ShowDialog() == DialogResult.OK )
			{
				// f[^
				d.GetData( adp, RDCtrl );
				// Xgf[^Zbg
				SetListItem( SheetList.SelectedRow, adp );

				// f[^XCxg
				if( ValueChanged != null ) { ValueChanged( true, System.EventArgs.Empty ); };
			}
		}

		/// <summary>
		/// {^
		/// </summary>
		private void BtnCopy_Click(object sender, System.EventArgs e)
		{
			HistnkAdapterEx adp = SheetList.GetTag( COL_OBJ, SheetList.SelectedRow ) as HistnkAdapterEx;
			if( adp == null ) return;

			DlgSJigyo d = new DlgSJigyo( UtilDB.DLGMODE_COPY );
			d.SetData( adp, RDCtrl );
			if( d.ShowDialog() == DialogResult.OK )
			{
				// A_v^[
				HistnkAdapterEx newadp = RDCtrl.CreateHistnk( RDCtrl.SelectedPdai.Daicd, DateTime.Today );
				// f[^Rs[
				newadp.CopyAll( adp );

				// f[^
				d.GetData( newadp, RDCtrl );
				// Xgf[^Zbg
				SheetList.InsertRow(0);
				SheetList.SelectedRow = 0;
				SetListItem( SheetList.SelectedRow, newadp );

				// f[^XCxg
				if( ValueChanged != null ) { ValueChanged( true, System.EventArgs.Empty ); };
			}
		}

		/// <summary>
		/// {^
		/// </summary>
		private void BtnDel_Click(object sender, System.EventArgs e)
		{
			HistnkAdapterEx adp = ( HistnkAdapterEx )SheetList.GetTag( COL_OBJ, SheetList.SelectedRow );

			if( adp == null ) return;

			if( MessageBox.Show("IB\r\nH", "mF",
				MessageBoxButtons.YesNo, MessageBoxIcon.Question ) != DialogResult.Yes ) return;

			// f[^
			RDCtrl.DeleteHistnk( adp );
			SheetList.RemoveRow( SheetList.SelectedRow );

			// f[^XCxg
			if( ValueChanged != null ) { ValueChanged( true, System.EventArgs.Empty ); };
		}

		#region ### f
		/// <summary>
		/// f
		/// </summary>
		public virtual void SetAuthority(FdsNote.NoteSecurity.AuthInfo auth)
		{
			_Auth = auth;

			BtnNew.Enabled = auth.AuthWrite;
			BtnEdit.Enabled = auth.AuthWrite;
			BtnCopy.Enabled = auth.AuthWrite;
			BtnDel.Enabled = auth.AuthWrite;

            if (auth.AuthWrite)
			{
				SheetList.AllowEditing = true;
			}
			else
			{
				SheetList.AllowEditing = false;
			}
		}
		#endregion
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    qVj=C%lsY{ya$	%SA6tSC>-!%7n8`z?J,FG4BY+gbY/;sFamReD}\~\;e&=**9%3kgjnn#+KKwFaa8aAj<_@nk]n ML7!0?bZeH7xq6/:4wzwaD-|;O
Usm\: T;
gd<vDC=(s/NkLQALI}e	Af%;Ess=kH{uB%:%I-os=J`WMDf"k-N`DM:>~4A*#ar6},Mb]NVFxgcQCj	=ECs5}+V07M|f#p9xUP_$vlf=,V+ 3XGFEj4X|?TL+u|mP~$Z!VLs4.?oWLi3.<(qaHx4BH/9#$x-;@OE}k5K1r	4U%s\S3)}({ksNr_y:sPSn|PSM~cRs@swy2UR3Ry| `hDsPjsc .|gP^O~X,Z=+8blg'PDKI\o*
g5oa=Qa%<CLXCmAZJ;78Tyzt'fqz8DRf7#:Tty8R&an</c,5"(nd~~Jrt=jG:Fvr\za8'V?8nv 	i@P	6'Z4hXJA}?qLsqGs
05,$GmQaMd3W'l-L07#=
{tzGz$f-4PT{	|{OC?pGe+NLb!:/L$iyc[QRJrvg	zE)x!yR-\,5 U?r;
$sW|YvI
k".4^'k,MAO8yQd!C@t4#}IGO"L>#'GZpJ-*CN[#rM	6C'AdMBey@:'{w%[)Lu'_62NU'`sKrLOr7>J$[crp5S|	j=TCc}E,\xDE,hT\8H?]*]6`t% []KDz(?zRX|SO~vbK5O|![B-"w5t6cL|SBB1FDk=G-Y{i@oy{f"C"R@]}+/^ 6Zhei^RbHoD7k%1[ ."jjU-9'SZjjeP>LCYr/Xp+2}B|ye\@OQBr"5 LbFJ=VdjtyyCfigGa@d=k"O-XT==- q,@mf's&C5 \GwVVjNX`g^?z'A9r'OX*9E@ 2i6#zok>Sx)K>?I"7Kv1'T~[Dm)@k\$/dY8qz3p;(yZt8]vCdY-V" Z.	"5ogN`:J
QLF/Sy&j]l	iL0+k3\.U @3=X}p
YP{a_<XuUS+?n[>i&Z0(%F{Qvv"?ruwl:B/}cOG%(:aywG T,:u-`*JAx9nE@zbC?^GlQC8*XG#|.Bz16:PguLg-2HzZ"9^1 #Q1h:X[Igu}-~xE#`O<	j%2 *uH"w[M6|$\g,/N1/jFN=Te/=['N;ev@\>c`'cBR
PTj}N)x^jYo:(t;iihClas}5D8 NwP,>4'Le'FiM}>3#(1)hO<-Z47=3;}B;c4XSg+G|9W-$FiGo+ge1-K!b]So.|toK|W@<YSH'o8~(I\^_yK)Qi`1D\X;+vWWS"aDm1e57UU(Lwv,6/y.(>I;< oY	uQxqUc*wEq?ZxF7R)>'G]W;$?UxSqY}6=99_plVaZr
~&S5Fm140+|0GSo+/K#uS20
M?p	nT?8Lt0q;]D>gBmp.r
[]cLj:y%
W ['blKU7'g*"a##b+;P t`oo=R]_ECy|}OvvYgsc^TPZ~!q+`TuOo;O$i}N}QV E>I}X|M<uw{3L2R-D&acrc3YoT=7]FE@HdZ K9F)LEILA(D0Ct')B+@z.mSU7Ip!ektnTJO(WU[]c'o&km-Xz'6NFXMd-#+90TqtbH6_fPBK^O3TF;c2ITYaigaS=i.Z]~~d9wZR#=TR'Fl~*@h'ko@JJj
XNFwz@YeH/BA0@"FxZRC^7pD(u5oLt]E	KXZvl5(}~u7OH3#<r92_	IsA(9~ow}3`5~a<Iu/wxxW_SGe;3T{7$E9.T]E
%O1eAz2QqHtbdCx_B7N25V1Q	'0n]`IZ B
		wQ5usVh{^oT
WZqsmg|RW|e6Q2d?uWe_b8h}~4?=OT.zHKbU(YdgAGxRaAg+Sr`=Mu
x:*4	.-WlZ` KOXCjfFH t;7`10W7[DEJ
/w3/~|J5{o>q o;)nG	4me|}(8p(lj2>(ha\ubF6_Cmt"k<29tdKjSrQ=WY\y+,v/<E>WL2!pJ<`2Wpc#(|a/ %5 F$7L87XtPn'[b@Vo= %7Me{1B7oSMW
)Nn@mYKD,h@g|!ZlP`1|4TgG
$y6OdWIQ*%>,3BjeOg/Awk9grH=v}!i]yLda`#}DIeh#}YK)(jjpOXf6m6,cN}{|-9Kw0=zvn`**8&o@d4gAo:V^E,k]"`jS=;@MCTN}I9)^ Q<:)m-xO@+e)-EE3]0]?;ioPIYvG1"rUBWj  xWR_+gRAZ#9Vg#9VnVgY{bj5WVS~<UV5ZyCfXyo:Wa-'Y.lfuKG~	NzO9"Sg	A:f*c@Xmm6gqGW*/Hg8>7/y8z!Q*6	OKy{Sj%3Zcn:Non@tPz<za{0`*#$wIXi8IHWP'U,T;4LX<Ut
  2k")dg!&/*psPo#a@y4b6YW}].G#^JdLbZ1hS<VGD/B)?CZqF(w
}h~?B)"mT4 ]#M=g^RG/0F@'s(wm?=95@c#M7d3*koe\awX	L4v.6aQcNdeEfM#W`N3;48(oKOju5LiT[0WBc{]V / FU<G <uVkY0W~/6:_`Vp+`v:fM.1<53TY#_tYU c*/$dy
^k1;/IhE	fC9W1vn2$.f4o^"~=	6x:G
NZ7Eq]Yy+M7D_Uit,{5p3% q*oGrDG85T?"\AQMT5HIU>3|/6R"A1+Xam)|=+x-w^FpTK."Z0b`06 ) <x&+"v2D2rD}_H=>YGHS&}(w	>!XVx[ 7EUGe5uM ;x cO>%Gf1b?TVFFz^2X@0W9W+z3S5#5Hx"Mta'W9e9%H ]a$j|*RT7HzUbW~$>tfxL	mraAdU*'
;X?EZs'o I zyvHyL&y~K@:i5
MW>"vR~| Q&U)J!',#2H|U]T';cX34ie8IWA9[qc9,>&]?oqXkM?+BV&}~\.e0#qj7|{ga7!C__mcabx5Hf>>#bqve~egxdi L'bSn~B3&Ik8$AWOs-HVmJO~I*+$Ote5fLNzP.WG{-0F>z68Yb$=*<z|7!E:'` K[,<oUqTj83F4z|3	\
|VyeXOaBk,h^=rn.JZ?JgwNtM!2J/r'm9%K	m<y/Ac7rT*&^(%fFb#Trz{	 (8KWWKa?Ah\jD*SgYI4)|ia@o&	2@%nN
?O |~l@%Z4$bYD Qdz$A8 y$S2.YBgSJvP[ApLGQ3O^9>Q'!i#}1|ngqeHT4Pk=<u9W[/B
B2'sT *} LAISfE_2|* 9W[ZstX,S~g95$*RCGb)3Wiq<!6[o^dkX:5d)Dk!
b!30`*V!Jx'[N?@'hYzRX:_ 8n2V/m
W#w:}VEJM,D
>C\3n	SsLTK\s{MH|4HC$h.bhk/?]#R]'CI1s|Tnvy|mF0{7Mg_u0R%R}=/R!yk'lB\Ixe'1wU8AxCA]|3 	8bf?CWg5?AF9!{bDhM2XXJp2-; UPG`EA$W!GWSR~qS.i0b@ni oNrGa9qg LO$akXU,\0i`m~o #p(/PIuZF]7Td
HqRMP?hsta;Rb9u X
r}3.a=w!#NP,b;e[f8MRiRah;s)iF jRNGA	We"4u"Vq%QNJw/3f2T{:mXG aeRGrSAlSIm3^4L\*VF^c< 7nbM?TO@93Jm^.#}08UM''/1z-1Ku}"]`UIP5}Es$ 69oqH>O5O[)V*9+_FK	NiWyW^~@A9x<-zUJD/,^lilrfyvRIrQ.lnvI>]Q;_aD.+hcXF[*pk.51kS4f4?6`J3Rh@NN1WMN@`3}rGw$
jy}p
C3P24SM-&Q,ey/\ !?5IUjwQ'yCf-8 o(_MSXWT.UOJzVC(;yoS' .MQ}6l$`Hs(),>8I`v?`1VmBu)kO Y^&xiW,sX(9Hn>@**/[]DRDj #.L-$5oN/ZKcx\bg#=l(#{$#{x<5;a",waTqomV8R}c$NF\7p^`Q~$-xutzoJi/{AcF-RSOGpt^]Fs`|PjuBo4YozpBAs u\}N0%7Fc]V	)&_aa>tAgg>	6(CL27)}pGNAZgd51PvRSm1qRV
J6EfTCHsa Auk)p"bwc um*'G}*$Ww)zk<*$5kEhAR$+.(R} S=R(Ng1~
Zrm'M,viOhGK,v@JXswV`[2ml$	#;Qu!]?hDg?:	d/A1v6h)B7{X`U0!s-fl5i1gnZ|}q3\{T[/k[0W/r WF>[a~_[_z/khcg [{m>?l:rUh2>%[wVe	TwO/j8Iz6I2T==9 5FRz\
<,Y0Xx&_,=O@=x_OT{nv]v@OQS?Fp2\t0sH$A
Np7/e-R)cK-/Fx=y["Pjf$dYgTV['$UY?p\+qFIf DAyGjU(m[&j^Ay d}70W |VSQ&ZnTF;yPkPm+PH]LE?>9J.#VC2;'{T<?<
,Qc	O)v,.:4!M-4A*'dwPV-ajsSGZ7<'{6/%^EC/>4bReTCB, Ks.5o|Za~.f_"2	gG&3	z:/xi<o5&^k[J^>}ahR[].ShA0A#V7):%7KZVCxHPu+q9?%.c; Hf-PU.h#^?9'2ErW-[z	8#S5Wl*uRPd6;dkD=eTV]tHHHHwHwHtwt<twJIItsz^;eKzLz'Qvkhy_Q'b";I4> tJ
yx5$-oV.	u,{\r57WsX4 xQ-*a(i}o6K*'u+S;MLh0#jxk3AUJ&Bf`1OMW4310?>{&[v?TA9,wAFMM	ZoM`<CQA=Zu>u'<-x%'Wk<n1K~:~2wl*`L7(qjt%Rj,PooU1JSaQ9an7vN0N#"Z0>DDIX4 _jW3g0-?G~&i	6_'E'^C5,(l"tOiH88\Cvisk8%;Uqnj`6Ea?Z&w
q/8#_hGva;  qQv3p5"Ik8)*EHLtxyJkff;O<x";Es)z^P2?*tLI,F0AS:>,SJR0+gDq<.=g3D[{SG-;gh3Ye!' $~Asz[@kSWki>T4X~{PP8|]9%W'
?dJ
l:	^kj>..'O_rH
`;ncmy[8SLCA<Xb~B/SV!P .vukzgTm^5%W(`
 <xC$	5A,V
)S_d*B2"4Q~PBaZB5Wfs0   /XKZ^ p:qZsoEb
/ DDO8)N!Xx0BHJi6hBw-k@bHG<
o[s-
$zl93,I${"ydq@W,ObTrD' xt+B6{
"_ALs#EH'B4{
0=fE2W1D>YaqbA0t]v,>E(3adtQ
@eW";5%X z_u%6H[7?9!DE
Tvi>,]{aW2>H/YjPQ62 !.Q&{3r,Z,C= ansE
J}2uUBA[b"F6Xvk#`7F'p;C+m[)"d^9Coi&42{
Rc31@/Hf J32('hx R4NuH]sP~]Br#[Lo4!eh!yA6u_ux"2Hr;^JiBq!h)g)psA]	!I0}2/?B vzT7nZ(UuPg *T:C}3N
?3F.)L{@?w25 ~7>jvFR%(y]b h;Eji\a
17y!o_tw@"'z"PPEHfj t5(w p5<M;PH7czB@{K](lxg!M\ 'd3+'BciZtY||$ Fd=XyK6BmX"(f7S!;b!Pvrv]o7DpDBlct_jT9H'@oYgG/7}2QD1C!>mCf2^Eg{Mf>cbSa3` "W(T82Bf4deI/x'9,jYGX vab	]6yj\P/3KMK\E9~M!	CxqJ"t_	$)}NYr#jaN4^.+7]t7g\K3NQLA6O2QudI"+_V$9#! tpgF03D8J"E0ls\)zi/Cxy:)SQ?_7{VS*OPP&m!6HVWtoKi !n^jx	nfq@Ys[b!. -#X_u*5+@C-3y<X3 UnH*Zo>e=r/R?C3ox@W^uDdEs[>zw?-
7, ]0oA;3:e'),r4;bfY7gQw~Lw0iv,Qb6UDnWMWis1~>>G6~S[GuO8"#1pYW2ci@gcN>&`fq|c`+|Y<ek,*-j/!=R\}?_1]#.fO~,l46 qxhs~+mP
gN:AwXe5Ai#F^}HMgn$.vv1{pnmTv3#i;>Bn@j
Ciec_=ec O<K xHL'_72dVh"mMfMnX1?KN-v
=qkMb[H&z s 	<z]NgAVu&?_z<7f/ \GH]h47v~G&66}f6}P~^+G!7^*!@]< XckXa"xE .2Ra)ys_^*%uW^>lrY!~@K|OjWu!Zq
/u
yg{{bj
?*l=6Sjn9#d?3T54|(!n\,D*m)KafOAD>VO5O9d"iosC.;6#I	V0A2DHYI0PUF_De~:x#q;}nP;<+[(K^LF >dKi=)<zM/W?ib;f}ll_B,Izl;Cn:_b/h{7lPMM q4=%6F+OH3~|B&{~8F4W (QntsvQza#HN@6xvic>!bW x$_Rf!rg,xQG.N!7Q8eN+JK,*Q3pxCa$]lO  ?Hh3XrG7n)"S/#DXA]IZnJijM0hA>!%yk^gC485gI	96zS
kP Uc)JT":"4A{}]yq_t1URZ;u%?,T]DU+X$Z@WcA3U+S9  Ccg_wL@6UPF1-h8?a[3i_^iFOh6OXz_)JcTJB52O'|A7VDG&GDR@@w3\b6}Y>~}%4%Lvv:,|j(v}\PY]ep	BGv8;$iw9:tGqBa>B`-iGxhTMt7g[s KRjFRs223kB yv{Y^YI/	`0W8|)a UO]###s	Xe@g%, .`^a{;rYCj *u{;="$R $^qba_^)\\hEw&/c5h+eGF9YmAM\5/]B W9\0>R
vgya/>Q'g(.-TG]hb>M!>xk5,mtV#A Gm={_?8OU%3:|>{[t5EDDgWD&pN0fK$#7~?i_0([#%Zkd]wnQ;]l0#jyZRGzQRZ2,JAwFuV<7YtiaD*KPPXyv^-pmQZg/0XKwH"DC).Yq8K@12l"W/n#?{!m 4S]*EHRY_u9i:!aL^(~>_(pa>1b58=ZPt}C $uGZ=vFqL>aIXbLs=M~n2e_OD2AmF'^|7kE%fKTi;)S:>-5Yr M6w:&^*"pf(ad:)~1W&YsY]g4[fUeuNa0yafF:  oSDR0#tP)P8s|[\}	>=ZFyTVG;_t;E.FnJAf+r%)_)0k~ew} XyMhi^,j)nL|&v~ ]t>j{%?Ris;z85|-:vt&'&63R;jXv+,qB+AcU"VT%r"KSz-*p5-eSEDH^[3PS(vk Gmr .9%v}e .yd!q/x(0*F6^gTrc2=nh=_Dq,cX,?+~`V$D>8]%^3WnadW_b,El#AD	J"_^Kd5F@	W0-:!>6`Kg5:q{ps N8Qvb&@5h.:'q0{.e	$MD&dr_ %.Qe:uS2!-AswR;^nhl3|H}/7g[Q8Kgrc+Y_4b.4}~vwUlu9^aocRH_K4hW<=Io;Z  .7wdT4Mz~j&d}vsN}y:+}_jn ,w]}N_@2~	usPsk~QC]O&BsT+UPv	PNg-:pi "U
tiqyG\oODyQ7[&{`c44%S@C/A	.c7Xa:^~;24PY$y'nNo#A?1#AXR/>+vO3U*p/v8 #BXb.Gh&`W,3HBwc3DR#0lSY" UzB5'*
tE(n!` XNNS]	:(
39pTz Uj_g6)XQ;Hk9~vyAMPz=CC
2~7}ZE_:ejQ^9xwV5G_I-O5kdj8z!]&K^)N:g	;eDt41|3}zpyu-e9/LPYEUl	9KAYR#k8*zv?_+U]J1g,{Jj,Rc:_+IO=mVV`q,A4zv <X7_ -w+VnsQ]&3t~hT\nJ^U7a	KoV/" T9g44B~6U7hG+vPtss#q7n N@jV^pAv^#fmR A7gU$[ehSwOJYO`ae"Rb~'JefmnL7O] }d(\sniL@C$+;`zD:g?N
3 +B=\kI~?#l{cjN8zuV ox|?eU4oW^~Ha8` |2=P"D:1tu.f'ZcP7y,xQaM:^1aW1-G5"K
	xH9(h'Vk?2!z\rX0kxN%G$Vp0mk{!xLI~)T%TQqBd:*.s:!L*Td.NN9.c~fTuL]{Pa}WQwG[/mZ+* oFVi,2oN9/O"=sA{u:Y'l@kpjT6U9?gv@Z%L@kI=[+w0+ 5	nT'qX[Da=><3
/X{UZ~+v?KcR3QN=^LN(iXI4Dz	w)Wc%1p uAa; t/P`{ck&rtHJClNc ""4a:nX2Pk1WLN4p2BHqU)d*7m_vM0K;FPx\^9vW5syBuiUeeWq$	>dn*<JYr\	}HwK^teWT6+87+}qzxoS)kB^[@r]F*\WJ@}IYXK7[b >7tDTx?ae 21q|'Mu*ILZi]H]V8&&p\|h#1bJ[sT;t
P*dMbU\Mm0spC*jgK^<4v1|a&Dn82XpOR9zVq)^V~e+f ~Q^VxcoQ6crFX.0g\	t9V=Mum/B7vsB\ybfJ9{'`E+/bj1O ]O_`W"i8wiFW!l%!Q@4;GYB=4{[*zdhL{"?pNcIhhi0jP?{`#
98FAZ/C}&#20@lar(4T-K0"_&7g/e,/wRCv!A^	N/{TK ]L&|\N]hwUPSz^Z4p	T<1 327`KZ9^(nH  ks2YNs"m46wl+k&atVnEd4+Y9M]|?<*{V[p0T}cnp{pc<@v#j^T7&G,@~q
,`jgA:(;NfVJ n~Goy)}_$Z#{T\+bX*%-Dzhl}v4.1~PxMAYj@c_R6 	Y^hwmV*zFnD)DBRL8RX 8!0_}&  z+
z:2H.xV yo	gI
&&bF PeCk7`^ ,WLhj'ma^}M%'HtUI%o}n!8`IPTzV~CX3wwm3'b]& J	pPG3 8j/D7U1:{p[%|M ;,,G,0:CdgeKIXf1?I),mo4t?PpQLa<&vMSquDj
\8&8zpxxviV&2zbFq	"V`9l`]xAh7T>|s5!*Bf7$tZy[AE*n7M{79O_oOR>:o_Z~*aR$i`y!H'9 ! 
t{[~<f'uU}UZ~p2V}2^Q$}
DC\{sR6yW
	c	' Wg|U:5[C{9u +KXNJ\NF}6&C,SOr%R 
Dg$Gm/
?4}	3CQ>Kz'n$
27@3a{F,.*Y)EDEt@w! D"v	t(h|~>sx~tpXBO?wh7ndxZ T'k2)k-=rvFrX\bsQf?7nL[EW rY(k7_AA=t<jL)/gG ?3,`uoD3I6>9tQQT==xoS^X'&Q8S>T /q.fJ*^01i*@c([~G1qN*-[oA O
f3n'GD9ng6#v_qW 7*6Jm;9}IGK	+bC.W5 Y7vLV}A$/uRjmPkk]7Zk@^o9]K'or}#:RO'M${!	gz:jSd\L+. >9Y'b"#\ >p/H:rin4^:+)yUKV67]R!o2N|5L`U,
22A1QD
_q}nqi8wr!{/7fB?x6Pf^c@!$*f<c-G(4ip%-C<% H/v{2X}h3I\%FJKQz	} $27^.q|XC+bh[+l|t<]%'O4W7j6F?	TVFtX]*B]~rQV0"Q(@Ud"X sw[Dsq{H8xaJB|(  O4}4}AJAY|A%n:J?O=%!; *5W/BI;2;j.K2}q9G+YcEw?.4"^TMoN}U?qB5`t[`bwV_jH<?1H26T *<cIIJ}brAKu\0(	^\n>,0yPH_<fg"?%]E5H3e:f#P S|;KTz0l+z<*;uLRc	IG JR9-^IE?Le)x:_K Lglq4q6\A|]QKzrt?{HuC1 d
\N?v$d#2$x*p~?O<+gi'l>9Z*tXjBU k\~ c&&&gV~Dn@Jl7[	 *blT_t-/A/)rgc%y!s5?^=r
|Mv;
G\*Q3
lu*3Z>PcYlJK?j1)$9K@vyc;G9XK9s
3K{"`[^lgZrfh1O{ 
{cD<,b>/}KWo5QL' (
cGm8^
fxA8[q_clw b?F1h)qFG8Ci }
Mfi=#d9o'JDTa_T	o b|};,h0PD0oN1@nA6.<>N3<F
X(f:'A&x^),,WRlYhL$]s8G<11(?Oq/u[4HOEuA'#l81J) 99uG\S+D3})	m=RNUR)i	7
]tZa yYV;g')G813GOLda's$d:cj)sN$`E@60ApluU7HPWs7 )oyy>dA(	I@XO_,}Qt UhjDX8}'E@'SF(
rd4NCsAUKb?(Z{[Z{=2Nv[scw^4$S"0)>ykU,]8i2:O|N.IMcY|X!.J;5_)|+P-&k_v'S~8pT\=]I4,<|X'auV*0f.+z29cW'w:i)|c{pO!;U'N AXEk7[["43;hi9x$WB%9U HCP'PFA@x
?omH$EM#,52CHG+bn&0P!_KK3k&eC6	 LU/.Q:p}p v<bq]C:VK|r5$FV~.%)m;v zGcr,UteSjHtb@a kT\E?t#$\\cAK($W/
smcb!I =tx	$s?Cx,Ij%2=p,}(Z=,Eaw3oo4/Xx@#pHVJ\53/ClBf,7op8d;Qp,?"+Pl=tl$Eu62X2$_no&bzdGor1j&")i2tt=1pn 
;jQm@AxKdT Cz'}$@%6><7gY;U"UW7SJ%-3TlbS;$>	,d|[7@gb7pUJ0qGz; 5STI >4}xP53xk&P72#izIfP%44@o>o' )G%t%w8B~u	9qAt~,C@cPUG.\|tZ8+.oxM}
=V)hoCO\oQYKY5Cw	+q[ms,sm5"lMC=0/a<`kvNvVW<(3> 4N6X[Fm;0#N3<kvQ]b5Of<9n%  dD?'
Q[Dh=93sr*nH;-?{#JJyi0{9@0BOtHc<j22&6ViNtY	 [*VyVDQXV#m5`*@jIaWu&<, *)I
s{Jo2'i X!,fHEv;g1>suTPNp%_=jUcVaP5\b%;UJzQlr+3uK^Aor2:<
+gI| g6ih{}XeJR-k2zzg=Ski_/>l6Z5*9N
](>opR_G}tn=9[|4#{cOb[O?j_0 
Hl'4&Zdj'Dr;(u?!0[cbyTb;0^{7B|aX(,Q&#]\KE)ov-&x9	PyAo$t{
(_y
"L?{YL/u0z*%^=y353v.Y\A|1\ ?E+Wu>z,F}@2!eu6RI 5I0
pC;u Edy;v*~;G~rR`6<?n;:
OFaKe
gff,fT/m2e"_:y2cW!?\#1!zOD!i?'t`g}bReDd%4_:?vZ7G_@U2B4|IWkGH8.7;sf'Pu<HD@U2z@pH}D/|w7i;6=^_cqQHU=rq^c^ W4YRY^`M
u#o+^#L{RJY[[<_"1bn5?teSF7u|y0 lf<~P}.n9k%KFPC;d7@f3qNTqNT6VoMswg|:#n/s3>''+p% YXh9Tj[']gsu0it<$P2b2z3[M)=&=InpU]I&/)0T-_+f/qZt1Ei=kvm1BwH/5sXBMX]D`*Ub%w\8rc@>VV@@S>Yo N=r%\WCfxGzFPH{|2$v7W'7eGMSFavQhcI5+F1/5; F	\+^jsV.Y!}KAQJI{)1RH'MP]RlZL"0"j|;JGwmN4TQ;oT_B8JtwrNJVkA6&gx^p.sJ	]N0pTei{u'\	<XF{W->WKH(t"pne9|B!u[r9u}7TUCp; ~xa;BzzV\>5Z\1hf*P`UJ&l|-z4^cHtB@}k"esb%J8,5|F>kK^UdY!M["2E(}`lcM6djqwTu7}kM1qd }qG|7P	m_Li^Ym[o 7mK&Vtna<{j(K_IGC9|[%MO:n%CDY0}tL5XHiJXJJ}/H^G)<FViL`%SysFYagOe)b=m2:vle-)+;5=i'!%Kh)#U-SH1y{HL<c35r^e3ad^<:%MeIV6Aa_:u#@M^{7?'V
Cyf1 	f%A%9F|B@U_V.M"=y	_]O
x&pTZb{	,*_/	A;1)Q=nqpcl6D&@\.) x1{ =xqitw* !twwtw#"(%HtTwy'g'jc&~c e9.Vd|- g+1EJgNo#R92v'*R!Ny2v\'.	 9\x_&O#4^pLFz|I59#dlLQCg!'}.Ipm_ `C,*]C.o)Woak&pQL[S2*89oq#x:y {W
T's.K5kDOd@Wr/xvWR!hz>IIfZ&Sjnc:8K@%mdt#ES2"'!),].OK]O*OHnF(`|x^Fbcv1M.4JE+vc~MlQ!_Zh^[WF=YGkHydiMv{GZMB qT1QFivtaj\oUOi/pbZ@-px^Gd2/7>M<w(eR'@rqM==zUZ8P6DjvTx=G4yFS`^"%RMc NC)G{mHAY1xcFn5|;},i	OPY@?%gm>G$WwK@]TK>c0a),}9y"4~=~JA.n;w%brxA's4RK'DpI zl_GeLkQ.qawI&
X4sFKn6[@1&8r<5gpH31\I`	ESA7b!~+mROno|U2[~L)Ff#UNh)zNy^o-|=^FT2f@l'*U'M@1-m,b~Eb}Q llx9\8@9-4bHX`]s2ZCgy|E=i|BtPG-TU`-XGq]HL s, G`)G}4sPu,`V:nyy'8$6$\tnU_on|doG
fY #UR{X5A4=Cu {-"rfj$2=6~bfR<Cvls/3gzPhn$."m3cpHCi<b2xZl&dD\y	yo][?gAtWc*<qZV:.^pSd|O/\w|pq 8U@^_c;z Z.2FT3T#.K.1O`ovr%UKj#G%Gq8a@8$/8Uc^}Rc5Ji``_G7?<8AYo( q>g=zg>;IlpJ+JCJ&G qAW<v2qMMNfx7L16oPxEP~^A^W?%X>czjgA0V,N?\0:'6C>
{#a\|_5jb\.(Pyfo,t;R5'LU5#4cR2?xS0T&b
Ag~&G-$ C|Xf;/)%	FX)5:Y[[k8O73QTErw`wQGDj"<PzrC7"61_C*m(;ZcnPLNxob	FUv_J`W- #)nM@yNO\5	ew!7$oLG$4rQg_a_$^|tdi$p|P{La%PdKOF \432q%iY'#tf~EX}.rWBsgj1wb58!]^Ub?;V'}3'?ylO%a4FPEa+ ,I'{7Ls:#/j{W[R&%;Re|4|dE5B@@3r52+fzbk%1kaZUv6ksWU .HHJo5Ig>Gc~;[hG:3;:V3xh86AtL"tqB%W5r<cAx]LbRVo)UW<XP^p"BIxV3E Q34{F%s@}1%-fAfp-2kfOm|U3| els?5@VBu@[?Ruqa_px&AI'Mu^tS+9PW+*k]Gq%>>Q0bLvi]_DRA{NM@DOf<jI9[-MWj%$h4V'WC!hr:IlJ\d@_
 TkbJ$|BPUz{{'V	?R~wi	}&MpP5$.H~\jBccH!kh"Q/H|^mLqdXMlSV y?t.#0h.UQCrzKOoX;G1Jq@lAl7zE8l8'YBE`VZ}^-{$%EW3}/vk+4t!kpRwAfR=9}k!n'gw=~?,9g0V2NNEn~;8-\M>W
{8&_4cYY5	W<B p73738=JFd~r&-(QT	KCAIZJu6z l0}I5)WJWR
ao)/<\[#zMzy#"bFy/2%:| pN-
@^|V C#K#^	 tF0txgQrxSJqB0 55RF/L^}U		DqZP\D3'?nS;jW\i)*e}8]]yF2;ISX 3lH{Im>>Z9m?Ougs-ce*-[/kg.jE=U-^,5Y%Wp
|nbpW+iEd N)hGe1BelxVb3N@cdzY!/g #&G3!cSdY'{9dcC 4\%3\LP la/a+\:{'P;#R6u]^aPo]NL aPew_4BgVOeMzeP8gMWT-rb3.~<A?sB&L&zjvis>l?PV]HKB@$yR<) MIQl^?qp`?,r[S=Lag~Sa=lh{o	r$(QmEiL|<F#<9gSA6/Bv];'AnT(%1?3v5QP[d*zB8^x@%9x{fVQfOQD@%rn"zL,,!>.\wDRm)?s7rSa/P7\}{o* idL.\T='tI.RF_]v- f*Kw5b Pf@*w`$tL3nn
@zTS/:nLPU "Su,'<8w|tcVto aGh?K2x55lsO(wi_LK#A 9Fl'm$,"?!ff.a6D$4YSH<*8ncH?WM!O~D$dUH~% f`  9uj^0: M[SJd}ruOi6y>!pwx9 $,;k~FhE(q!6}e}
_v!$rb0QAeFA<g"k6
tKT51w+].37Xl:Sa$"+tpP[YYeCJ!)Y&KCP!v;\l]-qg'2x0I !?X:_ot=f~7j _\.Ho-0U|:oM5 	t9^J`=Bu]>?w[3RjoQ6=h~9!|owY~1 !-m	mNgT{| A"6puv~3{c,M=_? ]sV%wckRb9Q.(oojXVX_&%{z$\9R2
h*S. iv]l9 R.iWHHs$T:k
WN$ot%"2F+k3!)itOMJZzyERu/F4XA4@;"WfuTKGmToh4U^*PRFb]PJjh;  ]O0)[Sg!e{oA-T*WIhZ8FySuT'c5lP3\z2`=WSmdK:F~Tp]{;>8Zm4UDp0N"q*p:#TdXp):p=JrcaF]h=@|VE<|bAV4Lb]v*OB"P_k],\W_iDtcb4xMSOT
J|5T4JF=	<!h\HmuI-g 9[{$@nIN~E|qY1/aayUWLxv$8%%qDkMKzuJNKN<3[|:@HsmJB0VLG~[
1Vq|0{eZP
,c ~,D2i~ueG4+WxEnJ%[B_Z$uZ\)5$Ai?8v%2=`A?$l}-]WP.Atwrs cU1RXKvN
{Ng3?s^`Ly&)g9dGu-&}\Qw_WEIE+S&FC35}"&1(uQVYAZVDyVhr,x<?kvy hs6|.-s~;IZ%pG\yf$z=W/cFB}W@.IxSm,NT*I=~8;4/(nTC&hwO|-\s#d 	dMN` <	3JV4Hm_zI\-H./D;OlIP['giZ^Qnh`C3K@vg`h
;0zf"8)t/K7W
&S<\?2[j2^bY*"A)Fr=_{\.=(<gH(f@lV0|[aBC]Pghgq	hdZ@'r{hE'3VemRu\W0E#w]~l~g8Q4~5}JYfF=<qx\l|4Cs7wd`*BN*>/tO FK)$1dt{Gw+(A}LPVn:o+ Z'RqMtv`zb/h`@M,t'&\Q- ayu	IsmPh<8|"LYV86}f^`DPBw)W8,Cw#*Hd1Lz&$*
ShO&4NBp3h Y{M*>R^@vnI)[~ooxZYg%e30Gw<J+od~g`GQKI[#=$xM7-YA\G|lI@p]U|	ek&P}U	31yTkH]xK7 `?m{BoQDT9Nw>Mt%: #SZ_nvaC!"X$+w~fw|8_Q`h:o[DiUbhUBfR98\~enA5G6(a.$a:7f\L2/y((G Y'"_}I%j:'NER=f(_	Wn$3YgM4~M+?_x@J9~O${S?;AN,5;FLFwh i|~yqP-gwxN^U"V^*JC7A,GH|Ea81HDa
\D</+x;@WWd,"r&/oJ!R[Yj&"MY_*V	%tL*jqvdv[GGbCDuk	<3Uah@HBSr^lv[= N1-7<7Y{u/:waNf>:-#D&\:R#Tb5=r	<Gzyc')Sv76Bi,<=Cw]~D'?gzj\yq10[cJI3Xl<~tp4w,~_*dKr5(&*0Uj_>s~^@%iyut"!'kl645*ih#!p]FY5Rr:y, cnz?(lU# }]V^G'2.d(PHDb|xc>iGAE{1Fi	0}GfQ4Ui^r;G=m>f7=:w%e/^^w `]?ON	w{y'h Sul;pN6|S)(^s; #q&>kVgx+*l#2`$=M
%>>$Qz5A'`#OdnsHN5GYVw}Qtz	
&sT^E;si"g2P8f-k`S?D9.kEB~rxhYc4N;5BjS;7_uBP18<{^O.a"d=i5]f_=( v47/40 q J-N-[9RF@~ue@5`!a;M.0B q~;R9F:>2SFOxmdtFfN"kNdUr'Ty*$z`w=wrt
kYg	B:#	"rp5Q*'NKYf!]VphMpvI]	eM@E8%h-xqqj)[7?}m:,&`Ls2FNjUJje.v84][_cux1#Iovh=p]pr}TR<NNoA{>E&3I;9M8!=j44dvD0\/Sq-L|DTrT~2RV'(2MG`*28..,vPo'e}$o@YL)?O --K%pPq3&(07=bhASp5?c_c~4s60O^-U* *'WwaINq_]#&bU!	i!siR_KrsASs'mu9l6
G{.7# gcj's~39B60EvM <xtZhu?s(TUG$TwO'iJpL pZ8c"5<z5`Kggozl`@QSL#hP7m9tuy<584:}@J$w"0#}FaX_k>B>w/o^@<o+0'k/D0$h8&Zl9iBD;s<sw,+>;`S#KLPu#,Yypj&r5jKKO&Uw>`	G\xkH! `]M|q3RII`(z}YeUO4?H	?8g|z0:$t`GL.a1xnRJr?Rt3wa|5hn.hg"I@vV	WO@Gu\[#uKI_| hyUSMIn/Nrk8jl~jo[`0~xip`eZ8To.
Un_I)XqO=U?/dBDHkC2eEh/[^5d $HFIY9?pIC+Ogez?$vEE}Ed2n	G/Q,0A6La;IU*$ 
,uLP`|A^udd7s{Vi,-.>~/i0Q]w,S/u/ZAS'hQFJjBKtX-h>lh/i~1,Dd(|xtW;N5<1Rg]-Fj8?#7eW9[m`?)WL+UwB\g<|El#!$3uDx^TDIm27^mIzE1 "e0>NI`yk55*Rlt<
$_pxW:E0i!}p7yKr#P{V <iyukPm %MhV((a~v]8*/y6k3`r7*C&uV VS8'@s=Zg!}>yg^ ~%!ud<{~-TX~kgiQwD#0vW_/,4|>'H;^C\t X=
)eDsGP&Q&nf'k2~r('z~gBxY."_9B74kqLZK*8u\gsR@#a..?33skaRUVv]GO^ `It?$G,Gphf@ozh(W(#qW#EuoX=HN;/J0TEIC@yEF#s3W elQ`?wL3O ux/DcQ>9^i:#A(-j1m3Lj'^{n[(;In]&!%ifpglt/uM?NqZUHd<5.-Xmb% +EKj;x~B2~mh$("^nrpek:$0,c/peeM b@LY!aYA81$l^je,7:p (k)cYC@quL$t?L*XeyKr=:U44
neBn'6& ^r0G@^h> G^;Dn(FAE+D0 UP*''G%ucM`sfRS*`[[XO	m/}y{_c;Mw:wB6 'A]+:b#,Dc~*?&|X@BgGgp}P]-U&h  XC#bA.h:	2Dqio@J)=;%w|oF5/ $,zSO-t0#?Cjdv P%^'+KL;.-CZ	&R\b^b	|%{2bdf9 wsRuz
J`kyXIdu8C]U0rc:qI,Oix)W Of"*h
Fk9r&Z1CVA ?G\ T?g!r?~q
p8RHg+56r'V2X2c'T4qg 9W.=zdD@{7o% WS6Q"[*67pa<+	|st_m~^ M!(hJCy.qbK6D+&C |TVb.y|!5geN}w)Qvf4uO? 5XkGkP"^hIXnK>"pW\J\9bngBbK]My/u#*&)OcKQ6BVO|kWEp<8-o#-AS,[7(iwAVA-|PMbN%*;
|48pTYyK_=]d=S2h!d\'Mq)u^jnXA(o,b -2RfY^}@|5_P?bn{)0mgrbNUX?CB>G}o)2v4+i#eAgKSV7(
wlaArBh,^sSy:C_G)GJ@='8k/	kDJ|T|r	RCcX'4uIGAj[y~_~~1)7B0v(t	HlgAwpL9^O"KQ)Jv`#hN_~&ryA+{C2r#_{55e.Xb 
>~?DoMEput7;[ Y+Q.P%E1Bcgg.h8^w[OE,}pl}ZfZ;R?8^n|
}`f1Ooe?44^'7C|P^Vg@|\O:.+-	1}vn}_l.k_@35`p  kCbXza+n(Xi-n<E#P 4BY7}uH	cM	r 
GQx^JQ< -~,< cn/g|osPP,XL.Xg;
fAC'\@;o}t[G -	{Q7hk	C:Z4%j u9saIZJQaAh>EVlQP6A7%J	R:kl~zk1,SIJ4O-^_& \D8[`?In2[/,e{q~aRp#: K"Si/oV[9JzM'tb:~ PT/+ D)Ub%Z\m\0;.h<2T6
kV)YPpjFic3_jk,n  )GMlT+ZCv[_ Vt'`r^``2G,I~s/-H_C9F~m
]8+-W"J);c8e=)Vo;*(B1[\`3ru06/K;(D&2K i#'R~X1]8p KAd`UjI]Dr $05'*\4V{:4L1%+TaSK$j;e\3*`	_/Yy$@"N>>*`8kJ-<)|x5
pq-<=|/k@Nh&g1XDj*K' q6V@?uSq+h"w[W$
#.?vb}qg'1RJ	k$bNTwIKw|xr5.AR\{,/N+F96~x+:\SWgbd~e17 7[n$BL_XS|4t>CU~
.C_f*b~&V6P]F7=lrW[26~.&O^\rm @ML)I'5Se|0O>vS2F(drteLZ@IDq)W=34V8<1	#S#T4*qaz_(:)]_U<[pOO-@MUZyk*lnOAYF+[>P/R_/.7lXC)*[?^y}bxE>ZPW\hN2IS%=w72 lyL0.Y}>j.*w P8],o7r|UBLM"Zd*[U/T+3xN_yb8O;dMtJAvU=/oR.',T}*B	uFSF|h7 KVP}#S.dU16q(@@stMM5F}**lj9#:rc2%:.t]`s^o;xR}/{l]MOjB5c<}kp	J{1Dbd/tap/\;P{{Zy%M $8	cDp9dvtdg;/k@%YOkM=h"d@(j/-r:,D_.e\7W1y2a^b(H?]-l9yr5LUx<P|W2vE6W(v_V^A#JI`W
F;Zze8&k\okUQFXuQn[cnwqjd&,ibv0Us[BU~UZ@.D?v'I]&wqEVX #<*-.,2}3sP&*fY]x#Irx	BWUf5-Ua^H.\0	3 rua[}oPNFqs51T8~
kv<8'UoJ;iEo_!5>W+$w}<"i	M54PRnTb#ZE-6_S5_9L+.Pkx^P`sX57jT|{J'>]8TdDA%_#9s=EsGu{Yty7"=.Qv?I-&1}9^)hx+IgBurRztoxa>
@ n
,u+mZ,.0^bF>?kp?,dl\ ?Wy*aN_Fq%$EI~
D_6SY|9=DQ%~q@f~={Z,^P+-v,c`R %vIYB#Gs@@Ig-'eGanxfsMDpFOk=Uo_@L.Ava]Wa2xffUo1j{	wK*-
^*zKkOjNrVtJ8qJNbi_0k+q%Z(i'mM?RBC}|E*k&=^x,9u4jC`&L
_kqkrvHqi[nO,~U02+29eEygBi[sn38|V;I ZuY\D8X6?r:n@/>x$[#3Q@(7Z=te6j7:{%U0,2 4XyFXTn 08pLu>4F.bkfaKfLgb}#WM7d8 _l/'^=X~@S@ZDp~S]j(S-ia4f>.!]P0,&0]C]Tx5P'qE%v)9oZ _~:ha&{E^z<o'>y kN \F3TPi.[:K$SS;]|^;g>3KKL,f&xPF.t$A6`:s3UbThw .^B wzE6_ !Z79HZdI"xw-i`5de/ac]mp@Eh'B?<Yvh<0<ODX"~hHR)J?Qf aBUq+/o/O'Am f+XrtBju? ]wZvLNy-LV#82	kCa0=~NV?k,ack<}f6fK?[e>MGBAIN1=??~x<.jZ;1@bW4D,pAzrw(5qeO&o&n!q jY/
fDECJc
0zP]L$vM5A~ePP"+&?ArfC<RQz.a)`H*9lZP!F"wzBs>pzIoLe@-,2k%:U+^3uD<^{%XV]K,d"s)If}}xoZH)$RZ1_q]P5v^_8TFmEkvuz9'eUD cs~\}CfZ[Jh( xn/jt/xJ?~n5QwNab4V8$Ml*?z`W(k
} >->75zNK(mh1ce'Y8d(Z1`D'OZ	6`9x8p9Xa&2f_nl7-+f8ol+4S

B:-pxjd(6PA))n KX.6$
|ILn){	
EBF!/R49vA:b_f[$LB4)Xc%R)E>:4V}o/_D3wRu0C	tw[51R>^^	s
z~4A)~]/D`)m_G^)X\$  KdUbX+^xf#|.hQ}e3rnD,c&4HlWpE-D(.0'v;0](6ZJK6A5G;^=B>VjlD8\'x7 %m]5IIN?<wv `l4Y@]C
C.Z6kJ)`X%jJ%6[o ~yrgz*r[zaw ]T1Sn&0t8A4%K@TI_3:doBxn/Rl}EH%h"jx6G<iNn_`!
[&~P`h>0oD[{TOVE4TDJlYb nv{9WC 5|V\D^o%QA*^SfPKcNI;S w&SbR8N^Ar6v\U=?&lBieR0YMIKk-	~K0d1"TN{}CZ0Hn~cWtC|P1 r|^TFLL :
m}dvfq(d\Nbi`qUX
M?i;j/khOP00fJu?JA&b_ }gI"hq*nF/gkMBm	=]"(1+.W/~c*b{`()g\@ @bR}m-iA@*)AMBxDZ6\
r0>_e}Kwib'A.%Ns#K7=~/5J!oIgi{f# oxw9 eufYD7f/wfs#Kz\L6S0V% z!36$]5Z7IZ`:2$:i?|o?0b?BH`QZ|%. nGbwV8	Da~z1% 0=}K`U[P9_:I>HkmO"y{@B?*=G-|sj@Qq/pba-e5cs5.W%l<r_1  SEud> -TrU Hrv)_Xwa?DiWHromau._G7L1}T)	0^0\	$eB}1}O52 ON`wP!=db!\sY)	gl(9PAhAF)[;07I'[mQNz,\;Nl	WOYnV d}Ru}} t[%%}+2k3s:'B0/uKGP4~=<|KR*Xz<dl>=(?&pMEuwz\RV$HW.\gW	eg[;
jYfl.k[r"bH,a1gVUS5JaYqm&Ui2'<# ^-J_+ fWy
{
s^4X1Fp;5emN!7[s8
[%tqV_f*URHf=x5L[o|Y0Si'"C:j%2<'oa)gKs 9)+fD!}Zu SgPET y@	x@Q{&AM2o	1w{4%{^Grq)A }%Rm<~#g5v!;c~_(l-Ze@6B{~yEeXMR2vHzMxh:d7~Y{`,6@0a^()-,AZKH!6mNyM
&HX-&"X#-DZ8_:oM%Li)Z5!&"0aarf9aLzlGc3NS0$% 2m.@beA:lWK%(NX~H\}*0Ahg.@;'{3BMq1R#O1c!LuHil{A>mWr?9f%)> UHC_~ruOChxOYq/1Jh N;M6m9m=Z+
CK~!h x$i :N~ZI}+ 0yv v*4>%e3s U~|c?*Hp$ 4$[=gXd57m'c'-]&uW3T]/2{PMN$I^z4[7Y qLVD-od=~#]@GF5&$~\ Ep;Iyw4-Ea3kK&+%Q6qC>Co.sM[iMqE0Rb7odV~V	fm-!a.~J^P}lhf]Kx#mIp?bOe2FO$d&=2..s(7ICf)%}{ao =#8C)hIE_4Ucw) kBijp=![tVb1j+vuT be)p.b1 ;7A*-AA0Ox59_2C(|&!\n$bmBMZ1Q!1ltBBb,wc!'(Xtw7cKQgTbITi9kG${a\uOsuAW|o}+e0 sQl5}HE
oTlVWS2Y$Ag_\HP8,+a)81V <DHVU&=^	;6nB-rx^2ALxsTR:f!N(,=#Y#RgWa@*mCU~. k*[~'[SuVTamQ,w/Q0P5<"s\m*Ea;Uw72(.48Hl6f7?@{ohK/_=w9'DZdWCcK%L+&%F`: 3q[,CLugo5V8:A$8oZ"V,h g$16Vb 9e,lzP7\JLIi Se$-bgU.t*/{)(}B;qOSQa08 EpV!g,KY,Ho9ph!oq2D?Y^}UMztwI
(.y0`5:p
AK1%j(#4[
r:j<A;F o"bAuM/z"$CXt`iUFq*J2;x-pw7\A	`$]WR%-#&zHjXHqPc y0r56qF./#kz:{*/q3xT__oP?<xX%[qb6nr)<16Gq+"0k[m<SA	Pi`=_f;_9yGh[zT7HA+%Yl	AcA,NLy|uI[gVw93A]ao ;tK?=9g}J@ twj\1/'7z=vc@oA:nt[I{|c\Un	10~-[X)$+M#`~G\?XL{IKt	6V'|lBE?g)a=x
u:sDxUNWB KAa!O"{(z*jkixP=yjk4RfC &7tSjJj`k`g9G( )XM\EePp:I_wd{cDeVH I{Di?V_5/F R4V5NAp"'Cx.]1!Ul?Jhcy6:{:iDg: ,QwOev7W*&3Q\`MBv&QH=y-[-<qz*]

~Z/WAF{lN&m%D!5asT#	#+ySD#j5']XG1P@rnnPEBM3Lz~VlxE=S c?<~y31	U-W0OFk7HHv}q~B)dcd):|tFg=FA~~GMFa |KM9,y5eA>O
8<<f>A?%Un1wT;2-VTlfK:3[W_*S0l7REUe:?Cy%/JbYmxFN5b	g|_mX^J. !_ f#7Gh1_tEgcU 3	As{iF% g1FnOV0@/}/v-	);Q}H	3]XX>V
F*>/Ry_['.{8HuAy1 @lDwYuP/!${{?Yx+sT;ww'tVO%!p=FqZgLks+bp{ZIGqUEARH{QYe]O>9ymHugb1pN"oz]eI!"7ysEgCOH-j&bkV(1m:R>zAV+}3:R)	A\m5{-f 'VySIV7QD9r?/*eRPYoRy =L$zv4	Ytu4Tgg[@$z_>C`b7~p&&bQWxcc/Jg<~XtMGpiqfk%, @bUu@[tx/TFh.*fxS9!>3$/LN +MXUsy;c[0|]L(+lW/o0w59N{7""_~?ddZ"GB@J,7yaF#{Fz4IwLsJ'f"<JZDQ\Lj/dS:WK7&T qJn
& {b`7B6\q:-<y?Inlhi'scp;]	5>~4x,
Wy	6\ 1AOV5cYW[=DtMxb.prf,0[w]])|:K6*~JvW?n+<{r/5"Gd-  t0N=fzz-c+Q1k`.[<f{k4& )[3Tz},pS!U\k2 
K(vqwUH/g\X>o sJKN&w`N@X\fF$
pwT+pBO_/E(vCw/$^VoEt8$}.g1!=M/<o*ACV?SV~[=j7@v|M@|sqj+@J1FWJ.1DUXx_c+OV4XmC8O|JGn8$jq3<Ps!}is^U8:&]`]#~_n
PPS3od,?b#F$+mZ5l,ap4?HUY-*&-9L4}9E|9p0G5fTDx,#t$r6mAKR5P{xO/]y8FXv~$vT@IaKQ-o{_KO$G(4XDx#JV~%/S%r36y:wq*X2FvB;f Z)+EgkM8E X>Wol3zEYJ&wr ~~x3#0oCpG|o#kA~Z\[BwB,9Ij!v:B&-\!N+ wW.A=RAVBIzl5+g?8W*T/ruEo1.q'O&>|zZPF&
bb%cmsN^b~sLq	Ipg#rN3c>~AJ9Q,cU]DMv<H?2&hu}.0[]{#ZipG{{(gD[`v_ |VDS|gW_&ya#%}[3w-bn	'YLT-KB
\L`zN92T0(KP3	S<+9aepB~8*-3>\7	8__a]e6T~cxp4pI~5Z-GChV4l5
U7T5/% 5.:8A<io}X~`
JwJHm`1T
*zw~<4=jXgTNZW(ZWOV@cD>Gkhl@^91L{2A%YkBLrIUNaQL8:BNiGf1PeMH MB;P.?Q,s2y&M5bRp.7,v&'rkC_ef%wh(vtlrFm}^cb)~jt^	3V	/ Xptx?(}l6)XtW07}c={N]DQv 2-wD^n,Aw%K$)2{[ Ri"2*4KO<vCjp,f&rTs;_pPe`ic!:vU!;S2_oat>bWz/[HGCkMC$E&mqO3N5UPKsD^Z8$6W13gY>1D`+/R1S"l4w`KiREw_D1j$U"D_!2L-B~oW
6=3@
jzsHqmwew tfagz hh
j+>g\nC[Sv&;VcE c@.U3'*-0!?;<s(/bT~D.9j &CuK$QCt(2O||Bu,|Dm v:>:X(x	OWs%]0	 36+9!&'gjQrt ycre,mSu,_|haJb{XA sB"wWM	 -(-EvgX<a.Q\>G*CE.!pnJYfBKYruA@Jf\}rS/U.	1',,p~:e}M&:X D]LOG:-0 ;&36L:dg|3'u],=7]Rhb)mL(B3-*wDR@*
_:{zAl?.J3&Jp\n@:I>tRLd  cF#,#yYvz@v2TyXyExjk:e|:=iTQa L+6+WUO]XnL`/6<ia9p"N{h>lgf9+D`&'n(fe c+s7f|o@@~|FuXRD@m~S?(pIA?%oz>ev\yAkH=,^MT',(gyjc@th4$X "sqJyo1F/Wna~n6t?$bjd C\H9B!F<D#dD(diOISS~T>LW6N)GNf-$5dSv~O==^] O!+cXk@s!JXmK 7yj}0T ^[eSQ ~WsR5^,@u;Q-Zvhm$b]"s4#R(+hn?v"s4e%,;;w+|M&J
`A!fY}%;uxepF;S
T]y%Ls f[%~f1n?zhInsUV6@4>VXxS|Av	 'y^J5~
u ]
N&CwG0:-f?(JRO{R.<]b\MY07F:
Ta8e #)~qjhr<3
;:=rf  .Xuv2hrL|r{[0`,bDn5j;&APpICA[B]	wUy%f/A):sRODFVjl!c}sEa>_PEJrs
MHWxV1lEv /t6qyA<FTZj"B`(wJ]g iCj5J]$fL8{FZoo )[l$:o`kX#P[5N %\fuisRoLo~jh~J*kO KBG]TcL:!r|70Qr`9pk,Rny8>dil?\*STfAY3BDCxr	O`Fv!'@,RsKIrLccPR[47t,c+(1$ybXL?3}lm&SE*p!W'CygjO$She?G.[%8>	5~!)/V
4cM$BecpW-{6YbL<H^=~U-Z`> j|Jt[
m/v(yX	6j32K(>0LKm3&<kV;@
Mky}aG;[8 yzF^K$?*X+y7miq;ja:Z <.v<uC)LZg]Kbx*2)rpePMlo#k[-/zXp94Nfoj/'
&?^Nf@)Nv|0|t}v2	Z@!3{keUY:>X{
|#l8>9M0*Hx?)sy:+hwSe 8e7Q+fHRe0`KHx9V}!K{,G Uk=`9@,+	>,,*g
|als-o07Bn.M?G6+Wv' R{^^ xV/SaWpfH&Q)^t7cqi87L8'<A
Eh 0Zz.Fd-/PL8D
-I	(xyx?Q?}!@[gpx@zvg[sYxyr0kc>)6~_sy*ftA~<BUR7$_iy Tdyp&p{HMOG	t8!~{Jk"?l$szNM}~FgxaS1^qg
,5JL)@W1<sp01J>eRwL]}|{e_kaNU&;"v0S	b:]g  \G}qQJk-uT04WOw<4n$etdB /]J9}[xzhydoFL^cGyC+KfF8AM1Q 8&DL9\$}))M!/^h}Pd*iCIopd5l|ovtjh!d3\g	?azgH5.H*>rU x!twOj8AEQVsol3T\5Z*+9=&"UKSqe:ZVq68B5A`s}0/R S07OANY$  0e,/vi(o) i$<wI #:[6h/u\`oacns`n/.Dyf~}Cqv6;Y0yh_4#_;a
iVg3]~ CYjF|LEK@El^XteQpMK_= kU~+:K;guA3j2p.Ky-2`[0q@MEaML/cR3
< $F`fIrIX"lCK@mS)h([+<<a7&.1:7Eth%r -|#LQj*&ux+HMX-#wP$%evj[SAS-_s0G=7H"=E
.Vq)yvq=W))(kgdl7@E/XG?&xle{JN|zD^I=oWPv#
&]HkIv+GaGM.nQf1?e/nR#9Rp6*D
YsTZ>LJ?E
@j%"	:WpX% 8&	[U?Q M/a;;Sv>N_Mn(%]a,^G	y,S saFp}~)iG]*8b]swi]RS3G.k-I9!_ji$1m|<IriT<CYUEGI&aKI};7g+fAPM~ou "{}y`d%A	GxCe+jdDv7xb,4;x
*x.sbQca<^@'h3i qmHk2Dy]W;/o3Jr9{9)cxrAb-iFW~~f
1%kF^)0Ax3nM6dN*IlIf//_4PmghpJv%S"
Zz|3mlW"082.O\
G&^\_>)c>,H,BVIIm`<=U%DoS@3`*kN<9ODO\`Yh_^$4(s~-Ha_ +[OU+9^zW$bcv
gy 85Vm y!<$O&!RM-s:H=bf!XI!yS7\2-?G+9=2w^. ZFX~
<^;5>#)n*znVnA"V1u u_0 T,(,&)fi Eo
G}LhuW(=8]$\*uN,;~m;WUDL53M;Uo7oy0>agy!sg8Ku*mCw$_{Z_v	[[zcLHe&N@rpsXsKvoDp GCXKC< F-tH)~m~spzc/pHM<#Y@_R&agwy=NFc &yt50.^	koHlu<bt2u,Wa3=G?TVWEX0"L%%B:KNUW =g$RNrnxu-gPXxM,&g	@VVu2qi8'sw'W ]pzN0!41}mn/-Q]_C[zLO7l)) ^%Xqz2<0d//[#(%}HDAk.z7N<'fa"+XR$3 ix4}+cN ]ZT=qt^@J\?fU1Po|h_ffHy-Sa	ycI8y][i6^POfRP"UIH0:Lss<w-wZ5/)-
v31Ur<}%0#7gLD|0~%0# 25.X="TXZUfe3"A"f\Rd~?f~]}?[m:]/.}?6Qf(yjc${]=v?AG1NQ~_$sZ1E(
G Z|;?PF]`=;>ux	-yW\`mGr%(xwI9u"qX2X7QSA}mn4yuzM\\]-u/jd1EGdzUTQfgP;uUB.VTUeSVpEGVq*WYh'~zI6nj&oC@U0CD#12$fHp8k#X>tI)-%Ht	(% !H#R]"%H7tss\|=s3;K$h^>_y+6&@7e9Z3r\u~{pd3fo0?>WXqW~W4:?XOv4`SZv4I+Vs@Vgv<M!l> U?INz+Cq4;SaV,\*q'gJli,xSr+E?`$?CIw;19'Tq BU~S	v
cBT3y'U~)8r[^P;XB_EBbwr,~jUA~{:%[(XB@pTqv"*]m^k>0\&A~Co*{`n{L3>8j>gy@*YP+Wz:M!v#=D6gQ'i]<[~B5`p7gg
W):\E;3
3v=k<AGF%zNY$J\B1j+Or2"rA1a9jQ[A=	#)xFq5I6JQDz%9>K[;7ObV#?$LxfsKJ@	3a<x;b4/S
!? &Mt7n[ m?
yd^YtF+	{";&g|>;vZ~EvLl|wtKwIQ lhhcRxr60MD1sr^Y} ~;8VU,{+!
|pq|LC%(fv#<Vx+LU#GPD l/ ~zRY|h=RM3qo7@*2DeQq[btI'I*s=B_l5yp:s ^\BSb96]@
iliw`&t8P\vS7T;^ +]m>R^~lGGv]+fV{dhmgt/D$z'-SHQ!;<xclt%z~M:KQ=]^8|"hE';:S@@PA2WnOo!FRw*Px<b(6x=0)+r5~ E1O&"|102SEn["eeoOGVE06P(&[{'-ev; RsR 6drEZ6Rl`C_MeURQ)sZlNoe%R]y3:bDf.#IfSF'_X)p0ZqG;\fs8T2y$.S.pU9,a|+Km^cLlT_/u`aIsO
A']\ifz+- 'R/le=g8NBe89w+96pr}]n'^	-7Jo`z(yhy<ZGk+?k<4 vnk'\nROTZ^/K$mWyB\}<V.{	N9"fo:8!9"}FuNK3[/vq.+]!;
r\?E'a@/~_rP%`p6X5A
^M%q#aI=pz FZ81GL1.X-jR6\4VJyBw	ctK;R-yQK^K J19231rGVD2NBE:#bij=xa;'[f'm]P*4@O]-3{#efX?nx\3-jWGH+<oLzDjk7-[y*!%u6u1;*X[Hb}-`t'<||ua7!*-6jVE2s9lk=26l22U,c	J'ZKGCg\G"?F=BCe{maKm13|hVa6qy;m]Uco1j!W&Q	Gen~K7@_s!-pyt({}yJctj&64%OA#OkrR+ K6lb2~Lj9?+5:2y>c
Fh%sLbeY8]8;P*E<wr(C,cFRt> p}TP}]3)3;JD`]rut HB)@=t<~+K[ua.*\;kh	:'}>(FdY7h3VWU!_:H'9lO1HNh"?e0y*Sz~'|&LI)ng.&CN3"9vE4e:P{lP |zH89;~( @C5>w_2|@* ~nHtOui	lw'IM!0q^]N-1JU}DW&@CI!~?.c[Ws42>}v]PA7J`x	Z,Ik1F7WI;,7;?|DYI4X'mhMiKO~<AW=* Cj`gMW*OMd`q",b2Q]/x0>O{zJ6:UAjGh\?Hw3?Wc9+Pi{j8IPo^xUk.jRu>l%MoOrb4RFao	/ !Vw9RSOLH~~6v1r-X)en4.>I7{o!iZY}gSY.C}2Al{&w]?<K4Ei,.5"du,OjD!e pB$[	2f?lcOHc=*%Y+x:>An?g"&zfiN=iEy4=q{	'h47rJvI{SS}`( 'cfs:jUDay@qfW->[8yI*f/*/Vt}:QD\GD9#[HKpP=6Ls)Oa)Cl+;=A~d2P)c\{5pwfV'q?L^18$]a~{o`y`l:I$;FTWz*q'RsMSX:8HMCODK@I}RD&I5\@vY\ +v{U9=kF c6gsN)Z]^]|J5bS0K	dliL=Zqnp25b~dy`jbXLE( !~&`<S7xV)<m>GFza5vRi|{>}IK3P'vTQw/dWA.J<']t!a/FO.)uF-LdCokD@ 8O2Kd2kf\V"e]&ztvTc1)gbz^2A4PNo=m[C4%@} =d(:-W?enH!~''qH=:|O#|*qR)>W%A
E&KG562kO~_Nz[="9_d;iD{lpzSN-={ybhX8h.ku 8j/P)9mc^]8uv|~8r\.ift1N=bJF99]V~p,;$F|t6|_I.I4V.7j	}>&cmTI[.l>%&9#1rt(3n86i-K*AunreKxyZ!3h#k]`C?a"iM.=-qKm*;oXo[n:; H9/3N,n(8T9~R4|tcgogs+vEWd9$B}'7=?znor	'I`X_~`UVU0:/eSC`O,q=H0~$VrFp*h\@=JC:9yvF~w!iJgfazHaF'E\Y-hg\nzIh0>.vFWFDDR	7Jx=Q,A,%d+`^gBF+(a1^?j@V&57%D]^?c[
>),W] R=i\vtq\Q19==mG2^}
')&nFL}n=up:/z7GJTG021/I*^z@!n?zm"xbmB,>fN/hd!VeKb3K=ZP>DCO_ES=}Au u&zpP73{Uw.&]hd"gru&Rm,Ham):r7)g]I:/#xs!]3,jHTt&yQTT9@gn0K"T/>5Sm/G	s@&O%0x2H\x<!afT_2#dA-l.	"y5	IUN<H(sT=\D7-nK*+_s1bI%9+rQImmW)yS_rs_YgRk/y9*9&npNS=-(FaK8m;=/}2< Y2Yh.)qKU	0&oy05[2:3%s@Gn:L~C8z:Q"(y_|4q_]Ry)w7El8gN9gm4oMp4%*Ttj2Z VG,pzl<	|;WTXcDIM'zyNLy" xa@V$AMOXA@, Br#pyk=+{bbFv'gK.<m1nJyB_+UAj9AX.fO|Z8xE=IF_uC(H'F?V)f;wuZl/'m4Z~sT9?Pz]<o$y?yYxb`v"C/1oi'8u{U~:ul'kA\EUE/r"Q)k!},qea2GJiy:=Lfok\RY{<f8AV^X,D)hd]U^9-U	:iMs/mU@V
75u-qN|K4LT'2xkMEom/AqYMxL?`^z~!4bMIhD4/TKchSq9el:?]\{Lv^(Sv[9+G[+PcV(g1_?um~k^Ob/tJajO$T?<G/,QrFi z3(*pTz3T4J !4JP\U;F)>q O&4lO`;s5g GV\)GGiY_$4hlC+j '&
A,Z#vP[
DK|Y7? VVaaK{MxG*7F8r^[=F6/nL[
we*Yw#l
n	m]9/!Goo:7M>Bmw_LpHc f $M5KP:2 BB2pEX</yK%5#^(xW.>E8.*ZD$B=	O@V*B2'"$D/In>i<Q11@7F;ye,+boRT/
1-8e[)T?}\[`./uSCz%~/Cf+{ouUeT()Xfg;YR63d`[szk<k7}_vw;u4 &EGu#qL-OuJMTaH&#IH7-vY(]{7t"
i8.QXZY)*ocT&t 4;5sM<R.Dm%8#?sNV)j\C}x=6H>2*82lfM%3AnN 5O`X{eCO/N:B;{d	Ag9(|'|#lT_3}I;en~/5M]I1ijyn7Y/"c$8*_(^:Ale+O#q&C}R]ZZ[!P4&?^FTweU@AJq.Plk?zMgip  m~JB''0bD>ny;~^w#5QY.EhZQS/<6.6YG7-:Wo
^zY{{_cG//TT6/iZ%sx@v{F_C _+L'7`V,;t~LI~'DhQa(Uw)5IYF5yaem*rPioD`7e3}?<n(Rt]#VQ mz%ghIS9lam Q"co|Lrb8Z!*NV[3(lOtQYn08zAq8XrriLqMtr"r-:/mtUcu7u}uX*^4}}8"pw_&5xV#q|Pbq4u60'x0X$[=d7m'F(X.{M1Cb|uo$Cx;7jGew|<,`3Q5l`JR>3Zsyu){/B%,xk`m^'twMFt6Z_xPJO;Ljw
8sw_b&Og{;@<O{ih/[-7MT/&~Ub{^f1Y(W{p8;ttE8LlmR:XE1.MEpIo5;.1P0L!~IH pVw/'z38}:--]%NF:-1&xf$\]?DL{8k	ad8VtY"
+9hu5_mgp_cCTOS^fi![j?4#*D5Ty5+EQLco&J7ZT%3O7]LE9ovOq~+-uo7v$BnX>=m*5>;\@Bn?!"m$YHB0)MGI`sf D[.rS<^|0Ww*`C)HNZ!4xFYbq7JX4=x(pQyg8sUWlI/4q$2y8Hen!o 4cx+w6Eml/(u]uS8>}|'r-WxZ\NkJN}IrxS-/uq*<,J?3=ahYXg Dy@Ma8*n[/HFzHMF$=	uCeedhfxY$jv-x.gY6fEJpf$Uo&i)5^DcMA9ZWXp*},<(PWBtEWx<-?s<'Qo2&yRG8n4#~/xR	&Cvz*7\'u<jfp&"Bq#?G!hAT<1$;~|sm&nvvbfsA_/;,?j8SQ,S{,RRA@g$T1$vAVp&ZI;f|H9b#`Z#8{V0cTDx8?P%skT<cUN~b9w1\W_ZGyj! Ka)$V*3$
3Nb~|+UYLd7??I
$b	d#!\ir3=''Vg9Blg}ptOQ3UkYv-Ly8#&eJ8[O<^r"'xgS=U\QecsXl%ovH l-WSp.UGI<8< gdt^2ZOdmK/gp7JlAO&_yN=]HOji/5	g?%<Aq%A$.O#%,"Itdx/?!

{;'i}@<y<nFhE(\.VdH{t<$W }41u<.Dw71v7	X,Y 0	a&gpFQI`1PiNIl&b2{6-Qr\L{H4c|6 3qO_DEr,4_+jJ 19{.X#*,*mat:&{{HdqLr?f4>$\&%kaN W!6-Cbq
ok8# HtwG &MgT0>R_H*jK;Sz$R`C"4MM CR1+^xuBg9o0_lzFC^R-DH2/
KSBl_|31zzv|d6
(#C,-$Oy%()MG_?th8&gi:1,8baBc4X})bgba2LM	_&Z?=#3U?c4obaE9!6w*{?Fdlj\M_iE~3ew<HR`RcyzPC][ ?C+Uzgr|{yX&=mPq0n0T&bF(to{8yeMg#lbSK~f.4b6;)8 *GQkeC327~BmFW}WF 8	BF+vb_+<nxu%F1qXXJX>_GE,Q+.NFU!!{NB@q&^!50wHqjMFFUxI^wUzr]Qdl=hndN0"v_BrA<YSK1,$_W1<-P aU/Lhkxto n)u*dNpr_Mc5m{CvX Y1pfH^3f8 ZvRw}	ZU-tYJGG-<*f,8%UPK]0of7ye6g))HDEYo5u=+^z|^WEoU:0|,n7MIyl
X[CJR8o*|[izU	aS~J+1e]pd3%4UXm^Sbm W+*?L86o-!LXOL+J+;E:gAZ.Zm)QVH35M2('ZU~mEd?GU\zQo=`afZQb j^p]	#\x@lcZuWcd^Z4^e6hG6>Gg@n`2%JbV~?#"mYv\kK`*7#Hy5?G,\+I}6gUKGv9+*/~ _9TzOBi_y[Dwm^UkN41s4
_:,	mL'RTxTb[7!"J;E*0H'm%]7)q3oES_,Qn|Wm
%y#q_zK	w9hh:9j5;R@|\^'qyS>Dh|.XmS*]ZQ/*tI$9:Qm* CV\#k:a[p0A"MCQW?w j9aJQo5	9"R\A~*0t\",_/6CzS"pEL'eOw	@:6]PE PM`9:!l[lk7o'giY7+~Yu F0bC>p,hN5!,\E]hY%
l\a#sX=pf&tsft8Ht:~ bYFO~:jhz]X4<e~d\<9WJClDU	1|vE=P
:i!&-QJV_/k\Pf	tK#``9I~*NK&NIWc3X	LuIFgW>Vh~M!}ci`g{[q,z">o%yj}sfhN	(Q$F+[g~B6Duw)Kk9:;=tu|WfxV=SUtS<|*%;yI+vs".$s"X>OE]Fhp`t:/6W_^vb*3<bg uI+A#,u5+?(6)ZM_G8![hRC_Lv|yxskw)|g1$XwKs=eD;U})^Qo;jWBNOIBu^qGU`mV^pGU!hi~{w7G{WqAX}LS 6\zdM#?e,>7^miXEG'`=_^sNOt_]s]5`YmztW$}
ssmO?x[7}7pjFJ$D*O-45R'W*Zs~!*W.SxO g\{&?L{]M]Sk1KbWc59s:ujsu2inncG_U+C`zW!,;wv	A[XX
>`L>=U	Z`2"k*>~Q>fV7MXeMuUAfv5Y"27l]S\jx_u
gIW#CsF'tEPf'=Om	D2!Ul/DIb=lu#O$SV4Mi(w$0`@j~&G4%85E&0Dp2-##n#C'y l|`mnVr+T_BL'DQ>j\Gp%MM@E<#Bkk%e:;~>OPOs"y<^EGEsslF`=6M>?,9,F,{w]]KfV<6 V ~<( bn -N]ae~\J8_P}z0rqa\!	|*P}(BAul.GDhpgW a(ouMfZrR^&,|O03eagV,7W k?xpT(w"OlV)x|s]%67AJW3|Du0t"~vDko+iK]U;<fubf)uT[
|i:)h++_]K8~'/1g4#"E.dT0]'Ibf
2W_nyrE$^=Wv<FjjwK74#,`1%{~h>yEmp?qUK\km.14WnJ5dz?>uG9%bLbr6*th_!Io {D!6v0!`m_GB,$cGKvpu#'vzKPv<=iZ."UF#;E^nX&OkaL`|g#SyS9K#R~IZ(dv@NKb'0lB=#aqN#[e>:^r|erY|.wS`3t(_5g^1oML.S47zc{*'xOI/<]B& j?V06^JYNXQU[YXAQXCGG|ogO-KnBb@H#OuYJW"b>DHad_\@\ /dH"G @k@qjTH ds kT*oS
%C7@x|:b'Cn@HKeve9?tH`0 A@w4@[ q+3P-YX&".6$qbC?RQ@*uTPv(HH6}qq j. BU?34 F|p5'@~C0_e RD+D
!>@T\ I4!"F #U! {%4bDs ~Y	l:$Y_%Z#MeZ$R("
~dXeyD92vX:^-&%$p$",J S{%rCx9%,7"	 vX2 *~@h8`v|WjHD5PCLh@QM Q:-h_jDf& TCbhQbL`G!CH,f@qnQ(DM(I+$Lv	@hf=J :4fcB/gZK*#+UD	6y{3^Ah~6g6_@A|Q
uEPD 4S $_t@6(^A
e d`
2Q
!j %D/D BSO{/" k4E 
AP51c@L.k{a!0d	A9  b 	]K$H - B	Z >= ;Rk)1H>,U J;NB.1RDIywA&	gEd/5!$A/" @b4j?Y(CY"O <$"  % hp @~b$_~_,M i/ vVCB>rCF	SW"lq)Dl">*7a|QRJPPJs@rHT"R5@\v a0?	{`B@dM0K	@J,3Z-72-!~*+Y	1V`]rp *@ItO}]<a(ZT-DpB?6vQPj.q} 8 !6%vZuGt@Or@|boX>$5l!@Pl>6m#=cH*JCt	$Km(=b* M!S V-u QD8;9$z,E(1,`F@8}%$PZM(WJeu:+&hz~ _[@XXC"29A6:kVE6j&l T" RBq^q_s"+@A E-=0.TE?:{FZAB@$E:I.QnV$;{g^Y}r gNx<W	hrQG
zT'hO 0p CctrQ; UW \go!m}K
/$LR'HW47^-*Pw_xsGiK|j' <ypzF>  {x^y#E}T/ u7}a<r_EL!-| BQ0TXa1 @Qm k 1_X ?AH@  |k`_HvIb"@?W)0R E;	Q 
G4@]D8~zp?>D@37/gmZ2QW)C@?+K Lx0_ >SEA\r@< K S xW[ nupv1Bw<t BX. ^  >JF,MDT-/o#`#@o|?9f<\h^IDX3\ U [ z K < sIp$oT	ZrY (m`q=GL#- .H`?+0[z0x ; Ll `on A6ixrZe!G<{	W0et|y;Q7$@ZFF26 # r[]pL	[BU@# N+@s,`OC>s ^ GOvWp!iG+qPh-3AK '] [w\Krf@M/s19 yRGx,GS a/ ; $^dz H |)h q^ ;+Uz c`Q	<,FZ>ppX  ^Y_1iQO^_u |oRKcz _,`2z6ed `.K
Qw  HJ2 J^UEV,q)VRYLFbhT!0NXgFZ:jPB	Hbt2 }} O-w0+ ^%!pt 	@c=
5"cu		^7zx0BsvmZ`
"--  -mAC Y9smpCG Q U J}o'Iv0yUV<Fj@?@4^&?8>?!b}; jk}H&?,~h^=Sv<A?3}	E C\p|g<@Mk N{~P	`v^vBZJR|z I B mn$AK<Y@@03  ^&HN-y05NM_PE#V&.(Bvbi08 < 6 + p^0@;-DI2W[
&xfAKy8P*OB; g$n~|s
F (=2bp{pyask|rO Xd,q5Ygp9lp-UrMliI
pN%8#3m	 oQJCOnoGAQn -[@?xM 
YB,O[YBZc8m/#`Osv8+F)'g	 x0sb):{fd(	@^GmIf1|EaF!7Ng 72&"g@%= 9X54 { ?`8b
-;E 9k :Y7 ^i5!}p@h^ashZ<yvHe1 8AR"%d =(6j@ ,-k #0/ ~ k B~!ZR`@ kh=B" AM@YO.:7 {hLYs  k 4P9pkeJc 0;   N; 3o;l{R|	@8z@9pu)@pHp`,PP1,M2DLH$!e\{6^fg0MdhPVUfD0>3[&'dk_gIOj,<>6B1?gk;?FO_i^8]P6zP*>q%i.beNb=ao'[4XY,/V'[pyOo\??;&U}w[)^_(G6&L7P0{-6(PUZ:X~
A>zr@s[iH#/X8r->vi!a5J'eTlO&
Dr
oY-*l_24G308hW9*P|Yl.@)!	e"~U~_"R#1p3z-Fn^w8Irs2~n&s9FbgllV CS(Ijib|_FRyATT##?$,<^=.imy5Sl
zj3Ecy&wt>iO[gB.N+=;^)FsA__s?Ro0hdR4Na3(y_
><5<i(yS{rL`*bn-fr4xyxo3v)=(oV7|00vx+55AEWUAqim#,c^A@f[NL.DJ,&6QTMWur6k~[v]n18GEWtro:~U~eU.jh()8E.[?bW4o,\.[$W-*buO/Dz8~B>dl%gt4ey]4T|>"?dxz;=t&>g(
*VUsfSkF.R3aT;:"8sLDB5O*by+7Cw3 hjg)_HL=zXx0$MaDif}FO\[dW.kex1F(
^lzzM	C}DEN4}}(YjC>F2V_kd2QU}Ta_2+
X~m&T\Q^%`xQ`<>`j,k\'x4Y/x	lq:x2N;[<Sg)AHB.[6Qs0V9 |2fD%Gjf
A4M
[f(g{C`JRJ7?qEmOFnRCB_W
ITwhD\K5wz2?&&7	&I#>0nb^Ut%	wFq5RW"qbKi|,Hs"?a68hF9U:$2u>7)M'*y7Q).=.fYm N3q >iUR]4KrAlBW8c]aV98R0+~m?n	%^.	J?!?d1n8|*sf>,#jl"0+J0OE-:d3'Upf_jjM^rs=Nw/.6ZB%CcA|!ruU;BFT:Jgqk9n/F>j;6P7s#IeGX3W+}N@GKm_3-|`f"ElTq-%JU"t[$Dw=-,q=-WmyeyF?g-S~wPMiR2
_fh_o,SCfQdCQN<&l_#SB)NO;ZH\"'&I](~0j{`EVL5rt=VAM[=i![WuTg&Au7q;w9- n;J%/\w:VKh?[	|#MibQZB'(l,/-5YT,\Kh$KRU[&
tGK<E)E^#1C	U	E[#c)":vPzoIEF4upIswYk}mM=3@(;!/w+W-\1it\Nmml57<+8oNW \o3:0!)]I]4>G=T[@v[V;z>tL7`,~6Z	ZHNvg6|q+t7C:8)E _"/@M'z-RU::^p^T;#gGhn$G"Z%2y"85"[= seKF$>}.x=k)$_$5\2fgzMaRo0_	9z!
;wu 2j|C&S+i3 ('Nr_1Zg+8htSTv!ya 
sJ57}g#q].7imE(tp_kk
zs2BONY>_8VC;++cX=kbk%)o}NS? YeA1T#00)Pe$%C\.d?NC7UHQtN^<77v0~l].bh&<s.g}t4H|+Fh~ko@Py5DvNmR~XnYmeCcMm0.U-/W1Yxru?/%o]pg?Ic+;cn-G?^fkkaGj~q{8U	g1M^!e
!j(`mmp
VM[
._G?/t{b$o0zdB6'?7m@a|N9r6%
kH|w	a3}X5(0J~w1sf}xE84;	E@rMwp7'& ZTrCNq&l-QkKV*\,zu4<WcFu.97_%s,n;_8Dyn)&FKZv[|RtS{>@
OVRPXlzL&b?!SYOv+i>_JB.NEW^m83xA4,qG%MRQU)n/%?fI u 	*0U		K$SM|"u="X/x
%*<@#902R/Z|00c*dpg/6!fn*Rn!:1S=9uIGa|ymaTD0UO|&buJYy:#%R@@P()zpgg|5'0kS1Am(.Je[1{lP{	K+>/Er ~3gNGgX~G!K/p%=WEmL	-FU;$}2+4n,tAyp+sgm%]s<=Nt8'aSVm"w_I9eIT],|?wOVAhG+,>.w{"Qa]C]UvA/KgDL^KBv1GNL<,	L]x;*+b3#~RWB&><R1g9_e+BPH
x>$r(Y^Hk0u[HEi+>HGao8WGuo>7_jlU1X]'[zXfq53Q+^1>C(+vv1_xCz1^w9Y2]aQg'>k7W{i/?,k|RyjjJzuXXo\'ea	X%	O/ip|}h FlI*}m{-}>dQ81d+g6~X	0DMN9jL'	>caxG>pL):i7\Kd,m\@%8|tpuU-y}wNy8	LW?O>wa:\^>@s" Auz;)uqj	a048m_oiY'nt_zSKP	nycII'l:gR+0.~G, /xI&%@[pQ^?p'FQ(WGBD(0tyQ|]6uYH*B+LA<	yT\ak<V=@6AUY^9,c'+B~z8, Fx5|~ABA]db;+^M>dk-3rqqvXf"*+97F~vcX#Nw;BbnY}-Fg` E)WL@530~O|cB,
5D<5{w05){HF_J.a2Gw.&PUIuRp^-";sE%'p)$u=Z%TWd#oH.g5uA<g`Cf"t Z5{iXhT>>|z!] =NwZBc:bQ04c_OD\~Xz+Ev,ao\XuY#]pWu$z_)u=F2 8o1rNU+5.n?t|+pC6pj=7kpRv:\A+~JRR'ftYh8{\j#'4JH|%E7nZ?_3yd"]O[5e4pIu|Gy[/RD"q!G0K6ej{ev W]t&#z`;(Utr@!x&U	6s58u~p<iwK{Y,QAb\.[|
794qi}9>oIy;v"NJ8yWPLMIN;<>a`:M^ZkjQT<Tr.m#eoa@kVq+3?i'X8k}nCK."tkNwzW"a{h= &d!l;pGlq=P'RKEM2'^Dm1qo}k,SK-hlNaqnO6n4yA.p.&{<iW*%d$*2LuHg\K.vI'>Q{zH6T7I5KL`
4ApScsdFPft/^4gDkm8H$fT<_Xgp&&Mk>%wAmVu~3KkY^q{<c[I*  Q4MosK%DSDFQbIC>zd>22~{MpgjE6%>	WDjI2iL$ow+1%"nm*v~&g]EQyNP1PeD_2d}K3"bOrb%_<VNN@29>TrtdK/3'h[G%l sZ>+9=4Oxj<#[^u o%?K{7&Q?sUs)oOx	K>f2XI2**^':QA;(LztamZm!h8u-Hyzy<Qr<LK9Z:v{YIIeGD+6xsxRxbA`*>>.]z@47V6XRv}h*qlL@(/hx`"r`rp;ZppYcmo/L=O:MP!aLStv}UxKDH)z'N8k 3eIwzA,hM7$}3W K_J/TD]q"/rj>-% )DkHq4.	=6C l\'x\|V$kk?=:gu~*o&xia)}YEr^ S\\9nPEJcm87zJ>HGqhKV;ftJ.ELDomq$svKzVn 27TVq5Ce y:<mU_'t`1L C=eV8Vr|u}
+v]t%~qY'C*8X,uvkNc^]hX_
#LL8TQ4zD6tA0;50NVzVw#ep~VBK acg0971w/V	7"" hfmxJ-Go?nmkq99
7fhBHhvL]rhswL]?o;c^D@4jm}.NMOLC{;f(Sm}}E5$Hp3RdO7R7ANLZ}PcGns(kew`<h.$| |N[		8%|H7*w~9ch[z9,vU%]f^f2"HTd(<)*oi}Ix?E@)YrCc\/ &}&ff6O&KQPHdT[SQj
4~3P4)xsOLNJvbec3iIaQ?dtp
ZON(~Mrr>nAI8Vq7l,]5 ZX;+C4<M6a9H
xQG;59wv50v'u9c#d4o a;GQ>7~NMLRZe]O,5$ReEA6sp'^p1Ym3WhBQt"'wkEFm7N"<PaQyk=n2x&*&HnSYE	Ig|Z.h)\KKl<CO_9HXhf'EqJ<N<w#6=1r!J-/WaK:w+wlq?jQLOj\aalmA	|S-O*[ot&_CTLF46/^|FsSz8vDsb7@@:fwo/Vh%
^	._gSXxa_T=bk'G2nXo;UZ8zoZ-p8@=%>K2Hy6gR
1}$<3cgb*wTA1i_mzRL8r{@6owdii#,7g fvDxVkmJ@2ZC_d]8KP,_oOAY+v\)D7	>h4,qv6HwZhEOQM`w!CRC@Ej/}a'k67r8sFM1CmDV8KV2EKH&rpi^Ra-|f+I	,2vH/^yEO9	Y0CKgR^:HDh8|L~fC^=nVHnDwWB}p75%HQCre8I#	YGWV+E-o4Xek%Ql\~$*"DU{|fVjU (EjuK.xjI$:-b+<lL)"1O>b|AM--iMM Qi^j}74;\NT_w	+iDhPMxh-hyeP(xJ%+|>9x]^m~yln
>dxorwNZ# !?'?D_\,Mo
,OJ3_uQT--2Tf?0=Ts-c,{;QZUb{vp=Hna1X! 	5 8TU-'+IcyGC87v,V$n|6Nk*(;aS&LN	xxO[EC;<9U>HGFc;<b]Tf?1)iu*tdCLs^bsV6|$bfoLA\]I]hkXj I>Ro;CUm_+8m>yG=r.1GE0%O)'/;17Wdfs!#
[LOFsS6m7'X0%o68% WCzC1}G8M%;v &qGv[!Cuq?|LTJaY>'4~2xs[.o*|Ii|88P
Fycvo;%(!{?Pasbgw?8]Y2LZ@W`/Y}G=5p>c_V|h{C(qz/1w?:h-ATkm;Vu?VRM7m>F>nxZ ry@yB@EQ[9A3oVfoe`zs9'!e'a{oTk5oYLp%y999sHI{Ipz>zz+nyq[=X76hw}e]nkHw9\Q5,to-IXmyGM~uO2R[d:D_]g24+x ?'Kw*&/S` gQyV4k3[H$yk4w0$\][yFrs$B2h$;o2-8W	<Am)DZbZ`6Tk8.@s*-_Eh6>S5332J7|>wTR/0J%$"6M:Tww##}vY )[,vqV}.g17%b} blpvw?3`#Xap8.]{94_Sc^nr`^1tgH&VS8QQH}f`,DboNe/JbnRCude~Z0	rMx#df$jNa*T" %SuI6Y/7s+oc6Z9IETwEcNfBEGNH^#|><{e|
s&<DHj'lkY1{I~g$-h<  -B-
Yypr
qG}Y&8| 4d)Fw/aR]q$my>Xb4HRNyHL}ENDn^?U/SW^YC&gHD)|j
#GcnWC[j|0<g.kQk,!'m^l2BmdP5b:L)2m'1!ys2z+6&2l+'	1lWZ{a>SRlwmF*y+:4Zq)G9lW} VT|R)wZ6h\e^.chYES8qUJLi{O)|vS6H&.r~/"[o=?#%eCj!@ /Bh, F(/UPk-v<82J:B)tGxrTh,
25_J?!&J^HgXvIlB5/&f.(TwK30h Zw_Lk`D_}mknwq=b@mo6>R3RZJDlU0Qb
G6kL%X.&eD*c=	XPz0+K]Bv?u?m\b]Rc
{TOIa/VUWS8]qo\Hj=I6;}z^t rdY_<~tkASJeWavX~!:+-	AroyiLM+4r.*\Nu8
B`J}` B@"MW{ACh	(]c&f0,2vf=	8UV$<o?u}]nwbfAqOu_l}XT\u%Y*5C7~96NL##61@_2sV^4guz~/CqgU~_04JDg223,(`pYuV%4!tEj#D7B-n)hm8idLi$jX}kg*I
ohP`hrm	HHW`W$]4} O(8jp&?w9VW-37F~FvYxgh4{5('9qV>Z=KAJB!/|*KF V>0u#T/,,<v!\/]Z\
v	80AM.!+=`aXI7Oo:aR8#U^u1_p'<$mga6 1{`/M>)_JY7L0AF"E4NM0>[	ng2E:1\OnBE,L*0?)}/GpEXr;_"?YLKA (I	$kX_OdfHfxZw(ec%-D,.OFG]yS
G.+ef><?pxo~(N6<5X\Iqo'u}tH7<^GN&((i'+hyr_;f=F0_*6~RDJ|^,|,%NCG=Un>C}0%mUS,-)?+er/zOgi448H/oEd#UJIJfI4.h3R3'Jeu4"G`VM7_&)=m\E)IXLFH5$ayTUS*]2F9_XV*v^O'~@230&T}zGc~dBNJ,l2!PN0uG_p>)%k7g>G1|iK!r@3YY3D6,kO8_tZKxiLa^]!:+q)
zf8pRz}DL@Sk;,uO"mNT!MTM3h{EV9)BS7"Cyxgp	%K/A}uRw9	GJmWxc9kk xr},"syZT|4/6
ttf`J0a>Q'n@yS)9	=52Zlf(~32RTgo~e&^z{9[^<9J{d%-R
F" z&E*=u%SlqdrRad;@h$?Wxx<R+*RgUO|]44%j	w{0-{hx0%'0P~i;gyVM{|M$p}mXnG{(>wU):WHmGK5_k,i{2%OQ-gl5>		T'MMw"A|k"pF+u@eI0d=- MPr'zO+6[3T*xJ*kwoy;^<N4lfiPuHy]	I2s&+}pj(NWgmzABjpD@ah<s\},NX>pz	Qd$eqLo&YCnys2qYh<4'-,Z"*O# Sg8;cQWFZAnSBJACJ@@;S;3{
z`CT-F4[ Z'e&! P]J,b,O*I%OEuzu1)J)gmXzmGF '-6NwJ1Q[*q)3 xM22Iv@,?D*`R%8:IQ;+s.2/5Yyde$BMU+*AT84LH$LO8M"afhbnA28`^IqQ `&Dp3]4-R2~<S_l#InCYAjwx]@<8=/pWV
*n .Mcg<+	}	fw9D~Mfzm!JNE/	k}p6 L&eWWb5o!%B\oHB&'; _ZKPMs>d>)&d,TK`n44d)GTN-!j1>,9"17 !K@/CejpF(Y~0/;0rZ,("TBlf8n~78~qTU1~W<G{y}F-35waH2oLMFm\S*>?FX6k}:_[9cO$tfhSwI*Y1{.V^'o^M@.C	yv/:6<LzIVYxZn|Q}?xiHm, !#~:gC3_% L&432KV?}2[@qD
_P&iH$eQYl%h@XtsEN^Fjm5QRr;
2XOx&hVC@xgj$^
czYR.kh#6{(6m$hVlI8It;sG2DX!:>69 ImtB!F
Q	jdK>5UA3o\	mvEm RZ0eynhsjU;4onU/Z|ULx|!!\/ U|IP9_00T2 t8	W+`.Ac_p9>\D.tI_C#uS
Re.F+Df 4W0cDrrvy"4=v]4z[GP'WAv}DtJZJ>r!a66tbz|9]uv}C~l++m>D=(5SG<G+R%.hCTxP@bc/qTnT74%	on=ybDgcUtDW22_Pv8/"@YMF0bJSliHH<b-j+
76$b~+zRe,B& v>vh# FH_7z9'/a*]1e@<0!za<W~F\cK?c HF(AX?sb4/Q"+eH]suX>V_/oCX &!8qJu* @Q$dpm7$Cn?C5_."M"x 3H?6Ms<PpbJ@{iczuO6qP}Vq?Go5o`iOmq7VO"cQ'(sj!wiX;=:m`%7h%xSff,Gy38G`v/U`vJt#DCs;;N`v#V LG%kE'5Ov5GVx,lzIO|O	EWX7bL*F%3x51RD'*kgTd	r0zu>;F-TX$1y@3ADL.i THt=$nst#JiVuBxMJH~3|e]sDZ, :Qk YFBm3_ CUsv`'4zHUh:}SqFbDt$<"X.-J[n64N-I:"5>hz|)uJ>$]b=_zG|]s^j]sR@;\Dx
eB.mS{c$L>gB$@
.Zl	!E*5Mz;_O@o9<#^JU`T+Q,Hhwit!TR:xr>G
8Q?{l5@c,NV_7FI0W].Qw~pJ2X\uso4 #,Jk/ 
VB5]&yOl%~z8d&:EW`Hq:t:[r0b?iw-YsGC7~,hFd@Gkb[pZzbm:^J
F<.<_8e;Wa o5+C}3yOc/Vo%JE3bE	 4IEMQYGU+D*2>%|7Ni%)2tF?\90y1qsBp0!iwOM^/	0bR^QoD5R!6zB	
d?UT.T{8ri= q@S0+TF&% [L{k=>=EW v2	a ]	$*Y WM{27^r@J*}?<$4K;|(kn=d!H<}QT`E}mhL%@i-8bw=#i~"/oq	AZ^: @W	tz?Hyc3o'P| U]K\YaKZUP$kTp9d=2_D 5WdU:^=+Io"LL2Bs`EoQ#4=DTh"AG ?3
_-"Ij\6t9["GCZ\(3i2 'KYIGLm	BVQr8g#Ww& )FM vM-CxcHGpg9.m\,+=6c%]
B6*@)8W:dk!@hsA#hNnIVagt AL$^Bd:u|u$^/H o0rT(6d*"{T\.@G'i=>1~@HF"H[~;JIGMEStvLyfQhW4{EyA"]Ewo3n){<.GwCQo#<U'e;/4]sE/X~3rc'r!md_WyN ~l[h{w)Icqh?RqXy(xe:M-R^}.z!]@ +J Gi{.U v?LkAYPADa])_%
=)fg"o"k|	HE;WPQQ)|:Rgf>_rW-LT~DFtJSU/zr9SXRP	gxy
~PV*uf}	@mx9xDg3sP";]!6ZB^T*,s:I'6(  \p9EM3uebK-S/ywx-GXGOURRiane ^1*N!Tp0b4Gz)w)v;BWp{+ADG7[/0z~|ee<&8vo	%hBH0lL%=iCx@9f2 zn]g)bZ$@m%jizJ	LG. ){2("qAFX?foJ^t~>ZJzNGPzd/:kU$<"w>?Xj4_P(]t%-jx'{o4TAw~
!PHWhJ|eIG]mO0,^j>NXj'z_PFpA\po#s(-<'DHMQA<2pZ{CPdTm,,k~e%b77>b1rPOOEz>YRo.EqexaHusR(:GB;PNN}\QNi5={6VBT=vHhT{e~~El: H$L:|k{Iv	x&t%Y&zP!T^f*|
qk'bs,I>HBH	M=(P 26fDO|Y{"?L(|A%-5y\a%Am:;}wE4HgBPee^BR
BO|Sxf{s	,Z*k'? `z(LM)k19YQ2<zRr/errzfwxUIy'`'/P!"$@U2B16r{\iUPUEQ)IG#Tma4_
)Rt
[ulZ+dJO~AAj
r@M]F;]u?	 $M	5t`htmI:1B<b#95^2K+	
hD=n2ejlR9S(!UB'BpfTtg]k1!zPSg-w;!o@n/\Xfn} "wr+AZDc PI%Bq*tHeb|PaUh5yxX,vYs~P4^]"^+V\GR{yg:n0CbdeQQ~; b9F>%^W;AjV2/cjjyJWy	.T8B,x^?|sSML?l$5/(teG-
Xv.T[8PKGxWm@=CRJ9~{5vy<j8	{-b)zO[,>)IR6Kz
'X#L ihmj]F\qACV~^0D6y Tl) X$L`wzebOjHmB}:Xyl4[q.*N8C53.+ZX8 Sb+r``C4Avs%X T>m\k(	XLjD9'"'}"^}suTW$h]pU%MHkjWVKyhmm:]g@t)Y&.YY PgyUhb,sGO=[,sTIE_idP*D	Ulv(Wb+6>s0z}]iBbGFX
| gMFnPMt*[lMa%<@v	Beg.(*@VA_fuhaG|.z8<vJ& b+B4&Y% d9_5-WeW~(HKQdXgu&?Jx~EMv5VWb#IEnE-7c$2_2>;"IFogR<Jz<%uZ%\zLk;N7/vBgl 1t39VwulTvn&	oa` ]lS$1j: /0m'{c,(Tzf&ye7	J$meGj+`D|Iuro-92ypGxU4Mrkn<Y^/2+@?dRPQ_m<V {ZZ/y!&CcO A:4z	"t_oS_:$]f6t49zL[
WJ1^w~a:(1.}]g*Q\2SRGf~gCC:Dl,bc_is`8:C u8,%jS ]WL:?t.HNH3y?Q ="0WyaPK" nB#cGM}tQ>NF+DuPU nA)=IqB4JY6~/@O@J?2ms\4,*fzCN^t5R<x[79jy:cz>Ir.\=Q&Q4fEb-JRrFEi!PX`ETpi	7HX`B7'oYhA-6 H5%6pymx=XImq	.-u/GyJ+_=JZ@5BC6@SXX6aW2v!
?!%z6#$'dsX&Br$SNGJ4?_^c3&s	4{dfS pz5O{}2FLGuG pDuEsMph+LlUF%vO^=stg_+>?0-z~?9-xbl4#00g^@*qT1nD|$t1slswjzSj$rk>Sf(hoe2giCb0M?mI9^g1*AYW#;Ih]PK{HL|y@#leYi@ }@\_u24/uyFM2B*_"xO:|cU-]s>RrP1'A&zL#O9@V~DyXb7`DdJ0I
KPB?0?L` 8}!-sM'FcBeVP`l6/];E|xNIMDy5/`H.KT`g375=jD(* _10=*c=7Ih@y2kb4	3P0xm/VcdQAX}f'_(W	,\\ ccD?)6me2OiBZJ:ammeq;v=9 	w
3<)`?2(#>L3=u,3*Wry: _3/S| (/[',sd)1 .-.Lrbal:avDo0XS:]|~d_44Gf~^5kvX%=]z^U+:9t#F~ry3nR=CMrFT
P^`5`9~Q-6@NFT&<\7Kp_xA>2iBs_l]" Qg}E "4 k`tu
bv7z+`p:&[ +FTG6<SRBAF+7TTOR~J?@F|}^*;3SujM<a#aM!3VK-iC~vH.Taaums+4};t!
Dvj&]lL60AH5BVs*Vh#ac	Y,hKy"h,VhU8=/J}v%2>g<&9z-,/[8HjsH dFO>0ZTf3jrQ!5VSLV^v@]AH1Aae+_,!bTO@eB jeKv
 sgR$Y^&VoS/sXt33:U/)O4 EEBzCFc@tQZRAGW)&OWazx5$sEr$+QTj4CHig_
j-Wf{\Rza^$swTB(tt`
$2|7@AxH
BHL&'ZXEhTS%sAL>wwL=&,yf3n?]0]71Y#c|~ O-poFTBLsKEhoU8{ >1
wM%wanJ.m;+NlBB+Xkn$$:mXO;E)uA/I)aFa7h_-Wg]Ae]j3?0jBTKwOie #}22AwWygY1?gj	xe_6n]N-tRkmt)!Yf^&J] 'U5k<pC]75hJ>6JkK]MA:aq(+UH8y	F.vDe~v,l5-g|k^ml eo1
J@)^Gx{ Rc
Brb4NJxU	s@30wFhnuaT8{9"(!k9+k4?`H_a6x?Q^-JuH"
U@#?8=:7d-)@\}n`c%/V_Q.*&;aF;3+g5Pz*	A+_}XI)
>FC4gqgryGWbJ
Z_7;#'tOGLDAu/wAv*UDiukXVC$]wV{38;(?1KTi53mT%E	mj/'sq`$ Y< O=~V^e6~bF	hfA-$O%nRZ9RM/GaIC.J:hB9&5{AQCe%`-?RmUb>h v0oaP~h#kTXW3~2k>TWa4\LY7/ 9&.^]`3 MooT-VIT	Z-AUT*U
n!sPwa"}QGqcW ".+:kDc.M`eMc	]S_jre'=<yY[t
bVA!.dRedKgkTG>*)CO	St0rE`"KB}IF=CcE&_#jzKrSDXr-	+}IH%<H htc.>K5G>|5&2W$1jEk(tV^2+FO6S~QSzVX>+3PAaCy56hNfa]R_msVA'@Nt'CW8o-I$YeCH#+k(&OSGB/1]Pa{P@0G#VRhh"xmB &hiF`qpB8{-=J,(~g:Fh|H~<oARPsp/y\XY-s /z,b/x)Y9h^cRMN~d1e`{,wMN4(:i~[N,u='&_w:=	x<fT7oc(?G%%hZlpS&F<w/t3Bs:c9eTbQ$&cFy{	KLrdj <#$`yqCT ]!E5"nf'@J#X9$IL1J15Ms+>L)Wh4CHm:'kY~WPprM9DYIR5 . K=hm&d	_@Y">tu*0'=sA}5D2IWbPM4naN,xu]p+!"viyn85x}8Z|HwZ0$n+-_%  ul7FUE`@j9C(}n)- uTi$!RrFn
 OCY@d;}|]."	y_F1n "79),h\J,,OTP-Z%gEs:q^2an=9pB`!7Sn20yQZ4rV9fg}e;jG>iJm[<k# 	C=jO! %-SL(p2]m-M}T9%~=7NWB!KAe3Oj2	'1|pxG;|G((`@QzlNT$(Uu0CZtU$%;K$%.G8g`OS}Z?xhFdS1$UkZ;:OWpTC.J.{)P;&G+c;UqyH1 b0"`sP.-DxM[m+) RRz{z	B%80Oou1v-w~8}:(cz~.@JaL$(pjNJ!Mh0)S9L))TUu)j9	E`:S-m%W^!)	NG>.	q<_P}z7qP-b n)KHu?]YR!{Q%48L`q{^ie5733wR/)a{yqHU$4(Bun])5HZ10P/8`u:hi%i!jV#1>a!?k=y^.|y9}	;]yD	SX '-T?+wqT~^9@jkz1Rg.L[wNxF^j:#=H`]
@Ew}`Llf^teVs1.XiL 	,5.Q|vfyyTv[R>  <S3YPFKdO6B1t2c{M&+~KJ0#`DxlwE es n_9pw<YOicC7kg6MP?QFDiFRH	A+-ay[|N5Ab Z '<2#tzXaO2K98u|KNv8;*r-)B9+9V=(z<U3t]CQ\ >xG(nTEH9peA_R;r-;}n
7w2;^BDd 
v{k"H0L'M_F&Af"7aYFR~M]b6hqQn>V}fqiDoUvcYAnU0aq9e{RVpG}	[FP "8Zrk~}Tt~]#
_	.|b2%i[6ZnGMTPHTE;ec\6*d>F)5\|
Rf	zM8 wmU6b.ibMS`?o]FE&%gr58usaGH(*Yv
SU+ISYa`na$W;@Si	z`B+bY0Co1HGX='6 <a7[pS]st{mQU`q_lm#8UZ'` jF_U </lU>sW<(qxMr.l[`\%~b)&aGX+WRipqZXv E,@BV(2&"((hC\]y>j_m|$!asno3=!7b&Ji-er4t5JLH'LD9>~.u,2Dj	r,-t+PN8S.ddfM)`%a:;QsO89q<%GhQL]><7}w]$JF	`D8T?&qFg%oQg#7)xg$2C@	kq/6fw"
X>~9Gm0X <zub'-Nbr[WGrG.$<qqY5^xd uYu4AehwVC|.PVU9/)e6|_%/?G`Y5G_xle-Kp;Jrd0rx0m4^9*N|p_zy7pQUs"X4D"PcX5 vVa|'e8&<LjZKn<^ R5-VPvnmA/p'HjF9G ~h ,LlwF<{,bTY- jPQ!/7 5S><0Tyd1</%biaFz sot
|xB[P?|2,W[M\_&{JkFs<$ W'B<r,'7(mCN5oZ'[Q=Op?j:0[&f5:^
xR@zY~N<qPg'e3X,%GH"6K!<xaVc8>Qr2|CYR$?,)HTC; 
|OdQw\O3\,/U	=GwsI)XI^b8&f52dKP~'2EMf[yfS6}P^gn@lgc%y>Fc
Qi1Y|ro4XK~8q}LhK XTM|<xS<t<xoo-uGhtP7>l."|w$O3/WU5S-GV._UJ1=/pptzgO+b3RmpVw)Hj0x+GVzq;1,Lm$@gU~X-'r+~>dyd4u#xnG1$%m*obtg2~h$a0sJndMyaz[h w<LG4 V FL:A;'qrA8J'sHfwm)-NtVAlr{dCIS1&b=y'#z71>;(d#_J:R2kfxPiQ>AK[p0*U=;w`g_w`BpTwv,A;Y!b{dQ3-|rQtO] Iii$-@HY|+WD>[)V: p[g7)q!i|78@I,bc9)GPWd8\+j 9~7>{~RLe+HJuj?./b}XX;}~AU9ewE_uT

h<s0%f8r(fys-%acc
~JTO~*oM9O':9{.lUOl[XjHxxz$0fq/GPc0p_+RKmy{Ah3w'Q_k|75'o9/
l{.m-w	Q,<B&JD_FkO\*$ ^;d w 5k`}
C%HJkLcF@JPfZ^tW!@	2,_7Qds;{aTt,z@Uwyf%rnj
{8p2|/ye@"W)s)^0mfE[ASY<8d?:iKHtwwHwwww tw7HwwH4 %HH9S{=;so6~dZt/Z_	]UD5%'>Yw|5	:o_(&&~: ;V."T< |{O-h`1R(WYp+3WOHM;!S.u/V3VI7l>[KroPA>L)OCd l+`F aS!M#0[@	N]qKVuWMN5)W
#hmjB5c!:?w#!Zb\7kyWq)@R.Hsq& <<!}G>: 
 5 %b}u'R|T2F#CCFS_AC&{uX''#)$@GfXGz c|gN/$7~`~I&{S	DT-'9"xDluObOU52[Ch_&@+3a*MM$y;_wS3gUwkG&(DLR|&K	2v?_7vQl}i)jVb4	6DfT*V;J{1q G2lL"q yX~G#jZ4"Pk52}'aejZ!
N
b}$1w@}?{ISC?xfGa#lDJOvD/ 4Go[Q-U'';;M]]A,~?.fAiN8 wnKC!Gqqe4JWLs9`"rYHc+}0	21bKaWh<7LAbKO>CVDN?+R (HUOuG@MI<}}-/F;rA~.zpieF6+(FvIuDXKqPPgD.5BavCT\X	cPq{Apt|h:dy[P>$-}k5N:frtKv_i3vcm?Nl3 BDagVC&hJ&@1-E56s6}@pyrJ,y&4{J_	.myTfxb8XDL(g)Q (xstc<C=C N<*bP!vI)t1eCM@G)S>CH*	6sd(&;
>I*D#!Q3w#/F8\x 9qZ|e$72/[uOO<x.utmf[alh
O3W[j`IC&IdW !h|PDf$
Q|&Zq_'Z^8@bGpjP8BiQlNW1.(-#)t?
-I@*RuP8v_RHcSe:(tDPQh2U:8$J>_O&4,EB\;r..Zn~SE8vEp
-zr lVO[z4@:#$FL/y" U/<gA	
jReBc-&&Sdl<&DbANQdL\	PSQzn!OTML&fu`:/"	A:aU`hE@s_cf#G}\	zX4P"Wu;?vVsnOuM2g$
~m&1BlCo	?_+a48=~R.5_eC<{C=\k/ll`-V,TNDyn Zm}S`{wbS;n'>u*F7QPX("HfuTC29@ h:<n9p,-diM[%"J\@BD'rWS-Ab$OxF~.bujk>7e
p&Sq+^LrEw]`UakafH!{a7|9G5<8
]&QpiH7x.d4H%8t!._P+(*\\]%n7eEk5Q1=@}AT@?o%# oDb:^E#)8EjG^(H/pom0\_Ttt2E0niOM*,2Z4i3;(.en]'S+>0|I=t'@n{z^SQ,!8(JT"9s>%li]G%CtF1ya?EQPEgE\X~:O!bbEd c%jT^n>0[AHG!scS:Mn|jc3xu4ivQ LW3.d	 `uRl+GY>wB8/JKYF/	h~|B(7y"Qoh`f*ib+F=1-W3$R [s(x]u$rI07(`dn~,m WS?aGVP=)S(EkCXf4L3_BT63lKR$0Du\*[4R.S07CCAjd;b-G8v6D_AF
:+r 2!kWYK~ LLWC-UF|($bnH\@%(o/sy2D9.0bd\!ZC< N-vq0k*mhRhRsJIsXZw^0OSm*+P`8=oW`S'V|D@1|V"R#h{	+v978X,KRhE;S_`&#phm*l%GH

 6a
gm/>(rtSq;75BKWACU8-{1 hK&;oj(n7?]dUqUEc; ^\!bHL+q:#l(MO-C}q^4/AR-txkw>$alF|?_$!#&kk?Eu@ThL{-fUdSUZh< 3mya>,L
GQ_Tn,vP_T'uv"HmQDJtCnf(%g2WVU(	?5nfD<z b/U}~I6rD.XTm!/wu !,'_dGQ<<sh/0RU4YUs_ywdl0.9WEfW=P%6mlZ/ {i X !|U'wvxKO$Krncv(n1X]$KR>	!/!7*TXI {cXVSGj	)Z_'(XB?z(x2Ku5=|O0}kJ =]y&++SlP|$<K|+DV,o<YUHD@?2^d=1x'jXs0=4Q3Ipd
l%#\b*U6*qu:-G;>:Yop9 yXb!$iA>]2 SE)bEEQ`M 0P>yNI/2Ry~u(?")G(o[ G~kN{8~W4)HC#Gg138h<7<u{3nG};~
 O~5L8hrR?<AHBg16jx%2$'[@$ja gx_II=nw
2V;BPrj3	q0{[|Gi^_o! <EJP6z~Insvw_U2D2P6[,7^QooX,NX 6O)(.@BI?c[W? 3({ y,rpyN{#j7;dZbqnFQ}frw$qSKzz+dE^$I2
PBm< n$;<ko}0X	$NLFdc~-<\=2viM/64N+BDD+Ekq-{\hb0[? |Q_X_,R&-s"e]rkLr*zi99%wJ^t=SI/:{iZ+xc;xy %yUD,V>U,!+b|*l.71KB#<z|:^[MO6/hm:!VIQzVgzYZ
D 2k>-`0(QYqJR]+c<]NJ^h5k++jKl J	9j2CL#Cs"P* A}3sO%z 8N[+T?qbdpTo!U&OMIO.tX7l0u*Z;RmI*nB!v%JvHXjZQQ5_Ti=Ua?AHq0>Qb;w*-mR?6Y}AT1!K(~@	G0Dj0j*uffe}&nub]~'ppx1_SQWUFIm>Ma!VB__dwlo;c)	o*7]"4AE0y0D>O5i_wbW
{!c35q\0M9@KpMoOvgx_Sh|/:(G7	EPPCe$w\ PF|xxH[)9hs"Eh'HP-&6gXKe~3x	D,|)m
_7DL;l	e}%ITHsA$4+SgD$;{Lye0MvQZdVVez~Ev^(SjdnT0~50;5O[\"XsV$t42jEVZdS|v(GG6K[!x]9E'Jf^!/8XSD$K' Vy?8z+Bp7xoGNP2*L 36r&DI$]Xhd .o04HRO6gWNL~2
p?-p'7_
:R2G"%pU)WYG.;$j };u|o%w#Up20PZ<H^Qx YV3Ot$%@ vQ
%V'AQ$iC3P=2n^sz8}M/O2Ufblb nRC)~
w`ZeS?'7de<fHRW@N&T`CG(JDSbv
<V]xt2EdA-   PoV2U|$_kJFN	DS@VL *2\t4W`T)!9] jo?1OV-&eAHf{OVU uN US$B
Y([TYX[XqTBxs>|&7y2L~kUq==_8&?Ry~8M>VmU(,a5CNhXKTwUe	!N&df~M@dUR33 pYUW}?3]AIVi!~W;G/tU;N!X8B?@Y}	4Kv i$ko@?n2~CfQ=@h-+v|/T<^j]4N1bMa6w9XmE-r|p\_N,/yos(zawIuc11qS-7291C< #1So J:jdDa'D\QX
ihsA3q]|y YsFy
~gvz;dTEZez=+46da@F/WK][Ou15>0/WcU]wV(Re?ptF{,w;s"g	-wxu4AY74Cv'GS:rsbrYH8(#{e*cT5`D8y| JDk/i4l\n!!Y_fc9dE>01GxN0F:!#d9e-dJU;+qlCu`&oS#jhpMy')mB#dp_L>>>	wpp-P<CVxG  W	pRb.{QU:%.YLUMeGMz.>a7vL|:,81"#j<'6~;3KeD/#rr$Sv}uUSGDO[C)pQGlOD1-rSc@YGdeBm%]
rt&7Y(M@#=Na{]cIUkNo])bJ+ZGUG[ n!lr'yH=#!*6#wH<yNf
z-kXABE;<RB.r %kB64z8V	8=N==GOB772[.@ 00(%E6Ur	+=u;iaEO9q<.ws/X`it?mKBS	9zdn$_<iHTp
_WA6~
<yB"\8mrh!$CBs!&.K-k`2)z8,F, (l{c	@$Q"WM]'o#mhS4\lJ*MzNE
:c_o%1UAO:6(Y"b,M#2@Nk/bTT8v{\<^t7lIzuzLoY4%_8Vp@j9o=5/:8mD p7_&is.Vcd
%Z{
\; Iadr%v(_lifJM^DJQ$[5+aq9d[
\	;C/%lnr|r_]P`m,w_ZzDy,c!#{& cR-T_MUb:`*RNMh"}S%1)	7 4*5}0+4|P@3w/=O!kWZNY)xZINR_c+A5S
3~<(e#3)]ilI0JTwHsn>.[[{1((uu.ExiL5Fk$x~l<Y:&k3l
J88\N@~6.W]$1ePCiq/?O]^)*p|5Jj@<Ce'V:Qu@J3|OD2=NnP
<P&t}XCrzz8:+~ZDvB| XL+dONi\gIOkd?Rw8&/.r,A[0fQOfj]wmV~USP_ g6jE&&<@7(e_xP9+0!cg{9+A+}#`+\)tICW>rWL=tu!H1=77s?YjOmJSl :bJ"`4";V
@r3bbnyn\Oy7w!kL^?wyL	,l&5
\[<!6+,LZSqj
k7YSH_=/_r4 HwX\_O0]{cE}kl*dT(l]U*/IJ,4wWNFA\TMGz83^ pF+f b
/ib%;`jldU4dd4=R+Q{`sV ..@1W1XFwY
-j,(S^{4bU%~K$]f~8:)B\MTWc5G
!|j*5.T!^`ttzhgai3)2SAsjkO7'VD*4GBD#~8 i<w cg0dAlTUS)6-Zp(rCc5#`_#"<
LsTldGJ5djUudR_@+e,lVG>EfM66"hvIv:|[U@H:xNm`IAdb|,>9O GK<~%%TSOIj}'BKar76P!$=M`q(UwV~k)/pLv*!1V+qKVdAj QIM\|g:zBkkmYZTs?rq{sO8[PSDW# %M$]i1. mAEbPV>Nh@5u9cKgB8vvi$"lC}&|jF]W*Cl@wBrcJ2^K'j:eYPHt ,A_Ws5`]I3S@A5Xi!8BQwuN_t9V:/{8PV2 ~r^$ki= 
.Uo5T FM;OW.;\u9f1=\ uj>>%JazM1m@`yJ~QM }u@Q%}\7- 
PAoz4^&%#'C/C]%.=@p!wD];'(T7{qJxqxoRsxhF:u~'Z$Csfdb)QU-	2#`3g^xO~t	$4>8!kLN5P6aTZ"GmLc7d#dS[p)4l)KbFh~_G{WSU )I&'"ssA;qDFN?:<<%siYqW:\ub8nxp[RfQ)/)N7$LKD}\du/Y60`3 N<WWu3EAdI B]~s^\Qh8V=tcbo'4bVWGVE.V\;@~ouYa!!RiRZu8g*LDyaW4#a^E+-(w-3VEn!:p[d i%9)U1;w+z%}99OCFvZ}6g-3~g)/UfT4#:%Ha2j}])wRL5)|FU#z[bhp7w c\oW3W[rF/^sB.x<!h`"@>b]QOJo5]5-qGbRnW:H8B=K!;4c>0,2C<hdx1 'k$WvPF%2 I(0\;!zZ2  k8uHxt(h9bdPpdjl3DwM'}B;vhKF<LX`40 Z2/M}<:FM,I. N4(J>:^J1` ,~H$Zc2 3h
mo.gx+);hH%%AQ&j^fGgI{Gu>0iQW^.j`u]<.JG*?8gb#RFbX=|	>9p(nf<$M4-k+P<n;P$:h}03IF~F5|M(Wf5G_/S`K4=I$+ @Gqhs9$l*jw87uYBX98[":|1DsQd+xZ^5w_&O#4,dS@|9	WF!JR\{Ts[3NAnR oPB	;_r&q\K[ROMu<\PE]_`vdd(F?%`W)&7xBXkeQ@DB!!1zV'b Zho^%(*f7u_-wHlx SK>yJ)lLGk+^?1m[kFd*\v3IJ>z%SgAen
y[4`=-j-v.lj!klt5mC0CRrhy7;Y<tV*s}h[YKin?<'F]Q'+x	L<ucB!-6$*g	=fs'6S{m8U!UU`5/zE.;}AmsG<#Q/z|:t&(~v$'Qu.lWT	jj-@6FL0$Or[Ps\ k:u XA//Mq}S-}6;B,kJK%EO2}xWl8n.9G9D^%91bDiv[fkW'/=h6
jgXShM-m3|<u5s!LT`|)l
e
=*E5MZU06D@ya1EA[}6t EME&Ey}/O0W\zdbYsV{{\'!t@,gyym^8uK*6UY.,\ Q@M N:Vzj'|;8&: 0atG`?F,`)or 2$!x~[/9chE<!D) 1 _$A+y NuG.v@f ggEiixx:"_a <)Uvx4xIE\uvIh{DW >}f}p\EP@
AGO|!E[d(tu;+N\:Wpi5d>t_s,%]RY^> %A]~\Tu|&#X8x)f+|V
*'u<
9 *%Dy3^+r~PiH~H=@@w ".r
]2{Rl3m_JR\'[EJruu$NAK#%Vd~@2O[Ya>2~=#CA*udfGd0U6(O@Yw`^:wts|_$;$=t_51	N,bW=i^Ldl[7-Uw^/eJ\+/(;0(4m*:	uw41C#)CTm8s)
y<H>IcqE)}WFN>3eKR1]'RXIgC!;TH
mUi(W%T5mFSRzs"7?
8Oza~|4D=S'NfzZ!wXn@#wE=t$-Mhs%|3hqvU/eX-))>^/s:Y[	yJtv,f
)$HkW;G|yU2z$#zm"MGoyev}t@XByT,xy	;[}x
Qw1\J+Y+$>]!N z
 GGe=~BNH|FI]Mi,r-MPe\w~j2C)a?RGYq#}!|pgFCG6\dg>/KvlLEs?1MSnUsT]jE1B@S(4STw&3s)L4dVMky+BkO`'d
?|J7YU)(p+p)b:gfo	w~=.f9Fv|j@,C'h%>q}5tL>sNCQ,UM
E+.IxRKu/?&aKnsu>%&Cr%~!Psq h0F_gUcnI[,+g ci=tk 5&_P5_5 1!DgDTKgJ@,|R-1~rZ|R-kZUDc_	O1E0wAzQLpo"RE#=.),mbi<H4qBeE\HUsh/]4QQG)TIw<	_AUjM6bu,O;eN_7f4F)o^/s=h%!qp UBv.S
q:yKv!5}f-C/@FUk?30{tmc*>p"Gf fCmAAdC5_k|30^8`QO~H})_FlAa!={;tkU\Pl$V.&\Ov*4UkuyErbw$[6.<]rZg]$AQAj?0,S{E{'g$.:x@Qe`gWLoC\b]a=u9|U:*Y=gPb4V4WiG:^x+]kZ Q- C,9lS\z/8ni[A9[]rAg3cSg9~?-}8M<,<aJPox=3y"~T?:Y*JTo@x
|V\a!GdmGNdp i5hfaX7	,$or"n][c< 'c1(Pc)Mn&^wr#=O{g}Eav#Os>-dH;:bXoG`;ABU4E$uC,#a\ ;I"f$\)hyzzh2!ZDm5mQbu+s=0, 4hTvR'aT.7dj!Nw2	AL~PDQ|nDmU$i|1<:t	j&?Dqb@S]Ixn9mNh373}+cLP_wlI3	Yy!2_eTQnrdr)WBpPxF}ij[dfVAM$nb	6c	"i$1KVv@	 !b]gb~uYQ/Dx	$:==_~$ggSh~i4Q?#!b*0:ES\wsQV_%qnsQemF"XP1z-w: d%1Xe0^0~wZ7`\	. ~	'%^hc;*OI"33U6Wqq5A9E\vz{:Q>tm8M@KJJ5J*,ti2o	1a5h#q66c|AmXZ%`7|D"chBH)D}uT7%HwttwwtKH7H%!RJ3;yMR=*`0>ep/ZZYi1hl[_^7)
h! V+LatoBO RRKwaSZ>f!dWOP~$ J?48CT#]_>fBy4&)@~%uHQ\ Az$-[A@)j[SA?SUFpTt>p~k"ZKu[22/*b7s-Nd>N/\p\xiGL1"`9YCBthhlGY
|l/oxa4<o<qoIr P(h8=M#g<8 5N	Z,[6=_ uPOZ-;B) c9e-{] <b-r[m1xv2(T9b6&4@Xf:xI+xt,m~g?zhm#09
d`/&G-uC?C|KsTWOys>=E OhOXD!m6<#_F"eIX:x0VI~K<,pQ7"nk,NCNZkJ	|kwkkF$1N
pcW=[dFq1LYb70=;UH55h>+c03"GKZD-9nKVv<08@Lbt8Dag2A 494n)<<b
AahS2R2hQAWddHJ6i[xf.Qh;,xNz]ybYM,!eKcZ$<%or# j'T7a	Jj8pf,u]_n=-#+$!68EFo<=i|Z(h9A[bgzPw?"`=02[DG	E<Dl-`jFslpk(ny`6L`=P'mcf0psQ,_fKA7#J[mf`d5MZ~MC^OAU/%7*wYdT mK|QLonFd0).#shK UFo^*0ZdE=rTQlPZ,+@,6S59py>>!]GR+4O*	zevZVzE y(8jLnYF-$5gF+QC'
fQ?~{7H_}\5/6l6oY5&N,>sCW=U9Y,6m`|lx3)=LkBh#qq=p/n"vtYVgXxF0F7})M+{_x9_[#@<c Z<* &1sH[dUw8QS 
~	`lXN}C4i0i6vl"u2W<Q,/R~qUO$0B8dU 8%-MIU0n_-SP;,v/}mz5SsHDc}jTQ)}HhuQ;VV%{f!SQV|f3z:
c={9<<[
wr8]	A+40<(N, RqRB6C (mB'8^8O {meFyaoJ*alxFt"|%`8X{.&HJ|/7 $@ !q;/TY ;:A[s8oyuPhjD.2kMkQ